diff -urN -x CVS -x doc -x lwip_tcpip -x calmrisc16 -x calmrisc32 ecos_20050912/packages/devs/eth/arm/imx_3stack/current/cdl/board_eth_drivers.cdl ecos_base/packages/devs/eth/arm/imx_3stack/current/cdl/board_eth_drivers.cdl
--- ecos_20050912/packages/devs/eth/arm/imx_3stack/current/cdl/board_eth_drivers.cdl	1969-12-31 18:00:00.000000000 -0600
+++ ecos_base/packages/devs/eth/arm/imx_3stack/current/cdl/board_eth_drivers.cdl	2008-04-01 10:37:36.000000000 -0500
@@ -0,0 +1,95 @@
+# ====================================================================
+#
+#      board_eth_drivers.cdl
+#
+# ====================================================================
+#####ECOSGPLCOPYRIGHTBEGIN####
+## -------------------------------------------
+## This file is part of eCos, the Embedded Configurable Operating System.
+## Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+##
+## eCos is free software; you can redistribute it and/or modify it under
+## the terms of the GNU General Public License as published by the Free
+## Software Foundation; either version 2 or (at your option) any later version.
+##
+## eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+## WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+## for more details.
+##
+## You should have received a copy of the GNU General Public License along
+## with eCos; if not, write to the Free Software Foundation, Inc.,
+## 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+##
+## As a special exception, if other files instantiate templates or use macros
+## or inline functions from this file, or you compile this file and link it
+## with other works to produce a work based on this file, this file does not
+## by itself cause the resulting work to be covered by the GNU General Public
+## License. However the source code for this file must still be made available
+## in accordance with section (3) of the GNU General Public License.
+##
+## This exception does not invalidate any other reasons why a work based on
+## this file might be covered by the GNU General Public License.
+##
+## Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+## at http://sources.redhat.com/ecos/ecos-license/
+## -------------------------------------------
+#####ECOSGPLCOPYRIGHTEND####
+
+cdl_package CYGPKG_DEVS_ETH_ARM_IMX_3STACK {
+    display       "Ethernet driver for Freescale MXC Board development board"
+
+    parent        CYGPKG_IO_ETH_DRIVERS
+    active_if	  CYGPKG_IO_ETH_DRIVERS
+
+    include_dir   cyg/io
+
+    # FIXME: This really belongs in the SMSC LAN92xx package
+    cdl_interface CYGINT_DEVS_ETH_SMSC_LAN92XX_REQUIRED {
+        display   "SMSC LAN92XX ethernet driver required"
+    }
+
+    define_proc {
+        puts $::cdl_system_header "/***** ethernet driver proc output start *****/"
+        puts $::cdl_system_header "#define CYGDAT_DEVS_ETH_SMSC_LAN92XX_INL <cyg/io/devs_eth_arm_board.inl>"
+        puts $::cdl_system_header "#define CYGDAT_DEVS_ETH_SMSC_LAN92XX_CFG <pkgconf/devs_eth_arm_imx_3stack.h>"
+        puts $::cdl_system_header "/*****  ethernet driver proc output end  *****/"
+    }
+
+    cdl_component CYGPKG_DEVS_ETH_ARM_MXCBOARD_ETH0 {
+        display       "MXC Board ethernet port driver"
+        flavor        bool
+        default_value 1
+        description   "
+            This option includes the ethernet device driver for the
+            MXC Board port."
+
+        implements CYGHWR_NET_DRIVER_ETH0
+        implements CYGINT_DEVS_ETH_SMSC_LAN92XX_REQUIRED
+
+        cdl_option CYGDAT_DEVS_ETH_ARM_MXCBOARD_ETH0_NAME {
+            display       "Device name for the ETH0 ethernet driver"
+            flavor        data
+            default_value {"\"eth0\""}
+            description   "
+                This option sets the name of the ethernet device."
+        }
+
+        cdl_component CYGSEM_DEVS_ETH_ARM_MXCBOARD_ETH0_SET_ESA {
+            display       "Set the ethernet station address"
+            flavor        bool
+            default_value 0
+            description   "Enabling this option will allow the ethernet
+            station address to be forced to the value set by the
+            configuration.  This may be required if the hardware does
+            not include a serial EEPROM for the ESA."
+
+            cdl_option CYGDAT_DEVS_ETH_ARM_MXCBOARD_ETH0_ESA {
+                display       "The ethernet station address"
+                flavor        data
+                default_value {"{0x08, 0x88, 0x12, 0x34, 0x56, 0x78}"}
+                description   "The ethernet station address"
+            }
+        }
+    }
+}
diff -urN -x CVS -x doc -x lwip_tcpip -x calmrisc16 -x calmrisc32 ecos_20050912/packages/devs/eth/arm/imx_3stack/current/include/devs_eth_arm_board.inl ecos_base/packages/devs/eth/arm/imx_3stack/current/include/devs_eth_arm_board.inl
--- ecos_20050912/packages/devs/eth/arm/imx_3stack/current/include/devs_eth_arm_board.inl	1969-12-31 18:00:00.000000000 -0600
+++ ecos_base/packages/devs/eth/arm/imx_3stack/current/include/devs_eth_arm_board.inl	2008-04-01 10:37:37.000000000 -0500
@@ -0,0 +1,101 @@
+//==========================================================================
+//
+//      devs_eth_arm_board.inl
+//
+//      Board ethernet I/O definitions.
+//
+//==========================================================================
+//####ECOSGPLCOPYRIGHTBEGIN####
+// -------------------------------------------
+// This file is part of eCos, the Embedded Configurable Operating System.
+// Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+//
+// eCos is free software; you can redistribute it and/or modify it under
+// the terms of the GNU General Public License as published by the Free
+// Software Foundation; either version 2 or (at your option) any later version.
+//
+// eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with eCos; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+//
+// As a special exception, if other files instantiate templates or use macros
+// or inline functions from this file, or you compile this file and link it
+// with other works to produce a work based on this file, this file does not
+// by itself cause the resulting work to be covered by the GNU General Public
+// License. However the source code for this file must still be made available
+// in accordance with section (3) of the GNU General Public License.
+//
+// This exception does not invalidate any other reasons why a work based on
+// this file might be covered by the GNU General Public License.
+//
+// Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+// at http://sources.redhat.com/ecos/ecos-license/
+// -------------------------------------------
+//####ECOSGPLCOPYRIGHTEND####
+//===========================================================================
+
+#include <cyg/hal/hal_intr.h>           // CYGNUM_HAL_INTERRUPT_ETHR
+#include <cyg/hal/hal_if.h>
+
+#ifdef CYGPKG_REDBOOT
+#include <pkgconf/redboot.h>
+#ifdef CYGSEM_REDBOOT_FLASH_CONFIG
+#include <redboot.h>
+#include <flash_config.h>
+#endif
+#endif
+
+extern unsigned int sys_ver;
+
+#ifdef __WANT_DEVS
+
+#ifdef CYGPKG_DEVS_ETH_ARM_MXCBOARD_ETH0
+#if defined(CYGPKG_REDBOOT) && defined(CYGSEM_REDBOOT_FLASH_CONFIG)
+RedBoot_config_option("Set " CYGDAT_DEVS_ETH_ARM_MXCBOARD_ETH0_NAME " network hardware address [MAC]",
+                      eth0_esa,
+                      ALWAYS_ENABLED, true,
+                      CONFIG_BOOL, false
+                     );
+RedBoot_config_option(CYGDAT_DEVS_ETH_ARM_MXCBOARD_ETH0_NAME " network hardware address [MAC]",
+                      eth0_esa_data,
+                      "eth0_esa", true,
+                      CONFIG_ESA, 0
+                     );
+#endif // CYGPKG_REDBOOT && CYGSEM_REDBOOT_FLASH_CONFIG
+
+#ifdef CYGSEM_HAL_VIRTUAL_VECTOR_SUPPORT
+// Note that this section *is* active in an application, outside RedBoot,
+// where the above section is not included.
+
+#include <cyg/hal/hal_if.h>
+
+#ifndef CONFIG_ESA
+#define CONFIG_ESA (6)
+#endif
+#ifndef CONFIG_BOOL
+#define CONFIG_BOOL (1)
+#endif
+
+cyg_bool _board_provide_eth0_esa(unsigned char * mac)
+{
+    cyg_bool set_esa;
+    int ok;
+    ok = CYGACC_CALL_IF_FLASH_CFG_OP( CYGNUM_CALL_IF_FLASH_CFG_GET,
+                                      "eth0_esa", &set_esa, CONFIG_BOOL);
+    if (ok && set_esa) {
+        ok = CYGACC_CALL_IF_FLASH_CFG_OP( CYGNUM_CALL_IF_FLASH_CFG_GET,
+                                          "eth0_esa_data", mac, CONFIG_ESA);
+    }
+
+    return ok && set_esa;
+}
+#endif // CYGSEM_HAL_VIRTUAL_VECTOR_SUPPORT
+
+#endif // CYGPKG_DEVS_ETH_ARM_MXCBOARD_ETH0
+
+#endif // __WANT_DEVS
diff -urN -x CVS -x doc -x lwip_tcpip -x calmrisc16 -x calmrisc32 ecos_20050912/packages/devs/eth/cl/cs8900a/current/src/if_cs8900a.c ecos_base/packages/devs/eth/cl/cs8900a/current/src/if_cs8900a.c
--- ecos_20050912/packages/devs/eth/cl/cs8900a/current/src/if_cs8900a.c	2005-05-08 04:29:40.000000000 -0500
+++ ecos_base/packages/devs/eth/cl/cs8900a/current/src/if_cs8900a.c	2005-09-13 23:56:25.000000000 -0500
@@ -171,7 +171,9 @@
     cyg_addrword_t base = cpd->base;
     cyg_uint16 chip_type, chip_rev, chip_status;
     cyg_uint16 i;
+#ifndef CS8900A_RESET_BYPASS
     long timeout = 500000;
+#endif
     cyg_bool esa_configured = false;
     
     cpd->tab = tab;
@@ -222,6 +224,7 @@
     }
 
     CYGHWR_CL_CS8900A_PLF_RESET(base);
+#ifndef CS8900A_RESET_BYPASS
     put_reg(base, PP_SelfCtl, PP_SelfCtl_Reset);  // Reset chip
 
     CYGHWR_CL_CS8900A_PLF_POST_RESET(base);
@@ -234,6 +237,7 @@
             return false;
         }
     }
+#endif /* CS8900A_RESET_BYPASS */
 
     chip_status = get_reg(base, PP_SelfStat);
 #if DEBUG & 8
@@ -474,6 +478,7 @@
     cyg_uint16 saved_data = 0, *sdata;
     cyg_uint16 stat;
     bool odd_byte = false;
+    int timeout = 50000;
 
     // Mark xmitter busy
     cpd->txbusy = true;
@@ -507,8 +512,15 @@
     // Wait for controller ready signal
     do {
         stat = get_reg(base, PP_BusStat);
+        if (timeout-- < 0) {
+            return;
+        }
     } while (!(stat & PP_BusStat_TxRDY));
 
+    if (timeout < 0) {
+        diag_printf("if_cs8900a.c:  PP_BusStat_TXRDY is not set. Cannot transmit packet\n");
+        return;
+    }
     // Put data into buffer
     for (i = 0;  i < sg_len;  i++) {
         data = (cyg_uint8 *)sg_list[i].buf;
@@ -683,6 +695,7 @@
     cyg_uint16 event;
     cs8900a_priv_data_t *cpd = (cs8900a_priv_data_t *)sc->driver_private;
     cyg_addrword_t base = cpd->base;
+    volatile int timeout=5000;
 
     HAL_READ_UINT16(base+CS8900A_ISQ, event);
     while (event != 0) {
@@ -708,6 +721,8 @@
 #endif
             break;
         }
+        while(timeout--);
+        timeout=5000;
         HAL_READ_UINT16(base+CS8900A_ISQ, event);
     }
 
@@ -732,4 +747,4 @@
         splx(s);
     }
 }
-#endif
+#endif
diff -urN -x CVS -x doc -x lwip_tcpip -x calmrisc16 -x calmrisc32 ecos_20050912/packages/devs/eth/fec/current/cdl/fec_eth_drivers.cdl ecos_base/packages/devs/eth/fec/current/cdl/fec_eth_drivers.cdl
--- ecos_20050912/packages/devs/eth/fec/current/cdl/fec_eth_drivers.cdl	1969-12-31 18:00:00.000000000 -0600
+++ ecos_base/packages/devs/eth/fec/current/cdl/fec_eth_drivers.cdl	2006-09-07 23:33:13.000000000 -0500
@@ -0,0 +1,89 @@
+# ====================================================================
+#
+#      cl_mxc_fec_eth_drivers.cdl
+#
+#      Ethernet driver for i.MXx FEC controller
+#
+# ====================================================================
+#####ECOSGPLCOPYRIGHTBEGIN####
+## -------------------------------------------
+## This file is part of eCos, the Embedded Configurable Operating System.
+## Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+##
+## eCos is free software; you can redistribute it and/or modify it under
+## the terms of the GNU General Public License as published by the Free
+## Software Foundation; either version 2 or (at your option) any later version.
+##
+## eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+## WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+## for more details.
+##
+## You should have received a copy of the GNU General Public License along
+## with eCos; if not, write to the Free Software Foundation, Inc.,
+## 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+##
+## As a special exception, if other files instantiate templates or use macros
+## or inline functions from this file, or you compile this file and link it
+## with other works to produce a work based on this file, this file does not
+## by itself cause the resulting work to be covered by the GNU General Public
+## License. However the source code for this file must still be made available
+## in accordance with section (3) of the GNU General Public License.
+##
+## This exception does not invalidate any other reasons why a work based on
+## this file might be covered by the GNU General Public License.
+##
+## Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+## at http://sources.redhat.com/ecos/ecos-license/
+## -------------------------------------------
+#####ECOSGPLCOPYRIGHTEND####
+# ====================================================================
+######DESCRIPTIONBEGIN####
+#
+# Author(s):      Fred Fan
+# Contributors:   Fred Fan
+# Date:           2006-08-23
+#
+#####DESCRIPTIONEND####
+#
+# ====================================================================
+
+cdl_package CYGPKG_DEVS_ETH_FEC {
+    display       "Driver for fast ethernet controller."
+
+    parent        CYGPKG_IO_ETH_DRIVERS
+    active_if	  CYGPKG_IO_ETH_DRIVERS
+
+    implements    CYGHWR_NET_DRIVERS
+    implements    CYGINT_IO_ETH_MULTICAST
+
+    active_if     CYGINT_DEVS_ETH_FEC_REQUIRED
+
+    include_dir   cyg/io
+    description   "Driver for fast ethernet controller."
+    compile       -library=libextras.a if_fec.c
+
+    define_proc {
+        puts $::cdl_header "#include <pkgconf/system.h>";
+        puts $::cdl_header "#include CYGDAT_DEVS_ETH_FEC_CFG";
+    }
+
+    cdl_component CYGPKG_DEVS_ETH_FEC_OPTIONS {
+        display "MXC FEC ethernet driver build options"
+        flavor  none
+	no_define
+
+        cdl_option CYGPKG_DEVS_ETH_FEC_CFLAGS_ADD {
+            display "Additional compiler flags"
+            flavor  data
+            no_define
+            default_value { "-D_KERNEL -D__ECOS" }
+            description   "
+                This option modifies the set of compiler flags for
+                building the Cirrus Logic ethernet driver package.
+                These flags are used in addition
+                to the set of global flags."
+        }
+    }
+}
+
diff -urN -x CVS -x doc -x lwip_tcpip -x calmrisc16 -x calmrisc32 ecos_20050912/packages/devs/eth/fec/current/include/fec.h ecos_base/packages/devs/eth/fec/current/include/fec.h
--- ecos_20050912/packages/devs/eth/fec/current/include/fec.h	1969-12-31 18:00:00.000000000 -0600
+++ ecos_base/packages/devs/eth/fec/current/include/fec.h	2008-02-20 00:49:49.000000000 -0600
@@ -0,0 +1,254 @@
+#ifndef _CYGONCE_ETH_FEC_H_
+#define _CYGONCE_ETH_FEC_H_
+//==========================================================================
+//
+//      dev/mxc_fec.h
+//
+//     	Fast Ethernet MAC controller in i.MXx
+//
+//==========================================================================
+//####ECOSGPLCOPYRIGHTBEGIN####
+// -------------------------------------------
+// This file is part of eCos, the Embedded Configurable Operating System.
+// Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+//
+// eCos is free software; you can redistribute it and/or modify it under
+// the terms of the GNU General Public License as published by the Free
+// Software Foundation; either version 2 or (at your option) any later version.
+//
+// eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with eCos; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+//
+// As a special exception, if other files instantiate templates or use macros
+// or inline functions from this file, or you compile this file and link it
+// with other works to produce a work based on this file, this file does not
+// by itself cause the resulting work to be covered by the GNU General Public
+// License. However the source code for this file must still be made available
+// in accordance with section (3) of the GNU General Public License.
+//
+// This exception does not invalidate any other reasons why a work based on
+// this file might be covered by the GNU General Public License.
+//
+// Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+// at http://sources.redhat.com/ecos/ecos-license/
+// -------------------------------------------
+//####ECOSGPLCOPYRIGHTEND####
+//####BSDCOPYRIGHTBEGIN####
+//
+//
+//####BSDCOPYRIGHTEND####
+//==========================================================================
+//#####DESCRIPTIONBEGIN####
+//
+// Author(s):    Fred Fan
+// Contributors: 
+// Date:         2006-08-23
+// Purpose:      
+// Description:  
+//
+//####DESCRIPTIONEND####
+//
+//==========================================================================
+
+#include <cyg/infra/cyg_type.h>
+
+#include <cyg/hal/hal_io.h>
+/* The defines of event bits */
+#define FEC_EVENT_HBERR	0x80000000
+#define FEC_EVENT_BABR	0x40000000
+#define FEC_EVENT_BABT	0x20000000
+#define FEC_EVENT_GRA	0x10000000
+#define FEC_EVENT_TXF 	0x08000000
+#define FEC_EVENT_TXB	0x04000000
+#define FEC_EVENT_RXF	0x02000000
+#define FEC_EVENT_RXB	0x01000000
+#define FEC_EVENT_MII	0x00800000
+#define FEC_EVENT_EBERR	0x00400000
+#define FEC_EVENT_LC	0x00200000
+#define FEC_EVENT_RL	0x00100000
+#define FEC_EVENT_UN	0x00080000
+
+#define FEC_EVENT_TX		FEC_EVENT_TXF
+#define FEC_EVENT_TX_ERR	(FEC_EVENT_BABT | FEC_EVENT_LC | FEC_EVENT_RL | FEC_EVENT_UN)
+#define FEC_EVENT_RX		FEC_EVENT_RXF
+#define FEC_EVENT_ERR		(FEC_EVENT_HBERR | FEC_EVENT_EBERR)
+
+#define FEC_RX_FRAMES		((CYGNUM_IO_ETH_DRIVERS_NUM_PKT/2)+1)
+#define FEC_FRAME_LEN		(1540+4)
+
+/* the defines to active transmit or receive frame */
+#define FEC_RX_TX_ACTIVE	0x01000000
+
+/* the defines of Ethernet Control register */
+#define FEC_RESET	0x00000001
+#define FEC_ETHER_EN	0x00000002
+
+/* the defins of MII operation */ 
+#define FEC_MII_ST	0x40000000
+#define FEC_MII_OP_OFF	28
+#define FEC_MII_OP_MASK 0x03
+#define FEC_MII_OP_RD	0x02
+#define FEC_MII_OP_WR	0x01
+#define FEC_MII_PA_OFF	23
+#define FEC_MII_PA_MASK 0xFF
+#define FEC_MII_RA_OFF	18
+#define FEC_MII_RA_MASK	0xFF
+#define FEC_MII_TA	0x00020000
+#define FEC_MII_DATA_OFF 0
+#define FEC_MII_DATA_MASK 0x0000FFFF
+
+#define FEC_MII_FRAME	( FEC_MII_ST | FEC_MII_TA )	
+#define FEC_MII_OP(x)	( ((x) & FEC_MII_OP_MASK) << FEC_MII_OP_OFF )
+#define FEC_MII_PA(pa)  (((pa)& FEC_MII_PA_MASK) << FEC_MII_PA_OFF)
+#define FEC_MII_RA(ra)	(((ra)& FEC_MII_RA_MASK) << FEC_MII_RA_OFF)
+#define FEC_MII_SET_DATA(v) (((v) & FEC_MII_DATA_MASK) << FEC_MII_DATA_OFF)
+#define FEC_MII_GET_DATA(v) (((v) >> FEC_MII_DATA_OFF) & FEC_MII_DATA_MASK )
+#define FEC_MII_READ(pa, ra) (	( FEC_MII_FRAME | FEC_MII_OP(FEC_MII_OP_RD) )|\
+					FEC_MII_PA(pa) | FEC_MII_RA(ra) )
+#define FEC_MII_WRITE(pa, ra, v) ( FEC_MII_FRAME | FEC_MII_OP(FEC_MII_OP_WR)|\
+				FEC_MII_PA(pa) | FEC_MII_RA(ra) |FEC_MII_SET_DATA(v) )
+
+#define MII_SPEED_SHIFT	1
+#define MII_SPEED_MASK 	0x0000003F
+#define MII_SPEED(x)	( (((((x)+499999)/2500000)&(MII_SPEED_MASK))>>1)<<(MII_SPEED_SHIFT) )
+
+/*the defines of MIB control */
+#define FEC_MIB_DISABLE	0x80000000
+
+/*the defines of Receive Control*/
+#define FEC_RCR_FCE	0x00000020
+#define FEC_RCR_BC_REJ	0x00000010
+#define FEC_RCR_PROM	0x00000008
+#define FEC_RCR_MII_MODE	0x00000004
+
+/*the defines of Transmit Control*/
+#define FEC_TCR_RFC_PAUSE	0x00000010
+#define FEC_TCR_FDEN		0x00000004
+
+/*the defines of buffer description*/
+#define FEC_BD_RX_NUM	32
+#define FEC_BD_TX_NUM	2
+
+typedef struct mxc_fec_reg_s 
+{
+		unsigned long res1;
+/*0x004*/	unsigned long eir;	/* Interrupt Event Register */
+/*0x008*/	unsigned long eimr;	/* Interrupt Mask Register */
+		unsigned long res2;
+/*0x010*/	unsigned long rdar;	/* Receive Descriptor Active Register*/
+/*0x014*/	unsigned long tdar;	/* Transmit Descriptor Active Register*/
+		unsigned long res3[3];
+/*0x024*/	unsigned long ecr;	/*Receive Descriptor Active Register*/
+		unsigned long res4[6];
+/*0x040*/	unsigned long mmfr;	/*MII Management Frame Register */
+/*0x044*/	unsigned long mscr;	/*MII Speed Control Register */
+		unsigned long res5[7];
+/*0x064*/	unsigned long mibc;	/*MII Control/Status Register */
+		unsigned long res6[7];
+/*0x084*/	unsigned long rcr;	/*Receive Control Register */
+		unsigned long res7[15];
+/*0x0C4*/	unsigned long tcr;	/*Transmit Control register */
+		unsigned long res8[7];
+/*0x0E4*/	unsigned long palr;	/*Physical Address Low Register*/
+/*0x0E8*/	unsigned long paur;	/*Physical Address High+Type Register*/
+/*0x0EC*/	unsigned long opd;	/*Opcode+Pause Duration */
+		unsigned long res9[10];
+/*0x118*/	unsigned long iaur;	/*Upper 32bits Individual Hash Table*/
+/*0x11c*/	unsigned long ialr;	/*lower 32bits Individual Hash Table*/
+/*0x120*/	unsigned long gaur;	/*Upper 32bits Group Hash Table*/
+/*0x124*/	unsigned long galr;	/*lower 32bits Group Hash Table*/
+		unsigned long res10[7];
+/*0x144*/	unsigned long tfwr;	/*Trasmit FIFO Watermark */
+		unsigned long res11;
+/*0x14c*/	unsigned long frbr; 	/*FIFO Receive Bound Register*/
+/*0x150*/	unsigned long frsr;	/*FIFO Receive FIFO Start Registers*/
+		unsigned long res12[11];
+/*0x180*/	unsigned long erdsr; 	/*Pointer to Receive Descriptor Ring*/
+/*0x184*/	unsigned long etdsr;	/*Pointer to Transmit Descriptor Ring*/
+/*0x188*/	unsigned long emrbr;	/*Maximum Receive Buffer size*/
+} mxc_fec_reg_t;
+
+#define BD_RX_ST_EMPTY 0x8000
+#define BD_RX_ST_WRAP  0x2000
+#define BD_RX_ST_LAST  0x0800
+#define BD_RX_ST_ERRS  0x0037
+
+#define BD_TX_ST_RDY	0x8000
+#define BD_TX_ST_WRAP	0x2000
+#define BD_TX_ST_LAST  	0x0800
+#define BD_TX_ST_TC  	0x0400
+#define BD_TX_ST_ABC	0x0200
+
+typedef struct mxc_fec_bd_t
+{
+	unsigned short int length;	/*packet size*/
+	unsigned short int status;	/*control & statue of this buffer description*/
+	unsigned char *	   data;	/*frame buffer address*/
+} mxc_fec_bd_t;
+
+typedef struct mxc_fec_priv_s 
+{
+	mxc_fec_reg_t * hw_reg;		/*the reister base address of FEC*/
+	unsigned char   phy_addr;	/*the address of PHY which associated with FEC controller*/
+	unsigned char   tx_busy;	/*0:free, 1:transmitting frame*/
+	unsigned char	res[2];
+	unsigned long 	status;		/*the status of FEC device:link-status etc.*/
+	unsigned long 	tx_key;		/*save the key delivered from send function*/
+	mxc_fec_bd_t * 	rx_bd;		/*the receive buffer description ring*/
+	mxc_fec_bd_t * 	rx_cur;		/*the next recveive buffer description*/
+	mxc_fec_bd_t * 	tx_bd;		/*the transmit buffer description rign*/
+	mxc_fec_bd_t * 	tx_cur;		/*the next transmit buffer description*/
+	/*TODO: Add interrupt about fields*/
+	/*TODO: Add timer about fields*/
+} mxc_fec_priv_t;
+
+#define MXC_FEC_PRIVATE(x)	((mxc_fec_priv_t *)(x)->driver_private)
+
+/*The defines of the status field of mxc_fec_priv_t */
+#define FEC_STATUS_LINK_ON	0x80000000
+#define FEC_STATUS_FULL_DPLX	0x40000000
+#define FEC_STATUS_AUTO_NEG	0x20000000
+#define FEC_STATUS_100M		0x10000000
+
+/*The defines about PHY */
+#ifndef FEC_PHY_ADDR
+#define PHY_PORT_ADDR		0x01
+#else 
+#define PHY_PORT_ADDR		FEC_PHY_ADDR
+#endif
+
+#define PHY_CTRL_REG		0x00
+#define PHY_CTRL_RESET		0x8000
+#define PHY_CTRL_AUTO_NEG	0x1000
+#define PHY_CTRL_FULL_DPLX	0x0100
+
+#define PHY_STATUS_REG	0x01
+#define PHY_STATUS_LINK_ST	0x0004
+
+#define PHY_IDENTIFY_1		0x02
+#define PHY_IDENTIFY_2		0x03
+#define PHY_ID1_SHIFT		2
+#define PHY_ID1_MASK		0xFFFF
+#define PHY_ID2_SHIFT		8
+#define PHY_ID2_MASK		0xFC00
+#define PHY_MODE_NUM		0x03F0
+#define PHY_REV_NUM		0x000F
+
+#define PHY_DIAG_REG		0x12
+#define PHY_DIAG_DPLX		0x0800
+#define PHY_DIAG_RATE		0x0400
+
+#define PHY_MODE_REG		0x15
+#define PHY_LED_SEL		0x200
+
+#define FEC_COMMON_TICK	2
+#define FEC_COMMON_TIMEOUT	(1000*1000)
+#define FEC_MII_TICK	2
+#define FEC_MII_TIMEOUT	(1000*1000)
+#endif // _CYGONCE_ETH_FEC_H_
diff -urN -x CVS -x doc -x lwip_tcpip -x calmrisc16 -x calmrisc32 ecos_20050912/packages/devs/eth/fec/current/src/if_fec.c ecos_base/packages/devs/eth/fec/current/src/if_fec.c
--- ecos_20050912/packages/devs/eth/fec/current/src/if_fec.c	1969-12-31 18:00:00.000000000 -0600
+++ ecos_base/packages/devs/eth/fec/current/src/if_fec.c	2008-02-20 00:50:11.000000000 -0600
@@ -0,0 +1,719 @@
+//==========================================================================
+//
+//      dev/if_fec.c
+//
+//      Device driver for FEC 
+//
+//==========================================================================
+//####ECOSGPLCOPYRIGHTBEGIN####
+// -------------------------------------------
+// This file is part of eCos, the Embedded Configurable Operating System.
+// Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+//
+// eCos is free software; you can redistribute it and/or modify it under
+// the terms of the GNU General Public License as published by the Free
+// Software Foundation; either version 2 or (at your option) any later version.
+//
+// eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with eCos; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+//
+// As a special exception, if other files instantiate templates or use macros
+// or inline functions from this file, or you compile this file and link it
+// with other works to produce a work based on this file, this file does not
+// by itself cause the resulting work to be covered by the GNU General Public
+// License. However the source code for this file must still be made available
+// in accordance with section (3) of the GNU General Public License.
+//
+// This exception does not invalidate any other reasons why a work based on
+// this file might be covered by the GNU General Public License.
+//
+// Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+// at http://sources.redhat.com/ecos/ecos-license/
+// -------------------------------------------
+//####ECOSGPLCOPYRIGHTEND####
+//####BSDCOPYRIGHTBEGIN####
+//
+// -------------------------------------------
+//
+// Portions of this software may have been derived from OpenBSD or other sources,
+// and are covered by the appropriate copyright disclaimers included herein.
+//
+// -------------------------------------------
+//
+//####BSDCOPYRIGHTEND####
+//==========================================================================
+//#####DESCRIPTIONBEGIN####
+//
+// Author(s):    Fred Fan
+// Contributors: 
+// Date:         2006-08-23
+// Purpose:      
+// Description:  Driver for FEC ethernet controller
+//
+// Note:         
+//
+//####DESCRIPTIONEND####
+//
+//==========================================================================
+
+#include <pkgconf/system.h>
+#ifdef CYGPKG_KERNEL
+#include <cyg/kernel/kapi.h>
+#endif
+#include <pkgconf/io_eth_drivers.h>
+
+#include <cyg/infra/cyg_type.h>
+#include <cyg/infra/cyg_ass.h>
+#include <cyg/hal/hal_arch.h>
+#include <cyg/hal/hal_intr.h>
+#include <cyg/hal/hal_endian.h>
+#include <cyg/infra/diag.h>
+#include <cyg/hal/drv_api.h>
+#include <cyg/hal/hal_soc.h>
+#undef __ECOS
+#define __ECOS
+#include <cyg/io/eth/eth_drv.h>
+#include <cyg/io/eth/netdev.h>
+#include <cyg/io/fec.h>
+#include <redboot.h>
+
+#include <cyg/hal/hal_mm.h>
+#include <cyg/hal/plf_mmap.h>
+#ifdef CYGSEM_REDBOOT_FLASH_CONFIG
+#include <flash_config.h>
+#endif
+
+/*!
+ * Global variable which contains the name of FEC driver and device. 
+ */
+static char  mxc_fec_name[] = "mxc_fec";
+
+/*!
+ * Global variable which defines the private structure of FEC device.
+ */
+static mxc_fec_priv_t  mxc_fec_private ;
+
+/*!
+ *Global variable which defines the buffer descriptions for receiving frame
+ * 	comment:: it must aligned by 128-bits.
+ */
+static mxc_fec_bd_t mxc_fec_rx_bd[FEC_BD_RX_NUM] __attribute__ ( ( aligned(32) ) ) ;
+
+/*!
+ *Global variable which defines the buffer descriptions for receiving frame
+ * 	comment:: it must aligned by 128-bits.
+ */
+static mxc_fec_bd_t mxc_fec_tx_bd[FEC_BD_TX_NUM] __attribute__ ( ( aligned(32) ) ) ;
+
+/*!
+ * Global variable which contains the frame buffers , 
+ */
+static unsigned char mxc_fec_rx_buf[FEC_BD_RX_NUM][2048] __attribute__ ( ( aligned(32) ) ) ;
+
+/*!
+ * Global variable which contains the frame buffers , 
+ */
+static unsigned char mxc_fec_tx_buf[FEC_BD_TX_NUM][2048] __attribute__ ( ( aligned(32) ) ) ;
+
+
+/*!
+ * This function get the value of  PHY registers by MII interface
+ */
+static int 
+mxc_fec_mii_read(volatile mxc_fec_reg_t * hw_reg, unsigned char phy_addr, unsigned char reg_addr, unsigned short int * value)
+{
+	unsigned long waiting = FEC_MII_TIMEOUT;
+	
+	if(hw_reg->eir & FEC_EVENT_MII ) {
+		hw_reg->eir = FEC_EVENT_MII ;
+	} 
+	hw_reg->mmfr = FEC_MII_READ(phy_addr, reg_addr);/*Write CMD*/
+	while(1) {
+		if(hw_reg->eir & FEC_EVENT_MII ) {
+			hw_reg->eir = FEC_EVENT_MII ; 
+			break;
+		}
+		if ( (--waiting) == 0 ) return -1;
+		hal_delay_us(FEC_MII_TICK);	
+	}
+	*value = FEC_MII_GET_DATA(hw_reg->mmfr);
+	return 0;
+}
+
+/*!
+ * This function set the value of  PHY registers by MII interface
+ */
+static int 
+mxc_fec_mii_write(volatile mxc_fec_reg_t * hw_reg, unsigned char phy_addr, unsigned char reg_addr, unsigned short int value)
+{
+	unsigned long waiting = FEC_MII_TIMEOUT;
+	
+	if(hw_reg->eir & FEC_EVENT_MII ) {
+		hw_reg->eir = FEC_EVENT_MII ;
+	} 
+	hw_reg->mmfr = FEC_MII_WRITE(phy_addr, reg_addr, value);/*Write CMD*/
+	while(1) {
+		if(hw_reg->eir & FEC_EVENT_MII ) {
+			hw_reg->eir = FEC_EVENT_MII ; 
+			break;
+		}
+		if ( (--waiting) == 0 ) return -1;
+		hal_delay_us(FEC_MII_TICK);	
+	}
+	return 0;
+}
+
+static void
+mxc_fec_set_mac_address(volatile mxc_fec_reg_t * dev, unsigned char * enaddr)
+{
+	unsigned long value;
+	
+	value = enaddr[0];
+	value = (value << 8) + enaddr[1];
+	value = (value << 8) + enaddr[2];
+	value = (value << 8) + enaddr[3];
+	dev->palr = value;
+	
+	value = enaddr[4];
+	value = (value<<8)+enaddr[5];
+	dev->paur = (value<<16);
+}
+
+/*!
+ * This function set the value of  PHY registers by MII interface
+ */
+static void 
+mxc_fec_start(struct eth_drv_sc *sc, unsigned char *enaddr, int flags)
+{
+	mxc_fec_priv_t * priv = sc?sc->driver_private:NULL;
+	volatile mxc_fec_reg_t * chip = priv?priv->hw_reg:NULL;
+
+	if ( !(priv && chip) || enaddr == NULL ) {
+		diag_printf("BUG[start]: MAC address or some fields in driver is NULL\n");
+		return;
+	}
+	mxc_fec_set_mac_address(chip, enaddr);
+
+	priv->tx_busy = 0;
+	chip->ecr |= FEC_ETHER_EN;
+	chip->rdar |= FEC_RX_TX_ACTIVE;
+}
+
+/*!
+ * This function pauses the FEC controller.
+ */
+static void 
+mxc_fec_stop(struct eth_drv_sc *sc)
+{
+	mxc_fec_priv_t * priv = sc?sc->driver_private:NULL;
+	volatile mxc_fec_reg_t * chip = priv?priv->hw_reg:NULL;
+	if ( !(priv && chip)  ) {
+		diag_printf("BUG[stop]: some fields in driver is NULL\n");
+		return;
+	}
+	chip->ecr &= ~FEC_ETHER_EN;
+}
+
+static int  
+mxc_fec_control(struct eth_drv_sc *sc, unsigned long key, void *data, int data_length)
+{
+	/*TODO:: Add support */
+	diag_printf("mxc_fec_control: key=0x%x, data=0x%x, data_len=0x%x\n",
+		key, data, data_length);
+	return 0;
+}
+
+/*!
+ * This function checks the status of FEC control.
+ */
+static int  
+mxc_fec_can_send(struct eth_drv_sc *sc)
+{
+	mxc_fec_priv_t * priv = sc?sc->driver_private:NULL;
+	volatile mxc_fec_reg_t * hw_reg = priv?priv->hw_reg:NULL;
+	unsigned long value;
+
+	if ( !( priv && hw_reg) ) {
+		diag_printf("BUG[can_send]:the private pointer and register pointer in MXC_FEC is NULL\n");
+		return 0;
+	}
+	if ( priv->tx_busy ) {
+		diag_printf("WARNING[can_send]: MXC_FEC is busy for transmittinig\n");
+		return 0;
+	}
+
+	if(!(hw_reg->ecr & FEC_ETHER_EN)) {
+		diag_printf("WARNING[can_send]: MXC_FEC is not enabled\n");
+		return 0;
+	}
+
+	if(hw_reg->tcr & FEC_TCR_RFC_PAUSE) {
+		diag_printf("WARNING[can_send]: MXC_FEC is paused\n");
+		return 0;
+	}
+
+	mxc_fec_mii_read(hw_reg, priv->phy_addr, 1, &value);
+	if ( value & PHY_STATUS_LINK_ST) {
+                priv->status |= FEC_STATUS_LINK_ON;
+        } else {
+                priv->status &= ~FEC_STATUS_LINK_ON;
+        }
+	return (priv->status&FEC_STATUS_LINK_ON);
+}
+
+/*!
+ * This function transmits a frame.
+ */
+static void 
+mxc_fec_send(struct eth_drv_sc *sc, struct eth_drv_sg *sg_list, int sg_len, int total, unsigned long key)
+{
+	mxc_fec_priv_t * dev = sc?sc->driver_private:NULL;
+	volatile mxc_fec_reg_t * hw_reg = dev?dev->hw_reg:NULL;
+	mxc_fec_bd_t * p;
+	int i, off;
+
+	if ( dev == NULL || hw_reg == NULL) {
+		diag_printf("BUG[TX]: some fields in driver are NULL\n");
+		return;
+	}
+	if ( total > (FEC_FRAME_LEN-4)) total = FEC_FRAME_LEN-4;
+	if ( sg_list == NULL || total <= 14 ) {
+		if(sc->funs->eth_drv && sc->funs->eth_drv->tx_done) {
+			sc->funs->eth_drv->tx_done(sc, key, -1);
+		}
+		return;
+	}	
+
+	for(i=0, off=0, p = dev->tx_cur; i<sg_len; i++) {
+		if(p->status & BD_TX_ST_RDY) {
+			diag_printf("BUG[TX]:MXC_FEC's status=%x\n", p->status);
+			break;
+		}
+		if (sg_list[i].buf == NULL ) {
+			diag_printf("WARNING[TX]: sg_list->buf is NULL\n");
+			break;
+		}
+		memcpy(hal_ioremap_nocache(p->data)+off, sg_list[i].buf, sg_list[i].len );
+		off += sg_list[i].len;
+	}
+	if ( off < 14 ) {
+		diag_printf("WARNING[TX]: data len is %d\n", off);
+		return;
+	}
+	p->length = off; 
+	p->status &= ~(BD_TX_ST_LAST|BD_TX_ST_RDY|BD_TX_ST_TC|BD_TX_ST_ABC);
+	p->status |= BD_TX_ST_LAST| BD_TX_ST_RDY | BD_TX_ST_TC;
+	if(p->status & BD_TX_ST_WRAP ) {
+		p = dev->tx_bd;
+	} else p++;
+	dev->tx_cur = p;
+	dev->tx_busy = 1;
+	dev->tx_key = key;
+	hw_reg->tdar = FEC_RX_TX_ACTIVE;	
+}
+
+/*!
+ * This function receives ready Frame in DB.
+ */
+static void 
+mxc_fec_recv(struct eth_drv_sc *sc, struct eth_drv_sg *sg_list, int sg_len)
+{
+        mxc_fec_priv_t * priv = sc?sc->driver_private:NULL;
+	mxc_fec_bd_t * p;
+
+	if(sg_list == NULL || priv == NULL || sg_len <= 0) {
+		diag_printf("BUG[RX]: driver's private field or argument of this calling is NULL \n");
+		return;
+	}
+	
+	/*TODO: I think if buf pointer is NULL, this function 
+	 * should not be called
+	 */
+	if(sg_list->buf == NULL) {
+		diag_printf("WARING[RX]: the sg_list is empty\n");
+		return;
+	}
+	p = priv->rx_cur;
+	
+	if(p->status & BD_RX_ST_EMPTY) {
+		diag_printf("BUG[RX]: status =%x\n", p->status);
+		return;
+	}
+
+	if(!(p->status & BD_RX_ST_LAST)) {
+		diag_printf("BUG[RX]: status =%x\n", p->status);
+		return;
+	} 
+	/*TODO::D_CACHE invalid this data buffer*/
+	memcpy(sg_list->buf, hal_ioremap_nocache(p->data), p->length -4);
+}
+
+static void 
+mxc_fec_deliver(struct eth_drv_sc *sc)
+{
+	/*TODO::When redboot support thread , 
+	 *	the polling function will be called at here
+	 */
+	return;
+}
+
+static void 
+mxc_fec_check_rx_bd(struct eth_drv_sc * sc)
+{
+	/* This funtion just called by polling funtion*/
+        mxc_fec_priv_t * priv = sc->driver_private;
+	mxc_fec_bd_t * p, * prev;
+	volatile mxc_fec_reg_t * hw_reg = priv->hw_reg;
+	int i;
+	
+	for(i = 0, p = priv->rx_cur; i< FEC_RX_FRAMES; i++){
+		/*TODO::D-CACHE invalid this BD.
+	 	*In WRITE_BACK mode: this maybe destroy the next BD 
+		*	when the CACHE_LINE write back.
+	 	*/
+		if(p->status & BD_RX_ST_EMPTY) {
+			break;
+		}
+		if(!(p->status & BD_RX_ST_LAST)) {
+			diag_printf("BUG[RX]: status=%x, length=%x\n", p->status, p->length);
+			goto skip_next;
+		}
+		
+		if((p->status & BD_RX_ST_ERRS)|| (p->length > FEC_FRAME_LEN)) {
+			diag_printf("BUG[RX]: status=%x, length=%x\n", p->status, p->length);
+		} else {
+			sc->funs->eth_drv->recv(sc, p->length -4);
+		}
+skip_next:
+		p->status = (p->status & BD_RX_ST_WRAP) | BD_RX_ST_EMPTY;
+		
+		if ( p->status & BD_RX_ST_WRAP) {
+			p = priv->rx_bd;
+		} else {
+			p++;
+		} 
+		priv->rx_cur = p;	
+		hw_reg->ecr |= FEC_ETHER_EN;
+		hw_reg->rdar |= FEC_RX_TX_ACTIVE;
+	}
+}
+
+/*!
+ * This function checks the event of FEC controller
+ */
+static void 
+mxc_fec_poll(struct eth_drv_sc * sc)
+{
+	mxc_fec_priv_t * priv = sc?sc->driver_private:NULL;
+        volatile mxc_fec_reg_t * hw_reg = priv?priv->hw_reg:NULL;
+        unsigned long value;
+
+	if ( priv == NULL || hw_reg == NULL) {
+		diag_printf("BUG[POLL]: some fields in driver are NULL\n");
+		return;
+	}
+	value = hw_reg->eir;
+	hw_reg->eir = value&(~FEC_EVENT_MII);
+	
+	if(value&FEC_EVENT_TX_ERR) {
+		diag_printf("WARNING[POLL]: There are error(%x) for transmit\n", value&FEC_EVENT_TX_ERR);
+		sc->funs->eth_drv->tx_done(sc, priv->tx_key, -1);
+		priv->tx_busy = 0;
+	} else {
+		if(value&FEC_EVENT_TX) {
+			sc->funs->eth_drv->tx_done(sc,  priv->tx_key, 0);
+			priv->tx_busy = 0;
+		}
+	}
+	
+	if(value&FEC_EVENT_RX) {
+		mxc_fec_check_rx_bd(sc);
+	}
+
+	if(value & FEC_EVENT_HBERR) {
+		diag_printf("WARNGING[POLL]: Hearbeat error!\n");
+	}
+
+	if(value & FEC_EVENT_EBERR) {
+		diag_printf("WARNING[POLL]: Ethernet Bus Error!\n");
+	}
+}
+
+
+static int
+mxc_fec_int_vector(struct eth_drv_sc *sc)
+{
+	/*TODO::
+	 *	get FEC interrupt number 	
+ 	 */
+    	return -1;
+}
+
+/*!
+ * The function initializes the description buffer for receiving or transmitting
+ */
+static void
+mxc_fec_bd_init(mxc_fec_priv_t * dev)
+{
+	int i;
+	mxc_fec_bd_t * p;
+	
+	p = dev->rx_bd = hal_ioremap_nocache(hal_virt_to_phy((unsigned long)mxc_fec_rx_bd));
+	for(i=0; i<FEC_BD_RX_NUM; i++, p++){
+		p->status = BD_RX_ST_EMPTY;
+		p->length = 0;
+		p->data = hal_virt_to_phy((unsigned long)mxc_fec_rx_buf[i]);
+	}
+
+	dev->rx_bd[i-1].status |= BD_RX_ST_WRAP;
+	dev->rx_cur = dev->rx_bd;
+
+        p = dev->tx_bd = hal_ioremap_nocache(hal_virt_to_phy((unsigned long)mxc_fec_tx_bd));
+        for(i=0; i<FEC_BD_TX_NUM; i++, p++){
+                p->status = 0;
+                p->length = 0;
+                p->data = hal_virt_to_phy((unsigned long)mxc_fec_tx_buf[i]);
+        }
+
+        dev->tx_bd[i-1].status |= BD_TX_ST_WRAP;
+	dev->tx_cur = dev->tx_bd;
+	
+	/*TODO:: add the sync function for items*/
+}
+
+/*!
+ *This function initializes FEC controller. 
+ */
+static void 
+mxc_fec_chip_init(mxc_fec_priv_t * dev)
+{
+	volatile mxc_fec_reg_t * chip = dev->hw_reg;
+	unsigned long ipg_clk;
+
+	chip->ecr = FEC_RESET;
+	while(chip->ecr & FEC_RESET) {
+		hal_delay_us(FEC_COMMON_TICK);
+	}
+
+	chip->eimr = 0x00000000;
+	chip->eir = 0xFFFFFFFF;
+	
+	chip->rcr = (chip->rcr&~(0x0000003F))|FEC_RCR_FCE|FEC_RCR_MII_MODE;
+	chip->tcr |= FEC_TCR_FDEN;
+	chip->mibc |= FEC_MIB_DISABLE;
+	
+	chip->iaur = 0;
+	chip->ialr = 0;
+	chip->gaur = 0;
+	chip->galr = 0;
+
+	/*TODO:: Use MII_SPEED(IPG_CLK) to get the value*/ 
+	ipg_clk = get_main_clock(IPG_CLK);
+	
+	chip->mscr = (chip->mscr&(~0x7e)) | (((ipg_clk+499999)/2500000/2)<<1);
+	
+	/*Enable ETHER_EN*/
+	chip->emrbr = 2048-16;
+	chip->erdsr = hal_virt_to_phy((unsigned long)dev->rx_bd);
+	chip->etdsr = hal_virt_to_phy((unsigned long)dev->tx_bd);
+}
+
+/*!
+ * This function initialize PHY
+ */
+static bool 
+mxc_fec_phy_init(mxc_fec_priv_t * dev)
+{
+	unsigned long value = 0;
+	unsigned long id = 0;
+
+	mxc_fec_mii_read(dev->hw_reg, dev->phy_addr, PHY_IDENTIFY_1, &value);
+	id = (value&PHY_ID1_MASK)<<PHY_ID1_SHIFT;
+	mxc_fec_mii_read(dev->hw_reg, dev->phy_addr, PHY_IDENTIFY_2, &value);
+	id |= (value&PHY_ID2_MASK)<<PHY_ID2_SHIFT;
+	switch( id) {
+	case 0x00540088:
+		break;
+	case 0x00007C0C:
+		break;
+	default:
+		diag_printf("[Warning] FEC not connect right PHY: ID=%lx\n", id);
+        }
+	
+	mxc_fec_mii_write(dev->hw_reg, dev->phy_addr, PHY_CTRL_REG, PHY_CTRL_AUTO_NEG|PHY_CTRL_FULL_DPLX);
+		
+	mxc_fec_mii_read(dev->hw_reg, dev->phy_addr, PHY_MODE_REG, &value);
+	value &= ~(PHY_LED_SEL);
+	mxc_fec_mii_write(dev->hw_reg, dev->phy_addr, PHY_MODE_REG, value);
+	
+	mxc_fec_mii_read(dev->hw_reg, dev->phy_addr, PHY_STATUS_REG, &value);
+	
+	if ( value & PHY_STATUS_LINK_ST) {
+		dev->status |= FEC_STATUS_LINK_ON;
+	} else {
+		dev->status &= ~FEC_STATUS_LINK_ON;
+	}
+		
+	mxc_fec_mii_read(dev->hw_reg, dev->phy_addr, PHY_DIAG_REG, &value);
+	if ( value & PHY_DIAG_DPLX) {
+		dev->status |= FEC_STATUS_FULL_DPLX;
+	} else {
+		dev->status &= ~FEC_STATUS_FULL_DPLX;
+	}
+	if ( value & PHY_DIAG_DPLX) {
+                dev->status |= FEC_STATUS_100M;
+        } else {
+                dev->status &= ~FEC_STATUS_100M;
+        }
+
+	diag_printf("FEC: [ %s ] [ %s ] [ %s ]:\n", 
+		(dev->status&FEC_STATUS_FULL_DPLX)?"FULL_DUPLEX":"HALF_DUPLEX",
+		(dev->status&FEC_STATUS_LINK_ON)?"connected":"disconnected",
+		(dev->status&FEC_STATUS_100M)?"100M bps":"10M bps");
+	return true;
+}
+
+/*! This function initializes the FEC driver. 
+ * It is called by net_init in net module of RedBoot during RedBoot init
+ */
+static bool 
+mxc_fec_init(struct cyg_netdevtab_entry *tab)
+{
+	struct eth_drv_sc * sc = tab?tab->device_instance:NULL;
+	mxc_fec_priv_t * private;
+    	char eth_add_local[6] = {0x00, 0x00, 0x45, 0x67, 0x89, 0xab};
+#ifdef CYGSEM_REDBOOT_FLASH_CONFIG
+	cyg_bool set_esa;
+    	int ok;
+
+	/* Get MAC address */
+    	ok = CYGACC_CALL_IF_FLASH_CFG_OP( CYGNUM_CALL_IF_FLASH_CFG_GET,
+                                      "fec_esa", &set_esa, CONFIG_BOOL);
+    	if (ok && set_esa) {
+        	CYGACC_CALL_IF_FLASH_CFG_OP( CYGNUM_CALL_IF_FLASH_CFG_GET,
+                                     "fec_esa_data", eth_add_local, CONFIG_ESA);
+	}
+#endif
+
+    	if(sc == NULL ){
+		diag_printf("FEC:: no driver attached\n");
+		return false;
+    	} 
+	
+	private = MXC_FEC_PRIVATE(sc);
+	if ( private == NULL ) {
+		private = MXC_FEC_PRIVATE(sc) = &mxc_fec_private;
+	}
+
+	private->hw_reg = SOC_FEC_BASE;
+	private->tx_busy = 0;
+	private->status = 0;
+	private->phy_addr = PHY_PORT_ADDR;
+
+	mxc_fec_bd_init(private);
+
+	mxc_fec_chip_init(private);
+
+	mxc_fec_phy_init(private);
+	
+	/*TODO:: initialize System Resource : irq, timer */
+
+	sc->funs->eth_drv->init(sc, eth_add_local);
+    
+    	return true;
+}
+
+/*!
+ * Global variable which defines the FEC driver, 
+ */
+ETH_DRV_SC(mxc_fec_sc,
+ 	   &mxc_fec_private, // Driver specific data
+           mxc_fec_name,
+           mxc_fec_start,
+           mxc_fec_stop,
+           mxc_fec_control,
+           mxc_fec_can_send,
+           mxc_fec_send,
+           mxc_fec_recv,
+           mxc_fec_deliver,     // "pseudoDSR" called from fast net thread
+           mxc_fec_poll,        // poll function, encapsulates ISR and DSR
+           mxc_fec_int_vector);
+
+/*!
+ * Global variable which defines the FEC device
+ */
+NETDEVTAB_ENTRY(mxc_fec_netdev,
+                mxc_fec_name,
+                mxc_fec_init,
+                &mxc_fec_sc);
+
+#if defined(CYGPKG_REDBOOT) && defined(CYGSEM_REDBOOT_FLASH_CONFIG)
+extern unsigned int sys_ver;
+
+void _board_provide_fec_esa(void)
+{
+    cyg_bool set_esa;
+    cyg_uint8 addr[6];
+    int ok;
+
+    ok = CYGACC_CALL_IF_FLASH_CFG_OP( CYGNUM_CALL_IF_FLASH_CFG_GET,
+                                      "fec_esa", &set_esa, CONFIG_BOOL);
+    diag_printf("Ethernet FEC MAC address: ");
+    if (ok && set_esa) {
+        CYGACC_CALL_IF_FLASH_CFG_OP( CYGNUM_CALL_IF_FLASH_CFG_GET,
+                                     "fec_esa_data", addr, CONFIG_ESA);
+#ifdef CYGPKG_HAL_ARM_MX27
+        if(sys_ver == SOC_SILICONID_Rev1_0) {
+                writel(addr[5], SOC_FEC_MAC_BASE + 0x0);
+                writel(addr[4], SOC_FEC_MAC_BASE + 0x4);
+                writel(addr[3], SOC_FEC_MAC_BASE + 0x8);
+                writel(addr[2], SOC_FEC_MAC_BASE + 0xC);
+                writel(addr[1], SOC_FEC_MAC_BASE + 0x10);
+                writel(addr[0], SOC_FEC_MAC_BASE + 0x14);
+                addr[5] = readl(SOC_FEC_MAC_BASE + 0x0);
+                addr[4] = readl(SOC_FEC_MAC_BASE + 0x4);
+                addr[3] = readl(SOC_FEC_MAC_BASE + 0x8);
+                addr[2] = readl(SOC_FEC_MAC_BASE + 0xC);
+                addr[1] = readl(SOC_FEC_MAC_BASE + 0x10);
+                addr[0] = readl(SOC_FEC_MAC_BASE + 0x14);
+        } else {
+                writel(addr[5], SOC_FEC_MAC_BASE2 + 0x0);
+                writel(addr[4], SOC_FEC_MAC_BASE2 + 0x4);
+                writel(addr[3], SOC_FEC_MAC_BASE2 + 0x8);
+                writel(addr[2], SOC_FEC_MAC_BASE2 + 0xC);
+                writel(addr[1], SOC_FEC_MAC_BASE2 + 0x10);
+                writel(addr[0], SOC_FEC_MAC_BASE2 + 0x14);
+                addr[5] = readl(SOC_FEC_MAC_BASE2 + 0x0);
+                addr[4] = readl(SOC_FEC_MAC_BASE2 + 0x4);
+                addr[3] = readl(SOC_FEC_MAC_BASE2 + 0x8);
+                addr[2] = readl(SOC_FEC_MAC_BASE2 + 0xC);
+                addr[1] = readl(SOC_FEC_MAC_BASE2 + 0x10);
+                addr[0] = readl(SOC_FEC_MAC_BASE2 + 0x14);
+        }
+        diag_printf("%02x:%02x:%02x:%02x:%02x:%02x\n",
+                    addr[0], addr[1], addr[2], addr[3], addr[4], addr[5]);
+#endif
+    } else {
+        diag_printf("is not set\n");
+    }
+}
+
+RedBoot_init(_board_provide_fec_esa, RedBoot_INIT_LAST);
+
+RedBoot_config_option("Set FEC network hardware address [MAC]",
+                      fec_esa,
+                      ALWAYS_ENABLED, true,
+                      CONFIG_BOOL, false
+                     );
+RedBoot_config_option("FEC network hardware address [MAC]",
+                      fec_esa_data,
+                      "fec_esa", true,
+                      CONFIG_ESA, 0
+                     );
+#endif // CYGPKG_REDBOOT && CYGSEM_REDBOOT_FLASH_CONFIG
diff -urN -x CVS -x doc -x lwip_tcpip -x calmrisc16 -x calmrisc32 ecos_20050912/packages/devs/eth/smsc/lan92xx/current/cdl/smsc_lan92xx_eth_drivers.cdl ecos_base/packages/devs/eth/smsc/lan92xx/current/cdl/smsc_lan92xx_eth_drivers.cdl
--- ecos_20050912/packages/devs/eth/smsc/lan92xx/current/cdl/smsc_lan92xx_eth_drivers.cdl	1969-12-31 18:00:00.000000000 -0600
+++ ecos_base/packages/devs/eth/smsc/lan92xx/current/cdl/smsc_lan92xx_eth_drivers.cdl	2007-10-17 02:52:38.000000000 -0500
@@ -0,0 +1,88 @@
+# ====================================================================
+#
+#      smsc_lan92xx_eth_drivers.cdl
+#
+#      Ethernet drivers - support for LAN92XX compatible ethernet controllers
+#
+# ====================================================================
+#####ECOSGPLCOPYRIGHTBEGIN####
+## -------------------------------------------
+## This file is part of eCos, the Embedded Configurable Operating System.
+## Copyright (C) 2007 Fred Fan
+##
+## eCos is free software; you can redistribute it and/or modify it under
+## the terms of the GNU General Public License as published by the Free
+## Software Foundation; either version 2 or (at your option) any later version.
+##
+## eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+## WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+## for more details.
+##
+## You should have received a copy of the GNU General Public License along
+## with eCos; if not, write to the Free Software Foundation, Inc.,
+## 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+##
+## As a special exception, if other files instantiate templates or use macros
+## or inline functions from this file, or you compile this file and link it
+## with other works to produce a work based on this file, this file does not
+## by itself cause the resulting work to be covered by the GNU General Public
+## License. However the source code for this file must still be made available
+## in accordance with section (3) of the GNU General Public License.
+##
+## This exception does not invalidate any other reasons why a work based on
+## this file might be covered by the GNU General Public License.
+##
+## Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+## at http://sources.redhat.com/ecos/ecos-license/
+## -------------------------------------------
+#####ECOSGPLCOPYRIGHTEND####
+# ====================================================================
+######DESCRIPTIONBEGIN####
+#
+# Author(s):      Fred Fan
+# Contributors:   Fred Fan
+# Date:           2007-9-27
+#
+#####DESCRIPTIONEND####
+#
+# ====================================================================
+
+cdl_package CYGPKG_DEVS_ETH_SMSC_LAN92XX {
+    display       "SMSC LAN92XX compatible ethernet driver"
+    description   "Ethernet driver for SMSC LAN92XX compatible controllers."
+
+    parent        CYGPKG_IO_ETH_DRIVERS
+    active_if	  CYGPKG_IO_ETH_DRIVERS
+
+    implements    CYGHWR_NET_DRIVERS
+    implements    CYGINT_IO_ETH_MULTICAST
+
+    active_if     CYGINT_DEVS_ETH_SMSC_LAN92XX_REQUIRED
+
+    include_dir   cyg/io
+    compile       -library=libextras.a if_lan92xx.c
+
+    define_proc { 
+        puts $::cdl_header "#include <pkgconf/system.h>";
+        puts $::cdl_header "#include CYGDAT_DEVS_ETH_SMSC_LAN92XX_CFG";
+    }
+
+    cdl_component CYGPKG_DEVS_ETH_SMSC_LAN92XX_OPTIONS {
+        display "LAN92XX ethernet driver build options"
+        flavor  none
+	no_define
+
+        cdl_option CYGPKG_DEVS_ETH_SMSC_LAN91CXX_CFLAGS_ADD {
+            display "Additional compiler flags"
+            flavor  data
+            no_define
+            default_value { "-D_KERNEL -D__ECOS" }
+            description   "
+                This option modifies the set of compiler flags for
+                building the LAN91CXX ethernet driver package.
+                These flags are used in addition
+                to the set of global flags."
+        }
+    }
+}
diff -urN -x CVS -x doc -x lwip_tcpip -x calmrisc16 -x calmrisc32 ecos_20050912/packages/devs/eth/smsc/lan92xx/current/include/smsc_lan92xx.h ecos_base/packages/devs/eth/smsc/lan92xx/current/include/smsc_lan92xx.h
--- ecos_20050912/packages/devs/eth/smsc/lan92xx/current/include/smsc_lan92xx.h	1969-12-31 18:00:00.000000000 -0600
+++ ecos_base/packages/devs/eth/smsc/lan92xx/current/include/smsc_lan92xx.h	2007-11-13 13:22:06.000000000 -0600
@@ -0,0 +1,187 @@
+#ifndef CYGONCE_DEVS_ETH_SMSC_LAN92XX_LAN92XX_H
+#define CYGONCE_DEVS_ETH_SMSC_LAN92XX_LAN92XX_H
+//==========================================================================
+//
+//      lan92xx.h
+//
+//      SMCS LAN9217 (LAN92XX compatible) Ethernet chip
+//
+//==========================================================================
+//####ECOSGPLCOPYRIGHTBEGIN####
+// -------------------------------------------
+// This file is part of eCos, the Embedded Configurable Operating System.
+// Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+// Copyright (C) 2003 Nick Garnett 
+//
+// eCos is free software; you can redistribute it and/or modify it under
+// the terms of the GNU General Public License as published by the Free
+// Software Foundation; either version 2 or (at your option) any later version.
+//
+// eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with eCos; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+//
+// As a special exception, if other files instantiate templates or use macros
+// or inline functions from this file, or you compile this file and link it
+// with other works to produce a work based on this file, this file does not
+// by itself cause the resulting work to be covered by the GNU General Public
+// License. However the source code for this file must still be made available
+// in accordance with section (3) of the GNU General Public License.
+//
+// This exception does not invalidate any other reasons why a work based on
+// this file might be covered by the GNU General Public License.
+//
+// Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+// at http://sources.redhat.com/ecos/ecos-license/
+// -------------------------------------------
+//####ECOSGPLCOPYRIGHTEND####
+//####BSDCOPYRIGHTBEGIN####
+//
+// -------------------------------------------
+//
+// Portions of this software may have been derived from OpenBSD or other sources,
+// and are covered by the appropriate copyright disclaimers included herein.
+//
+// -------------------------------------------
+//
+//####BSDCOPYRIGHTEND####
+
+#include <cyg/hal/hal_io.h>
+#include <cyg/hal/hal_endian.h>
+
+#define __WANT_CONFIG
+#include CYGDAT_DEVS_ETH_SMSC_LAN92XX_CFG
+#undef __WANT_CONFIG
+
+typedef struct
+{
+    unsigned short id;
+    unsigned short ver;
+    char *id_name;
+}smsc_lan92xx_id_t;
+
+// LAN92xx register offset
+#define LAN92XX_RX_DATA         0x00
+#define LAN92XX_TX_DATA         0x20
+#define LAN92XX_RX_STATUS1      0x40
+#define LAN92XX_RX_STATUS2      0x44
+#define LAN92XX_TX_STATUS1      0x48
+#define LAN92XX_TX_STATUS2      0x4C
+#define LAN92XX_ID_REV          0x50
+#define LAN92XX_IRQ_CFG         0x54
+#define LAN92XX_INT_STS         0x58
+#define LAN92XX_INT_EN          0x5C
+#define LAN92XX_RESERVED1       0x60
+#define LAN92XX_BYTE_TEST       0x64
+#define LAN92XX_FIFO_INT        0x68
+#define LAN92XX_RX_CFG          0x6C
+#define LAN92XX_TX_CFG          0x70
+#define LAN92XX_HW_CFG          0x74
+#define LAN92XX_RX_DP_CTRL      0x78
+#define LAN92XX_RX_FIFO_INF     0x7C
+#define LAN92XX_TX_FIFO_INF     0x80
+#define LAN92XX_PMT_CTRL        0x84
+#define LAN92XX_GPIO_CFG        0x88
+#define LAN92XX_GPT_CFG         0x8C
+#define LAN92XX_GPT_CNT         0x90
+#define LAN92XX_RESERVED2       0x94
+#define LAN92XX_WORD_SWAP       0x98
+#define LAN92XX_FREE_RUN        0x9C
+#define LAN92XX_RX_DROP         0xA0
+#define LAN92XX_MAC_CMD         0xA4
+#define LAN92XX_MAC_DATA        0xA8
+#define LAN92XX_AFC_CFG         0xAC
+#define LAN92XX_E2P_CMD         0xB0
+#define LAN92XX_E2P_DATA        0xB4
+
+// Access these MAC registers indirectly through MAC_CMD and MAC_DATA
+// registers. 
+#define MAC_MAC_CR 	    1
+#define MAC_ADDRH 	    2
+#define MAC_ADDRL 	    3
+#define MAC_HASHH 	    4
+#define MAC_HASHL 	    5
+#define MAC_MII_ACC     6
+#define MAC_MII_DATA    7
+#define MAC_FLOW        8
+#define MAC_VLAN1       9
+#define MAC_VLAN2       10
+#define MAC_WUFF        11
+#define MAC_WUCSR       12
+
+// These PHY registers are accessed indirectly through the MAC via the 
+// MII interface using the MII_ACC and MII_DATA registers. PHY controls
+// the 802.3 physical layer such as 10/100Mbps, full/half mode.
+#define PHY_BCR         0
+#define PHY_BSR         1
+#define PHY_ID1         2
+#define PHY_ID2         3
+#define PHY_ANAR        4
+#define PHY_ANLPAR      5
+#define PHY_ANER        6
+#define PHY_MCSR        17
+#define PHY_SMR         18
+#define PHY_SCSI        27
+#define PHY_ISR         29
+#define PHY_IMR         30
+#define PHY_SCSR        31
+
+#define PHY_100TX_FD    0x4000
+#define PHY_100TX_HD    0x2000
+#define PHY_10T_RD      0x1000
+#define PHY_10T_HD      0x0800
+#define PHY_LINK_ON     0x0004
+
+#define IS_DUPLEX(x)	((x) & (PHY_100TX_FD | PHY_10T_RD))
+
+#define MAC_TIMEOUT     (1000 * 100)
+#define MAC_TICKET      2
+
+#define E2P_CMD_SHIFT	28
+#define E2P_CMD_BUSY	0x80000000
+#define E2P_CMD_TIMEOUT	0x00000200
+#define E2P_CMD_LOADED	0x00000100
+
+enum epc_cmd {
+    E2P_CMD_READ    = 0 << E2P_CMD_SHIFT,
+    E2P_CMD_EWDS    = 1 << E2P_CMD_SHIFT,
+    E2P_CMD_EWEN    = 2 << E2P_CMD_SHIFT,
+    E2P_CMD_WRITE   = 3 << E2P_CMD_SHIFT,
+    E2P_CMD_WRAL    = 4 << E2P_CMD_SHIFT,
+    E2P_CMD_ERASE   = 5 << E2P_CMD_SHIFT,
+    E2P_CMD_ERAL    = 6 << E2P_CMD_SHIFT,
+    E2P_CMD_Reload  = 7 << E2P_CMD_SHIFT,
+};
+#define E2P_CMD(cmd, addr) (E2P_CMD_BUSY | (cmd) | (addr))
+
+#define E2P_CONTEXT_ID  0xA5
+
+typedef struct
+{
+    unsigned int base;
+    int status;
+    int tx_busy;
+    int tx_key;
+    unsigned char mac_addr[6];
+} smsc_lan92xx_t;
+
+#ifndef LAN92XX_REG_BASE
+#define LAN92XX_REG_BASE    PBC_BASE
+#endif
+
+#ifndef LAN92XX_REG_READ
+#define LAN92XX_REG_READ(reg_offset)  \
+    (*(volatile unsigned int *)(LAN92XX_REG_BASE + reg_offset))
+#endif    
+
+#ifndef LAN92XX_REG_WRITE
+#define LAN92XX_REG_WRITE(reg_offset, val)  \
+    (*(volatile unsigned int *)(LAN92XX_REG_BASE + reg_offset) = (val))
+#endif
+
+#endif // CYGONCE_DEVS_ETH_SMSC_MAC_MAC_H
diff -urN -x CVS -x doc -x lwip_tcpip -x calmrisc16 -x calmrisc32 ecos_20050912/packages/devs/eth/smsc/lan92xx/current/src/if_lan92xx.c ecos_base/packages/devs/eth/smsc/lan92xx/current/src/if_lan92xx.c
--- ecos_20050912/packages/devs/eth/smsc/lan92xx/current/src/if_lan92xx.c	1969-12-31 18:00:00.000000000 -0600
+++ ecos_base/packages/devs/eth/smsc/lan92xx/current/src/if_lan92xx.c	2007-11-29 16:33:13.000000000 -0600
@@ -0,0 +1,710 @@
+//==========================================================================
+//
+//      dev/if_lan92xx.c
+//
+//      Ethernet device driver for SMSC LAN92XX compatible controllers
+//
+//==========================================================================
+//==========================================================================
+
+//#####DESCRIPTIONBEGIN####
+//
+// Author(s):    Fred Fan
+// Contributors:
+// Date:         2007-10-16
+// Purpose:
+// Description:  Driver for SMSC LAN92xx ethernet controller
+//
+// Note:
+//
+//####DESCRIPTIONEND####
+//
+//==========================================================================
+#include <pkgconf/system.h>
+#include <pkgconf/io_eth_drivers.h>
+
+#include <cyg/infra/cyg_type.h>
+#include <cyg/hal/hal_arch.h>
+#include <cyg/hal/hal_intr.h>
+#include <cyg/hal/hal_diag.h>
+#include <cyg/infra/cyg_ass.h>
+#include <cyg/infra/diag.h>
+#include <cyg/hal/drv_api.h>
+#include <cyg/io/eth/netdev.h>
+#include <cyg/io/eth/eth_drv.h>
+#include <cyg/io/smsc_lan92xx.h>
+
+
+#ifdef CYGPKG_NET
+#include <pkgconf/net.h>
+#include <cyg/kernel/kapi.h>
+#include <net/if.h>  /* Needed for struct ifnet */
+#endif
+
+//#define LAN92XX_DEBUG
+#ifdef LAN92XX_DEBUG
+#define PDEBUG(fmt, args...) diag_printf(fmt, ##args)
+#else
+#define PDEBUG(fmt, args...)
+#endif /*LAN92XX_DEBUG*/
+
+#define __WANT_DEVS
+#include CYGDAT_DEVS_ETH_SMSC_LAN92XX_INL
+#undef __WANT_DEVS
+
+#define LAN_92XX_DRV_VER    "1.1"
+
+#define MAX_RX_NUM (CYGNUM_IO_ETH_DRIVERS_NUM_PKT - 1)
+static smsc_lan92xx_id_t smsc_lan92xx_id_table[] = 
+{
+    {0x117A, 0x0000, "SMSC LAN9217"},
+    {0},
+};
+
+static int lan92xx_eeprom_present = 1;
+
+static smsc_lan92xx_t lan92xx_dev;
+static inline void
+lan92xx_set_mac_addr(struct eth_drv_sc *sc, unsigned char *enaddr);
+static void lan92xx_soft_reset(struct eth_drv_sc *sc);
+static inline unsigned int
+lan92xx_mac_read(struct eth_drv_sc *sc, unsigned char reg);
+static inline void
+lan92xx_mac_write(struct eth_drv_sc *sc, unsigned char reg, unsigned long val);
+static inline unsigned int
+lan92xx_mii_read(struct eth_drv_sc *sc, unsigned char addr);
+static inline void
+lan92xx_mii_write(struct eth_drv_sc *sc, unsigned char addr, unsigned int val);
+
+/*!
+ * This function set the value of PHY registers by MII interface
+ */
+static void
+lan92xx_start(struct eth_drv_sc *sc, unsigned char *enaddr, int flags)
+{
+    unsigned int val;
+    smsc_lan92xx_t *pdev = (smsc_lan92xx_t *)(sc->driver_private);
+
+    lan92xx_set_mac_addr(sc, enaddr);
+
+    pdev->tx_busy = 0;
+
+    val = lan92xx_mac_read(sc, MAC_MAC_CR)& (~0x800);
+    val |= 0x0010080C;
+    lan92xx_mac_write(sc, MAC_MAC_CR, val);
+    val = lan92xx_mac_read(sc, MAC_MAC_CR);
+}
+
+/*!
+ * This function pauses the FEC controller.
+ */
+static void
+lan92xx_stop(struct eth_drv_sc *sc)
+{
+    unsigned int val;
+
+    val = lan92xx_mac_read(sc, MAC_MAC_CR);
+    val &= ~(0x0000000C);
+    lan92xx_mac_write(sc, MAC_MAC_CR, val);
+}
+
+static int
+lan92xx_control(struct eth_drv_sc *sc, unsigned long key, void *data, int data_length)
+{
+    /*TODO:: Add support */
+    PDEBUG("%s: key=0x%x, data=0x%x, data_len=0x%x\n",
+           __FUNCTION__, key, (unsigned long)data, (unsigned long)data_length);
+    return 0;
+}
+
+/*!
+ * This function checks the status of FEC control.
+ */
+static int
+lan92xx_can_send(struct eth_drv_sc *sc)
+{
+    smsc_lan92xx_t *pdev = (smsc_lan92xx_t *)(sc->driver_private);
+
+    if (!(pdev->status & PHY_LINK_ON)) return 0;
+    if (pdev->tx_busy) return 0;
+
+    return 1;
+}
+
+/*!
+ * This function transmits a frame.
+ */
+static void
+lan92xx_send(struct eth_drv_sc *sc, struct eth_drv_sg *sg_list, int sg_len, int total, unsigned long key)
+{
+    int i, j, len, freespace;
+    unsigned int tx_cmd1, tx_cmd2, data, *pdata;
+    smsc_lan92xx_t *pdev = (smsc_lan92xx_t *)(sc->driver_private);
+    freespace = LAN92XX_REG_READ(LAN92XX_TX_FIFO_INF) & 0xFFFF;
+
+    if (freespace < total + 16 ) {
+        sc->funs->eth_drv->tx_done(sc, key, -1);
+        return;
+    }
+    for (i = 0; i < sg_len; i++) {
+        len = (sg_list[i].len + 3) >> 2;
+        if (i == (sg_len - 1))
+            tx_cmd1 = 0x1000;
+        else if (i)
+            tx_cmd1 = 0x0000;
+        else
+            tx_cmd1 = 0x2000;
+
+        tx_cmd1 |= sg_list[i].len;
+        tx_cmd2 = (total << 16) + total;
+        LAN92XX_REG_WRITE(LAN92XX_TX_DATA, tx_cmd1);
+
+        LAN92XX_REG_WRITE(LAN92XX_TX_DATA, tx_cmd2);
+        pdata = (unsigned int *)sg_list[i].buf;
+
+        for (j=0; j<len; j++) {
+            data = *(pdata++);
+            LAN92XX_REG_WRITE(LAN92XX_TX_DATA, data);
+            for (data=0; data<2; data++) {
+                asm volatile("nop");
+                asm volatile("nop");
+                asm volatile("nop");
+                asm volatile("nop");
+            }
+        }
+    }
+    pdev->tx_busy = 1;
+    pdev->tx_key = key;
+}
+
+static void
+lan92xx_drop_packet(struct eth_drv_sc *sc, int count)
+{
+    unsigned int data;
+    if (count >= 4) {
+        LAN92XX_REG_WRITE(LAN92XX_RX_DP_CTRL, 0x80000000);
+        while (LAN92XX_REG_READ(LAN92XX_RX_DP_CTRL) & 0x80000000) {
+        }
+    } else {
+        while (count--)
+            data = LAN92XX_REG_READ(LAN92XX_RX_DATA);
+    }
+}
+
+/*!
+ * This function receives ready Frame in DB.
+ */
+static void
+lan92xx_recv(struct eth_drv_sc *sc, struct eth_drv_sg *sg_list, int sg_len)
+{
+    unsigned int i, len, rlen, status;
+    unsigned int *pdata = (unsigned int *)(sg_list->buf);
+
+    status = LAN92XX_REG_READ(LAN92XX_RX_STATUS1);
+
+    len = (status >> 16) & 0x3FFF;
+    rlen = (len + 3) >> 2;
+    if (((void *)(sg_list->buf) == NULL) || (sg_list->len == 0)) {
+        //diag_printf("WARING[RX]: the sg_list is empty\n");
+        goto Drop;
+    }
+
+    if (sg_list->len < len) {
+        diag_printf("WARING[RX]: packet(%dB)large than buffer (%dB)\n",
+                    sg_list->len, len);
+        goto Drop;
+    }
+
+    for (i = 0; i < rlen; i++) {
+        *(pdata++) = LAN92XX_REG_READ(LAN92XX_RX_DATA);
+    }
+    return; 
+Drop:
+    lan92xx_drop_packet(sc, rlen);    
+}
+
+static void
+lan92xx_deliver(struct eth_drv_sc *sc)
+{
+    /*TODO::When redboot support thread ,
+     *      the polling function will be called at here
+     */
+    return;
+}
+
+static void 
+lan92xx_link_status(struct eth_drv_sc *sc)
+{
+    unsigned int val;
+    smsc_lan92xx_t *pdev = (smsc_lan92xx_t *)(sc->driver_private);
+    val = lan92xx_mii_read(sc, PHY_ISR);
+    if (val&0x50) {
+        val = lan92xx_mii_read(sc, PHY_BSR);
+        if (val != pdev->status) {
+            pdev->status = val;
+            val = lan92xx_mac_read(sc, MAC_MAC_CR) & (~0x802F0800);
+            if ( IS_DUPLEX(pdev->status)) {
+                val |= 0x00100000;
+            }
+            lan92xx_mac_write(sc, MAC_MAC_CR, val);
+        }
+    }
+}
+/*!
+ * This function checks the event of FEC controller
+ */
+static void
+lan92xx_poll(struct eth_drv_sc *sc)
+{
+    unsigned int val, reg;
+    int rx_num = 0;
+    smsc_lan92xx_t *pdev = (smsc_lan92xx_t *)(sc->driver_private);
+
+    reg = LAN92XX_REG_READ(LAN92XX_INT_STS);
+    LAN92XX_REG_WRITE(LAN92XX_INT_STS, reg);
+
+    //diag_printf("INT_STS: %x\n", reg);	
+    if (reg & 0x40000) {
+        lan92xx_link_status(sc);
+    }
+
+    if (reg & 0xE000) {
+        diag_printf("%s:: TX or RX error [0x%x]\n", __FUNCTION__, reg);
+        lan92xx_soft_reset(sc);
+        return;
+    }
+
+    while (1) {
+        reg = LAN92XX_REG_READ(LAN92XX_RX_FIFO_INF);
+        if (!(reg & 0xFF0000))
+            break;
+        if (!LAN92XX_REG_READ(LAN92XX_RX_STATUS2)) {
+            diag_printf("***FIFO 0x%x, wrong status =0x%x: int_sts=0x%x\n",
+                        reg, LAN92XX_REG_READ(LAN92XX_RX_STATUS2),
+                        LAN92XX_REG_READ(LAN92XX_INT_STS));
+            continue;
+        }
+
+        if (LAN92XX_REG_READ(LAN92XX_RX_STATUS2) & 0x4000909A) {
+            val = (LAN92XX_REG_READ(LAN92XX_RX_STATUS1) >> 16) & 0x3FFF;
+            val = (val + 3) >> 2;
+            lan92xx_drop_packet(sc, val);
+        } else {
+            val = (LAN92XX_REG_READ(LAN92XX_RX_STATUS2) >> 16) & 0x3FFF;
+            sc->funs->eth_drv->recv(sc, (val + 3) & (~3));
+            rx_num++;
+        }
+        if ( rx_num >= MAX_RX_NUM) break;
+    }
+
+    while (1) {
+        reg = LAN92XX_REG_READ(LAN92XX_TX_FIFO_INF);
+        if (!(reg & 0xFF0000)) break;
+
+        if (!LAN92XX_REG_READ(LAN92XX_TX_STATUS2)) {
+            diag_printf("***FIFO %x, wrong status =%x: int_sts=%x\n",
+                        reg, LAN92XX_REG_READ(LAN92XX_TX_STATUS2),
+                        LAN92XX_REG_READ(LAN92XX_INT_STS));
+            continue;
+        }
+        reg = LAN92XX_REG_READ(LAN92XX_TX_STATUS1);
+        if (reg & 0x8000) {
+            sc->funs->eth_drv->tx_done(sc, pdev->tx_key, -1);   
+        } else {
+            sc->funs->eth_drv->tx_done(sc, pdev->tx_key, 0);
+        }
+        pdev->tx_busy = 0;
+    }
+}
+
+static int
+lan92xx_int_vector(struct eth_drv_sc *sc)
+{
+    PDEBUG("%s::\n", __FUNCTION__);
+
+    /*TODO::
+     *      get FEC interrupt number
+     */
+    return -1;
+}
+
+static smsc_lan92xx_id_t *lan92xx_probe(unsigned long id)
+{
+    smsc_lan92xx_id_t *p = smsc_lan92xx_id_table;
+    while (p->id) {
+        if (id == p->id)
+            return p;
+        p++;
+    }
+    return NULL;
+}
+
+static inline unsigned int
+lan92xx_mac_read(struct eth_drv_sc *sc, unsigned char reg)
+{
+    unsigned int cmd;
+    
+    if (LAN92XX_REG_READ(LAN92XX_MAC_CMD) & 0x80000000) {
+        diag_printf("Error: %d. MAC is busy\n", __LINE__);
+        return 0xFFFFFFFF;
+    }
+
+    cmd = 0xC0000000 | reg;
+    LAN92XX_REG_WRITE(LAN92XX_MAC_CMD, cmd);
+
+    while (LAN92XX_REG_READ(LAN92XX_MAC_CMD) & 0x80000000);
+
+    return LAN92XX_REG_READ(LAN92XX_MAC_DATA);
+}
+
+static inline void
+lan92xx_mac_write(struct eth_drv_sc *sc, unsigned char reg, unsigned long val)
+{
+    unsigned int cmd;
+
+    if (LAN92XX_REG_READ(LAN92XX_MAC_CMD) & 0x80000000) {
+        diag_printf("Error: %d. MAC is busy\n", __LINE__);
+        return;
+    }
+
+    LAN92XX_REG_WRITE(LAN92XX_MAC_DATA, val);
+    cmd = 0x80000000 | reg;
+    LAN92XX_REG_WRITE(LAN92XX_MAC_CMD, cmd);
+
+    while (LAN92XX_REG_READ(LAN92XX_MAC_CMD) & 0x80000000);
+}
+
+static inline void 
+lan92xx_set_mac_addr(struct eth_drv_sc *sc, unsigned char *enaddr)
+{
+    unsigned int val;
+    val = enaddr[3];
+    val = (val << 8) | enaddr[2];
+    val = (val << 8) | enaddr[1];
+    val = (val << 8) | enaddr[0];
+    lan92xx_mac_write(sc, MAC_ADDRL, val);
+
+    val = lan92xx_mac_read(sc, MAC_ADDRH) >> 16;
+    val = (val << 8) | enaddr[5];
+    val = (val << 8) | enaddr[4];
+    lan92xx_mac_write(sc, MAC_ADDRH, val);
+}
+
+static inline unsigned int
+lan92xx_mii_read(struct eth_drv_sc *sc, unsigned char addr)
+{
+    unsigned int cmd;
+
+    cmd = (0x1 << 11 ) | (addr << 6) | 1;
+    lan92xx_mac_write(sc, MAC_MII_ACC, cmd);
+    while (lan92xx_mac_read(sc, MAC_MII_ACC) & 1);
+
+    return lan92xx_mac_read(sc, MAC_MII_DATA)&0xFFFF;
+}
+
+static inline void 
+lan92xx_mii_write(struct eth_drv_sc *sc, unsigned char addr, unsigned int val)
+{
+    unsigned int cmd;
+
+    cmd = (0x1 << 11 ) | (addr << 6) | 3;
+    lan92xx_mac_write(sc, MAC_MII_DATA, val);
+    lan92xx_mac_read(sc, MAC_MII_DATA);
+    lan92xx_mac_write(sc, MAC_MII_ACC, cmd);
+
+    while (lan92xx_mac_read(sc, MAC_MII_ACC) & 1);
+}
+
+static int lan92xx_phy_init(struct eth_drv_sc *sc)
+{
+    int val;
+    smsc_lan92xx_t *pdev = (smsc_lan92xx_t *)(sc->driver_private);
+
+    lan92xx_mii_write(sc, PHY_BCR, 0x8000);
+
+    while (lan92xx_mii_read(sc, PHY_BCR) & 0x8000);
+
+    for (val = 0; val < 2500; val++)
+        hal_delay_us(4);
+
+    val = lan92xx_mii_read(sc, PHY_ANAR);
+    val |= 0x01E1;
+    lan92xx_mii_write(sc, PHY_ANAR, val);
+    lan92xx_mii_write(sc, PHY_SMR, 0x00E1);
+    lan92xx_mii_write(sc, PHY_SCSI, 0x400B);
+    lan92xx_mii_write(sc, PHY_IMR, 0x00F0);
+    lan92xx_mii_write(sc, PHY_BCR, 0x1200);
+
+    while ((lan92xx_mii_read(sc, PHY_BCR) & 0x200));
+
+    pdev->status = lan92xx_mii_read(sc, PHY_BSR);
+
+    return 0;
+}
+
+static int lan92xx_mac_init(struct eth_drv_sc *sc)
+{
+    static int mac_init = 0;
+    unsigned int val;
+    smsc_lan92xx_t *pdev = (smsc_lan92xx_t *)(sc->driver_private);
+
+    val = lan92xx_mac_read(sc, MAC_MAC_CR) & (~0x802F0800);
+    if (IS_DUPLEX(pdev->status)) {
+        val |= 0x00100000;
+    }
+    lan92xx_mac_write(sc, MAC_MAC_CR, val);
+
+    lan92xx_mac_write(sc, MAC_HASHH, 0);
+    lan92xx_mac_write(sc, MAC_HASHL, 0);
+
+    if (mac_init)
+        return 0;
+
+    mac_init = 1;
+
+#if CYGSEM_HAL_VIRTUAL_VECTOR_SUPPORT
+    if (!_board_provide_eth0_esa(pdev->mac_addr))
+#endif	
+    {
+        // make sure EPC not busy
+        while ((val = LAN92XX_REG_READ(LAN92XX_E2P_CMD)) & E2P_CMD_BUSY);
+
+        if (val & E2P_CMD_TIMEOUT) {
+            lan92xx_eeprom_present = 0;
+            diag_printf("LAN9217: NO EEPROM\n");
+            return -1;
+        }
+        
+        if (!(LAN92XX_REG_READ(LAN92XX_E2P_CMD) & E2P_CMD_LOADED)) {
+            diag_printf("LAN9217:EEPROM is empty\n");
+        }
+        val = lan92xx_mac_read(sc, MAC_ADDRH);
+        pdev->mac_addr[5] = (val >> 8) & 0xFF;
+        pdev->mac_addr[4] = val&0xFF;
+        val = lan92xx_mac_read(sc, MAC_ADDRL);
+        pdev->mac_addr[3] = (val >> 24) & 0xFF;
+        pdev->mac_addr[2] = (val >> 16) & 0xFF;
+        pdev->mac_addr[1] = (val >> 8) & 0xFF;
+        pdev->mac_addr[0] = val & 0xFF;
+    }
+    return 0;
+}
+
+/*
+ * This function reset LAN9219 .
+ */
+static void
+lan92xx_soft_reset(struct eth_drv_sc *sc)
+{
+    unsigned int timeout = MAC_TIMEOUT;
+
+    LAN92XX_REG_WRITE(LAN92XX_HW_CFG, 1);
+    while ((LAN92XX_REG_READ(LAN92XX_HW_CFG) & 1) && (--timeout)) {
+        hal_delay_us(MAC_TICKET);
+    }
+
+    if (!timeout) {
+        diag_printf("LAN92XX: Reset fail \n");
+        return ;
+    }
+
+    LAN92XX_REG_WRITE(LAN92XX_INT_EN, 0);
+    LAN92XX_REG_WRITE(LAN92XX_HW_CFG, 0x150000);
+    LAN92XX_REG_WRITE(LAN92XX_AFC_CFG, 0x6E3740);
+    LAN92XX_REG_WRITE(LAN92XX_TX_CFG, 0x2);
+    LAN92XX_REG_WRITE(LAN92XX_INT_EN, 0x40000);
+
+    timeout = MAC_TIMEOUT;
+
+    while ((LAN92XX_REG_READ(LAN92XX_E2P_CMD) & 0x80000000) && (--timeout)) {
+        hal_delay_us(MAC_TICKET);
+    }
+
+    LAN92XX_REG_WRITE(LAN92XX_GPIO_CFG, 0x70070000);
+    LAN92XX_REG_WRITE(LAN92XX_INT_STS, 0xFFFFFFFF);
+    lan92xx_mac_init(sc);
+}
+
+/*!
+ * This function initializes the LAN92xx driver.
+ * It is called by net_init in net module of RedBoot during RedBoot init
+ */
+static bool
+lan92xx_init(struct cyg_netdevtab_entry *tab)
+{
+    unsigned int reg, timeout;
+    smsc_lan92xx_id_t *id;
+    struct eth_drv_sc *sc = tab ? tab->device_instance : NULL;
+    smsc_lan92xx_t *pdev = (smsc_lan92xx_t *)(sc->driver_private);
+
+    diag_printf("\nLAN92xx Driver version %s\n", LAN_92XX_DRV_VER);  
+    if (!pdev) {
+        diag_printf("LAN92xx:: Driver don't attach with device\n");
+        return false;
+    }
+    reg = LAN92XX_REG_READ(LAN92XX_ID_REV);
+    id = lan92xx_probe(reg >> 16);
+    if (id) {
+        diag_printf("%s: ID = 0x%x REV = 0x%x\n", id->id_name, id->id, id->ver);
+    } else {
+        diag_printf("LAN92XX: unknow chip ID = %x\n", reg);
+        return false;
+    }
+
+    timeout = MAC_TIMEOUT;
+    while ((!(LAN92XX_REG_READ(LAN92XX_PMT_CTRL) & 1)) && (--timeout)) {
+        hal_delay_us(MAC_TICKET);
+    }
+    if (timeout == 0) {
+        diag_printf("LAN92XX: is not ready to access\n");
+        return false;
+    }
+
+    lan92xx_phy_init(sc);
+
+    lan92xx_soft_reset(sc);
+    (sc->funs->eth_drv->init)(sc, pdev->mac_addr);
+    return true;
+}
+
+/*!
+ * Global variable which defines the LAN92xx driver,
+ */
+ETH_DRV_SC(lan92xx_sc,
+           &lan92xx_dev, // Driver specific data
+           CYGDAT_DEVS_ETH_ARM_MXCBOARD_ETH0_NAME,
+           lan92xx_start,
+           lan92xx_stop,
+           lan92xx_control,
+           lan92xx_can_send,
+           lan92xx_send,
+           lan92xx_recv,
+           lan92xx_deliver,     // "pseudoDSR" called from fast net thread
+           lan92xx_poll,        // poll function, encapsulates ISR and DSR
+           lan92xx_int_vector);
+
+/*!
+ * Global variable which defines the FEC device
+ */
+NETDEVTAB_ENTRY(lan92xx_netdev,
+                "lan92xx_" CYGDAT_DEVS_ETH_ARM_MXCBOARD_ETH0_NAME,
+                lan92xx_init,
+                &lan92xx_sc);
+
+// Low level function to issue a command to the eeprom controller.
+// return 0 on success and -1 on failure
+static inline int 
+_lan92xx_e2p_do_cmd(unsigned int cmd)   
+{
+    unsigned int v;
+    LAN92XX_REG_WRITE(LAN92XX_E2P_CMD, cmd);
+    while ((v = LAN92XX_REG_READ(LAN92XX_E2P_CMD)) & E2P_CMD_BUSY);
+    if (v & E2P_CMD_TIMEOUT) {
+        diag_printf("%s:: EEPROM timeout\n", __FUNCTION__);
+        // clear the timeout status bit
+        LAN92XX_REG_WRITE(LAN92XX_E2P_CMD, E2P_CMD_TIMEOUT);
+        while ((v = LAN92XX_REG_READ(LAN92XX_E2P_CMD)) & E2P_CMD_BUSY);
+        return -1;
+    }
+    return 0;
+}
+
+// for all the 7 EEPROM operations
+// return 0 on success and -1 on failure
+static int
+lan92xx_e2p_op(enum epc_cmd cmd, unsigned char addr, unsigned char *data)
+{
+    switch (cmd) {
+    case E2P_CMD_READ:
+        if (_lan92xx_e2p_do_cmd(E2P_CMD(cmd, addr)) != 0)
+            return -1;
+        *data = (unsigned char)LAN92XX_REG_READ(LAN92XX_E2P_DATA);
+        return 0;
+        break;
+    case E2P_CMD_WRAL:
+    case E2P_CMD_WRITE:
+        LAN92XX_REG_WRITE(LAN92XX_E2P_DATA, *data);
+        break;
+    default:
+        break;
+    }
+
+    if (_lan92xx_e2p_do_cmd(E2P_CMD(cmd, addr)) != 0)
+        return -1;
+
+    return 0;
+}
+
+static void setMac(int argc, char *argv[])
+{
+    int i;  
+    unsigned char data[7];
+    unsigned long temp;
+
+    if (!lan92xx_eeprom_present) {
+        diag_printf("NO EEPROM present\n\n");
+        return;
+    }
+
+    if (argc == 1) {
+        for (i = 0; i < 7 ; i++) {
+            if (lan92xx_e2p_op(E2P_CMD_READ, i, &data[i]) != 0) {
+                diag_printf("read MAC %d address fail\n\n", i);
+                return;
+            }
+        }
+
+        if (data[0] != E2P_CONTEXT_ID) {
+            diag_printf("Warning: Unprogrammed MAC address: 0x%x\n", data[0]);
+            return;
+        }
+
+        diag_printf("MAC address: ");
+        diag_printf("0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x\n\n",
+                    data[1], data[2], data[3],
+                    data[4], data[5], data[6]);
+        return;
+    }
+
+    if (argc != 2) {
+        diag_printf("Error: Wrong argument\n");
+        return;
+    }
+
+    data[0] = E2P_CONTEXT_ID;
+    for (i = 1;  i < 7;  i++) {
+        if (!parse_num(*(&argv[1]), &temp, &argv[1], ":")) {
+            diag_printf("Error: failed to parse command: %d\n", __LINE__);
+            return;
+        }
+        if (temp > 0xFF) {
+            diag_printf("Error: invalid valie: 0x%x\n", (unsigned int)temp);
+            return;
+        }
+        data[i] = temp;
+    }
+
+    // enable erase/write
+    if (lan92xx_e2p_op(E2P_CMD_EWEN, 0, data) != 0) {
+        diag_printf("%s:: Enable write/erase fail\n", __FUNCTION__);
+        return;
+    }
+    for (i = 0; i < 7; i++) {
+        if (lan92xx_e2p_op(E2P_CMD_ERASE, i, &data[i]) != 0 || 
+            lan92xx_e2p_op(E2P_CMD_WRITE, i, &data[i]) != 0) {
+            diag_printf("Error: failed to program eeprom at %d\n", i);
+            return;
+        }
+    }
+
+    // disable erase/write
+    if (lan92xx_e2p_op(E2P_CMD_EWDS, 0, data) != 0) {
+        diag_printf("%s:: Enable write/erase fail\n", __FUNCTION__);
+    }
+}
+
+RedBoot_cmd("setmac",
+            "Set Ethernet MAC address in EEPROM",
+            "[0x##:0x##:0x##:0x##:0x##:0x##]",
+            setMac
+           );
diff -urN -x CVS -x doc -x lwip_tcpip -x calmrisc16 -x calmrisc32 ecos_20050912/packages/devs/flash/amd/am29xxxxx/current/cdl/flash_amd_am29xxxxx.cdl ecos_base/packages/devs/flash/amd/am29xxxxx/current/cdl/flash_amd_am29xxxxx.cdl
--- ecos_20050912/packages/devs/flash/amd/am29xxxxx/current/cdl/flash_amd_am29xxxxx.cdl	2005-06-12 08:41:12.000000000 -0500
+++ ecos_base/packages/devs/flash/amd/am29xxxxx/current/cdl/flash_amd_am29xxxxx.cdl	2008-02-20 01:00:07.000000000 -0600
@@ -307,6 +307,36 @@
             part in the family."
     }
 
+    cdl_option CYGHWR_DEVS_FLASH_AMD_S29GL128N {
+        display       "AMD/SPANSION S29GL128N flash memory support"
+        default_value 0
+        implements    CYGINT_DEVS_FLASH_AMD_VARIANTS
+        description   "
+            When this option is enabled, the AMD/SPANSION flash driver will be
+            able to recognize and handle the S29GL128N
+            part in the family."
+    }
+
+    cdl_option CYGHWR_DEVS_FLASH_AMD_S29GL256N {
+        display       "AMD/SPANSION S29GL256N flash memory support"
+        default_value 0
+        implements    CYGINT_DEVS_FLASH_AMD_VARIANTS
+        description   "
+            When this option is enabled, the AMD/SPANSION flash driver will be
+            able to recognize and handle the S29GL256N
+            part in the family."
+    }
+
+    cdl_option CYGHWR_DEVS_FLASH_AMD_S29GL512N {
+        display       "AMD/SPANSION S29GL512N flash memory support"
+        default_value 0
+        implements    CYGINT_DEVS_FLASH_AMD_VARIANTS
+        description   "
+            When this option is enabled, the AMD/SPANSION flash driver will be
+            able to recognize and handle the S29GL512N
+            part in the family."
+    }
+
     cdl_option CYGHWR_DEVS_FLASH_AMD_S29PL032J {
         display       "Spansion S29PL032J flash memory support"
         default_value 0
@@ -337,4 +367,14 @@
             part in the family."
     }
 
-}
+    cdl_option CYGHWR_DEVS_FLASH_S29WS256N {
+        display       "SPANSION flash memory support"
+        default_value 0
+        implements    CYGINT_DEVS_FLASH_AMD_VARIANTS
+        description   "
+            When this option is enabled, the AMD flash driver will be
+            able to recognize and handle the S29WS256N
+            part in the family."
+    }
+
+}
diff -urN -x CVS -x doc -x lwip_tcpip -x calmrisc16 -x calmrisc32 ecos_20050912/packages/devs/flash/amd/am29xxxxx/current/include/flash_am29xxxxx.inl ecos_base/packages/devs/flash/amd/am29xxxxx/current/include/flash_am29xxxxx.inl
--- ecos_20050912/packages/devs/flash/amd/am29xxxxx/current/include/flash_am29xxxxx.inl	2004-04-23 15:50:32.000000000 -0500
+++ ecos_base/packages/devs/flash/amd/am29xxxxx/current/include/flash_am29xxxxx.inl	2008-02-20 00:48:13.000000000 -0600
@@ -169,7 +169,7 @@
     cyg_bool     bootblock;
     cyg_uint32   bootblocks[64];         // 0 is bootblock offset, 1-11 sub-sector sizes (or 0)
     cyg_bool     banked;
-    cyg_uint32   banks[8];               // bank offsets, highest to lowest (lowest should be 0)
+    cyg_uint32   banks[16];               // bank offsets, highest to lowest (lowest should be 0)
                                          // (only one entry for now, increase to support devices
                                          // with more banks).
     cyg_uint32   bufsiz;                 // write buffer size in units of flash_data_t
@@ -184,6 +184,7 @@
 //----------------------------------------------------------------------------
 // Functions that put the flash device into non-read mode must reside
 // in RAM.
+#ifndef MXCFLASH_SELECT_MULTI
 void flash_query(void* data) __attribute__ ((section (".2ram.flash_query")));
 int  flash_erase_block(void* block, unsigned int size) 
     __attribute__ ((section (".2ram.flash_erase_block")));
@@ -197,6 +198,17 @@
 static flash_data_t * find_sector(volatile flash_data_t * addr, unsigned long *remain_size)
     __attribute__ ((section (".2ram.find_sector")));
 
+#else
+void norflash_query(void* data);
+int  norflash_erase_block(void* block, unsigned int size);
+int  norflash_program_buf(void* addr, void* data, int len);
+
+//----------------------------------------------------------------------------
+// Auxiliary functions
+static volatile flash_data_t * find_bank(volatile flash_data_t * base, void * addr, CYG_ADDRWORD * bo);
+static flash_data_t * find_sector(volatile flash_data_t * addr, unsigned long *remain_size);
+#endif //MXCFLASH_SELECT_MULTI
+
 //----------------------------------------------------------------------------
 // Flash Query
 //
@@ -205,7 +217,11 @@
 // will be of the same type.
 
 void
+#ifndef MXCFLASH_SELECT_MULTI
 flash_query(void* data)
+#else
+norflash_query(void* data)
+#endif
 {
     volatile flash_data_t *ROM;
     volatile flash_data_t *f_s1, *f_s2;
@@ -245,7 +261,11 @@
 //----------------------------------------------------------------------------
 // Initialize driver details
 int
+#ifndef MXCFLASH_SELECT_MULTI
 flash_hwr_init(void)
+#else
+norflash_hwr_init(void)
+#endif
 {
     flash_data_t id[4];
     int i;
@@ -281,7 +301,11 @@
 //----------------------------------------------------------------------------
 // Map a hardware status to a package error
 int
+#ifndef MXCFLASH_SELECT_MULTI
 flash_hwr_map_error(int e)
+#else
+norflash_hwr_map_error(int e)
+#endif
 {
     return e;
 }
@@ -290,7 +314,11 @@
 //----------------------------------------------------------------------------
 // See if a range of FLASH addresses overlaps currently running code
 bool
+#ifndef MXCFLASH_SELECT_MULTI
 flash_code_overlaps(void *start, void *end)
+#else
+norflash_code_overlaps(void *start, void *end)
+#endif
 {
     extern unsigned char _stext[], _etext[];
 
@@ -304,7 +332,11 @@
 // Erase Block
 
 int
+#ifndef MXCFLASH_SELECT_MULTI
 flash_erase_block(void* block, unsigned int size)
+#else
+norflash_erase_block(void* block, unsigned int size)
+#endif
 {
     volatile flash_data_t* ROM, *BANK;
     volatile flash_data_t* b_p = (flash_data_t*) block;
@@ -344,6 +376,8 @@
         }
     }
 
+#define CYGHWR_FLASH_AM29XXXXX_NO_WRITE_PROTECT
+
     while (size > 0) {
 #ifndef CYGHWR_FLASH_AM29XXXXX_NO_WRITE_PROTECT
         // First check whether the block is protected
@@ -427,7 +461,11 @@
 //----------------------------------------------------------------------------
 // Program Buffer
 int
+#ifndef MXCFLASH_SELECT_MULTI
 flash_program_buf(void* addr, void* data, int len)
+#else
+norflash_program_buf(void* addr, void* data, int len)
+#endif
 {
     volatile flash_data_t* ROM;
     volatile flash_data_t* BANK;
@@ -480,7 +518,7 @@
             // Initiate buffered write
             *f_s1 = FLASH_Setup_Code1;
             *f_s2 = FLASH_Setup_Code2;
-            *SECT = FLASH_Load_Buffer;
+            *addr_v = FLASH_Load_Buffer;
             *SECT = FLASHWORD(nwords - 1);  // All devices need to see this
 
             // Load data into write buffer, flush buffer
@@ -585,4 +623,4 @@
     return (flash_data_t *) res;
 }
 
-#endif // CYGONCE_DEVS_FLASH_AMD_AM29XXXXX_INL
+#endif // CYGONCE_DEVS_FLASH_AMD_AM29XXXXX_INL
diff -urN -x CVS -x doc -x lwip_tcpip -x calmrisc16 -x calmrisc32 ecos_20050912/packages/devs/flash/amd/am29xxxxx/current/include/flash_am29xxxxx_parts.inl ecos_base/packages/devs/flash/amd/am29xxxxx/current/include/flash_am29xxxxx_parts.inl
--- ecos_20050912/packages/devs/flash/amd/am29xxxxx/current/include/flash_am29xxxxx_parts.inl	2005-06-12 08:41:12.000000000 -0500
+++ ecos_base/packages/devs/flash/amd/am29xxxxx/current/include/flash_am29xxxxx_parts.inl	2008-02-20 00:48:13.000000000 -0600
@@ -1114,6 +1114,7 @@
         bufsiz     : 1
     },
 #endif
+
 #ifdef CYGHWR_DEVS_FLASH_AMD_AM29LV256
     {   // AMD AM29LV256
         long_device_id: true,
@@ -1249,6 +1250,55 @@
         bufsiz     : 1
     },
 #endif
+
+#ifdef CYGHWR_DEVS_FLASH_AMD_S29GL512N
+    {   // AMD/SPANSION S29GL512N
+	long_device_id: true,
+	device_id  : FLASHWORD(0x227e),
+	device_id2 : FLASHWORD(0x2223),
+        device_id3 : FLASHWORD(0x2201),
+        block_size : 0x20000 * CYGNUM_FLASH_INTERLEAVE,
+        block_count: 512,
+        device_size: 0x4000000 * CYGNUM_FLASH_INTERLEAVE,
+        base_mask  : ~(0x4000000 * CYGNUM_FLASH_INTERLEAVE - 1),
+        bootblock  : false,
+        banked     : false,
+        bufsiz     : 16
+    },
+#endif
+
+#ifdef CYGHWR_DEVS_FLASH_AMD_S29GL256N
+    {   // AMD/SPANSION S29GL256N
+	long_device_id: true,
+	device_id  : FLASHWORD(0x227e),
+	device_id2 : FLASHWORD(0x2222),
+        device_id3 : FLASHWORD(0x2201),
+        block_size : 0x20000 * CYGNUM_FLASH_INTERLEAVE,
+        block_count: 256,
+        device_size: 0x2000000 * CYGNUM_FLASH_INTERLEAVE,
+        base_mask  : ~(0x2000000 * CYGNUM_FLASH_INTERLEAVE - 1),
+        bootblock  : false,
+        banked     : false,
+        bufsiz     : 16
+    },
+#endif
+
+#ifdef CYGHWR_DEVS_FLASH_AMD_S29GL128N
+    {   // AMD/SPANSION S29GL128N
+	long_device_id: true,
+	device_id  : FLASHWORD(0x227e),
+	device_id2 : FLASHWORD(0x2221),
+        device_id3 : FLASHWORD(0x2201),
+        block_size : 0x20000 * CYGNUM_FLASH_INTERLEAVE,
+        block_count: 128,
+        device_size: 0x1000000 * CYGNUM_FLASH_INTERLEAVE,
+        base_mask  : ~(0x1000000 * CYGNUM_FLASH_INTERLEAVE - 1),
+        bootblock  : false,
+        banked     : false,
+        bufsiz     : 16
+    },
+#endif
+
 #ifdef CYGHWR_DEVS_FLASH_AMD_S29GL064M
     {   // AMD/SPANSION S29GL064M
 	long_device_id: true,
@@ -1290,6 +1340,52 @@
     },
 #endif
 
+#ifdef CYGHWR_DEVS_FLASH_S29WS256N
+    {       // SPANSION S29WS256N (compatible with AM29DL640D except for IDs.)
+        long_device_id: true,
+        device_id  : FLASHWORD(0x227e),
+        device_id2 : FLASHWORD(0x2230),
+        device_id3 : FLASHWORD(0x2200),
+        block_size : 0x20000 * CYGNUM_FLASH_INTERLEAVE,
+        block_count: 256,
+        device_size: 0x2000000 * CYGNUM_FLASH_INTERLEAVE,
+        base_mask  : ~(0x2000000 * CYGNUM_FLASH_INTERLEAVE - 1),
+        bootblock  : true,
+        bootblocks : { 0x00000000 * CYGNUM_FLASH_INTERLEAVE, /* offset not absolute */
+                       0x8000 * CYGNUM_FLASH_INTERLEAVE,
+                       0x8000 * CYGNUM_FLASH_INTERLEAVE,
+                       0x8000 * CYGNUM_FLASH_INTERLEAVE,
+                       0x8000 * CYGNUM_FLASH_INTERLEAVE,
+                       0x01FE0000 * CYGNUM_FLASH_INTERLEAVE,  /* offset not absolute */
+                       0x8000 * CYGNUM_FLASH_INTERLEAVE,
+                       0x8000 * CYGNUM_FLASH_INTERLEAVE,
+                       0x8000 * CYGNUM_FLASH_INTERLEAVE,
+                       0x8000 * CYGNUM_FLASH_INTERLEAVE,
+                       _LAST_BOOTBLOCK
+                     },
+        banked     : true,
+        banks      : { 
+                       0x1E00000 * CYGNUM_FLASH_INTERLEAVE,
+                       0x1C00000 * CYGNUM_FLASH_INTERLEAVE,
+                       0x1A00000 * CYGNUM_FLASH_INTERLEAVE,
+                       0x1800000 * CYGNUM_FLASH_INTERLEAVE,
+                       0x1600000 * CYGNUM_FLASH_INTERLEAVE,
+                       0x1400000 * CYGNUM_FLASH_INTERLEAVE,
+                       0x1200000 * CYGNUM_FLASH_INTERLEAVE,
+                       0x1000000 * CYGNUM_FLASH_INTERLEAVE,
+                       0xE00000 * CYGNUM_FLASH_INTERLEAVE,
+                       0xC00000 * CYGNUM_FLASH_INTERLEAVE,
+                       0xA00000 * CYGNUM_FLASH_INTERLEAVE,
+                       0x800000 * CYGNUM_FLASH_INTERLEAVE,
+                       0x600000 * CYGNUM_FLASH_INTERLEAVE,
+                       0x400000 * CYGNUM_FLASH_INTERLEAVE,
+                       0x200000 * CYGNUM_FLASH_INTERLEAVE, //starting of bank1
+                       0                                   //starting of bank0
+                     },
+        bufsiz     : 1
+    },
+#endif
+
 #endif // 16 bit devices
 
-#endif // CYGONCE_DEVS_FLASH_AMD_AM29XXXXX_PARTS_INL
+#endif // CYGONCE_DEVS_FLASH_AMD_AM29XXXXX_PARTS_INL
diff -urN -x CVS -x doc -x lwip_tcpip -x calmrisc16 -x calmrisc32 ecos_20050912/packages/devs/flash/arm/imx_3stack/current/cdl/flash_board_spansion.cdl ecos_base/packages/devs/flash/arm/imx_3stack/current/cdl/flash_board_spansion.cdl
--- ecos_20050912/packages/devs/flash/arm/imx_3stack/current/cdl/flash_board_spansion.cdl	1969-12-31 18:00:00.000000000 -0600
+++ ecos_base/packages/devs/flash/arm/imx_3stack/current/cdl/flash_board_spansion.cdl	2008-04-01 10:32:15.000000000 -0500
@@ -0,0 +1,71 @@
+# ====================================================================
+#
+#      flash_board_spansion.cdl
+#
+#      FLASH memory - Hardware support
+#
+# ====================================================================
+#####ECOSGPLCOPYRIGHTBEGIN####
+## -------------------------------------------
+## This file is part of eCos, the Embedded Configurable Operating System.
+## Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+##
+## eCos is free software; you can redistribute it and/or modify it under
+## the terms of the GNU General Public License as published by the Free
+## Software Foundation; either version 2 or (at your option) any later version.
+##
+## eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+## WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+## for more details.
+##
+## You should have received a copy of the GNU General Public License along
+## with eCos; if not, write to the Free Software Foundation, Inc.,
+## 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+##
+## As a special exception, if other files instantiate templates or use macros
+## or inline functions from this file, or you compile this file and link it
+## with other works to produce a work based on this file, this file does not
+## by itself cause the resulting work to be covered by the GNU General Public
+## License. However the source code for this file must still be made available
+## in accordance with section (3) of the GNU General Public License.
+##
+## This exception does not invalidate any other reasons why a work based on
+## this file might be covered by the GNU General Public License.
+##
+## Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+## at http://sources.redhat.com/ecos/ecos-license/
+## -------------------------------------------
+#####ECOSGPLCOPYRIGHTEND####
+# ====================================================================
+######DESCRIPTIONBEGIN####
+#
+# Author(s):      gthomas
+# Original data:  gthomas
+# Contributors:
+# Date:           2000-07-26
+#
+#####DESCRIPTIONEND####
+#
+# ====================================================================
+
+cdl_package CYGPKG_DEVS_FLASH_IMX_3STACK_SPANSION {
+    display       "Freescale Spansion FLASH memory support"
+
+    parent        CYGPKG_IO_FLASH
+    active_if	  CYGPKG_IO_FLASH
+
+    implements    CYGHWR_IO_FLASH_DEVICE
+
+    compile       board_spansionflash.c
+
+    # Arguably this should do in the generic package
+    # but then there is a logic loop so you can never enable it.
+    cdl_interface CYGINT_DEVS_FLASH_AMD_AM29XXXXX_REQUIRED {
+        display   "Generic AMD FlashFile driver required"
+    }
+
+    implements    CYGINT_DEVS_FLASH_AMD_AM29XXXXX_REQUIRED
+
+    requires      CYGHWR_DEVS_FLASH_AMD_S29GL512N
+}
diff -urN -x CVS -x doc -x lwip_tcpip -x calmrisc16 -x calmrisc32 ecos_20050912/packages/devs/flash/arm/imx_3stack/current/src/board_spansionflash.c ecos_base/packages/devs/flash/arm/imx_3stack/current/src/board_spansionflash.c
--- ecos_20050912/packages/devs/flash/arm/imx_3stack/current/src/board_spansionflash.c	1969-12-31 18:00:00.000000000 -0600
+++ ecos_base/packages/devs/flash/arm/imx_3stack/current/src/board_spansionflash.c	2008-04-01 10:32:15.000000000 -0500
@@ -0,0 +1,73 @@
+//==========================================================================
+//
+//      board_spansionflash.c
+//
+//      Flash programming for AMD Flash devices
+//
+//==========================================================================
+//####ECOSGPLCOPYRIGHTBEGIN####
+// -------------------------------------------
+// This file is part of eCos, the Embedded Configurable Operating System.
+// Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+//
+// eCos is free software; you can redistribute it and/or modify it under
+// the terms of the GNU General Public License as published by the Free
+// Software Foundation; either version 2 or (at your option) any later version.
+//
+// eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with eCos; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+//
+// As a special exception, if other files instantiate templates or use macros
+// or inline functions from this file, or you compile this file and link it
+// with other works to produce a work based on this file, this file does not
+// by itself cause the resulting work to be covered by the GNU General Public
+// License. However the source code for this file must still be made available
+// in accordance with section (3) of the GNU General Public License.
+//
+// This exception does not invalidate any other reasons why a work based on
+// this file might be covered by the GNU General Public License.
+//
+// Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+// at http://sources.redhat.com/ecos/ecos-license/
+// -------------------------------------------
+//####ECOSGPLCOPYRIGHTEND####
+//==========================================================================
+//#####DESCRIPTIONBEGIN####
+//
+// Author(s):    Patrick Doyle <wpd@delcomsys.com>
+// Contributors: Patrick Doyle <wpd@delcomsys.com>
+// Date:         2002-11-26
+// Purpose:      
+// Description:  
+//              
+//####DESCRIPTIONEND####
+//
+//==========================================================================
+
+#include <cyg/hal/hal_soc.h>
+
+//--------------------------------------------------------------------------
+// Device properties
+
+// We use the one SPANSION S29WS256N part on the EVB.
+#define CYGNUM_FLASH_INTERLEAVE (1)
+#define CYGNUM_FLASH_SERIES     (1)
+#define CYGNUM_FLASH_WIDTH      (16)
+#define CYGNUM_FLASH_BASE       (CS0_BASE_ADDR)
+
+#define CYGNUM_FLASH_TIMEOUT_QUERY 5000000
+#define CYGNUM_FLASH_TIMEOUT_ERASE_TIMER	100000000
+#define CYGNUM_FLASH_TIMEOUT_ERASE_COMPLETE	100000000
+#define CYGNUM_FLASH_TIMEOUT_PROGRAM		100000000
+//--------------------------------------------------------------------------
+// Platform specific extras
+
+//--------------------------------------------------------------------------
+// Now include the driver code.
+#include "cyg/io/flash_am29xxxxx.inl"
diff -urN -x CVS -x doc -x lwip_tcpip -x calmrisc16 -x calmrisc32 ecos_20050912/packages/devs/flash/arm/mx35evb/current/cdl/flash_board_spansion.cdl ecos_base/packages/devs/flash/arm/mx35evb/current/cdl/flash_board_spansion.cdl
--- ecos_20050912/packages/devs/flash/arm/mx35evb/current/cdl/flash_board_spansion.cdl	1969-12-31 18:00:00.000000000 -0600
+++ ecos_base/packages/devs/flash/arm/mx35evb/current/cdl/flash_board_spansion.cdl	2008-02-26 00:44:41.000000000 -0600
@@ -0,0 +1,71 @@
+# ====================================================================
+#
+#      flash_board_spansion.cdl
+#
+#      FLASH memory - Hardware support
+#
+# ====================================================================
+#####ECOSGPLCOPYRIGHTBEGIN####
+## -------------------------------------------
+## This file is part of eCos, the Embedded Configurable Operating System.
+## Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+##
+## eCos is free software; you can redistribute it and/or modify it under
+## the terms of the GNU General Public License as published by the Free
+## Software Foundation; either version 2 or (at your option) any later version.
+##
+## eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+## WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+## for more details.
+##
+## You should have received a copy of the GNU General Public License along
+## with eCos; if not, write to the Free Software Foundation, Inc.,
+## 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+##
+## As a special exception, if other files instantiate templates or use macros
+## or inline functions from this file, or you compile this file and link it
+## with other works to produce a work based on this file, this file does not
+## by itself cause the resulting work to be covered by the GNU General Public
+## License. However the source code for this file must still be made available
+## in accordance with section (3) of the GNU General Public License.
+##
+## This exception does not invalidate any other reasons why a work based on
+## this file might be covered by the GNU General Public License.
+##
+## Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+## at http://sources.redhat.com/ecos/ecos-license/
+## -------------------------------------------
+#####ECOSGPLCOPYRIGHTEND####
+# ====================================================================
+######DESCRIPTIONBEGIN####
+#
+# Author(s):      gthomas
+# Original data:  gthomas
+# Contributors:
+# Date:           2000-07-26
+#
+#####DESCRIPTIONEND####
+#
+# ====================================================================
+
+cdl_package CYGPKG_DEVS_FLASH_MX35EVB_SPANSION {
+    display       "Freescale Spansion FLASH memory support"
+
+    parent        CYGPKG_IO_FLASH
+    active_if	  CYGPKG_IO_FLASH
+
+    implements    CYGHWR_IO_FLASH_DEVICE
+
+    compile       board_spansionflash.c
+
+    # Arguably this should do in the generic package
+    # but then there is a logic loop so you can never enable it.
+    cdl_interface CYGINT_DEVS_FLASH_AMD_AM29XXXXX_REQUIRED {
+        display   "Generic AMD FlashFile driver required"
+    }
+
+    implements    CYGINT_DEVS_FLASH_AMD_AM29XXXXX_REQUIRED
+
+    requires      CYGHWR_DEVS_FLASH_S29WS256N
+}
diff -urN -x CVS -x doc -x lwip_tcpip -x calmrisc16 -x calmrisc32 ecos_20050912/packages/devs/flash/arm/mx35evb/current/cdl/flash_board_strata.cdl ecos_base/packages/devs/flash/arm/mx35evb/current/cdl/flash_board_strata.cdl
--- ecos_20050912/packages/devs/flash/arm/mx35evb/current/cdl/flash_board_strata.cdl	1969-12-31 18:00:00.000000000 -0600
+++ ecos_base/packages/devs/flash/arm/mx35evb/current/cdl/flash_board_strata.cdl	2008-02-26 00:44:41.000000000 -0600
@@ -0,0 +1,80 @@
+# ====================================================================
+#
+#      flash_board_strata.cdl
+#
+#      FLASH memory - Hardware support
+#
+# ====================================================================
+#####ECOSGPLCOPYRIGHTBEGIN####
+## -------------------------------------------
+## This file is part of eCos, the Embedded Configurable Operating System.
+## Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+##
+## eCos is free software; you can redistribute it and/or modify it under
+## the terms of the GNU General Public License as published by the Free
+## Software Foundation; either version 2 or (at your option) any later version.
+##
+## eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+## WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+## for more details.
+##
+## You should have received a copy of the GNU General Public License along
+## with eCos; if not, write to the Free Software Foundation, Inc.,
+## 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+##
+## As a special exception, if other files instantiate templates or use macros
+## or inline functions from this file, or you compile this file and link it
+## with other works to produce a work based on this file, this file does not
+## by itself cause the resulting work to be covered by the GNU General Public
+## License. However the source code for this file must still be made available
+## in accordance with section (3) of the GNU General Public License.
+##
+## This exception does not invalidate any other reasons why a work based on
+## this file might be covered by the GNU General Public License.
+##
+## Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+## at http://sources.redhat.com/ecos/ecos-license/
+## -------------------------------------------
+#####ECOSGPLCOPYRIGHTEND####
+# ====================================================================
+######DESCRIPTIONBEGIN####
+#
+# Author(s):      gthomas
+# Original data:  gthomas
+# Contributors:
+# Date:           2000-07-26
+#
+#####DESCRIPTIONEND####
+#
+# ====================================================================
+
+cdl_package CYGPKG_DEVS_FLASH_MX35EVB_STRATA {
+    display       "Freescale FLASH memory support"
+
+    parent        CYGPKG_IO_FLASH
+    active_if	  CYGPKG_IO_FLASH
+
+    requires      CYGPKG_DEVS_FLASH_STRATA
+    requires      CYGNUM_DEVS_FLASH_STRATA_MAX_BLOCKS == 256
+
+    implements    CYGHWR_IO_FLASH_BLOCK_LOCKING
+
+    include_dir   cyg/io
+
+    # Arguably this should do in the generic package
+    # but then there is a logic loop so you can never enable it.
+    cdl_interface CYGINT_DEVS_FLASH_STRATA_REQUIRED {
+        display   "Generic StrataFLASH driver required"
+    }
+
+    implements    CYGINT_DEVS_FLASH_STRATA_REQUIRED
+
+    define_proc {
+        puts $::cdl_system_header "/***** strataflash driver proc output start *****/"
+        puts $::cdl_system_header "#define CYGDAT_DEVS_FLASH_STRATA_INL <cyg/io/board_strataflash.inl>"
+        puts $::cdl_system_header "#define CYGDAT_DEVS_FLASH_STRATA_CFG <pkgconf/devs_flash_board_strata.h>"
+        puts $::cdl_system_header "/*****  strataflash driver proc output end  *****/"
+    }
+}
+
diff -urN -x CVS -x doc -x lwip_tcpip -x calmrisc16 -x calmrisc32 ecos_20050912/packages/devs/flash/arm/mx35evb/current/include/board_strataflash.inl ecos_base/packages/devs/flash/arm/mx35evb/current/include/board_strataflash.inl
--- ecos_20050912/packages/devs/flash/arm/mx35evb/current/include/board_strataflash.inl	1969-12-31 18:00:00.000000000 -0600
+++ ecos_base/packages/devs/flash/arm/mx35evb/current/include/board_strataflash.inl	2008-02-26 00:44:41.000000000 -0600
@@ -0,0 +1,64 @@
+#ifndef CYGONCE_DEVS_FLASH_BOARD_STRATAFLASH_INL
+#define CYGONCE_DEVS_FLASH_BOARD_STRATAFLASH_INL
+//==========================================================================
+//
+//      board_strataflash.inl
+//
+//      Flash programming - device constants, etc.
+//
+//==========================================================================
+//####ECOSGPLCOPYRIGHTBEGIN####
+// -------------------------------------------
+// This file is part of eCos, the Embedded Configurable Operating System.
+// Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+//
+// eCos is free software; you can redistribute it and/or modify it under
+// the terms of the GNU General Public License as published by the Free
+// Software Foundation; either version 2 or (at your option) any later version.
+//
+// eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with eCos; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+//
+// As a special exception, if other files instantiate templates or use macros
+// or inline functions from this file, or you compile this file and link it
+// with other works to produce a work based on this file, this file does not
+// by itself cause the resulting work to be covered by the GNU General Public
+// License. However the source code for this file must still be made available
+// in accordance with section (3) of the GNU General Public License.
+//
+// This exception does not invalidate any other reasons why a work based on
+// this file might be covered by the GNU General Public License.
+//
+// Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+// at http://sources.redhat.com/ecos/ecos-license/
+// -------------------------------------------
+//####ECOSGPLCOPYRIGHTEND####
+//==========================================================================
+//#####DESCRIPTIONBEGIN####
+//
+// Author(s):    gthomas, hmt
+// Contributors: gthomas
+// Date:         2001-02-24
+// Purpose:      
+// Description:  
+//              
+//####DESCRIPTIONEND####
+//
+//==========================================================================
+
+// The system has one 16-bit devices.
+// a StrataFlash 28F256L18. The 256 means 256Mbit, so 32Mbyte with 16bit width.
+
+#define CYGNUM_FLASH_DEVICES 	(1)
+#define CYGNUM_FLASH_BASE 	(0xA0000000u)
+#define CYGNUM_FLASH_BASE_MASK  (0xFE000000u) // 32MB devices (size=0x02000000 -> mask=0xFE000000)
+#define CYGNUM_FLASH_WIDTH 	(16)
+#define CYGNUM_FLASH_BLANK      (1)
+
+#endif  // CYGONCE_DEVS_FLASH_BOARD_STRATAFLASH_INL
\ No newline at end of file
diff -urN -x CVS -x doc -x lwip_tcpip -x calmrisc16 -x calmrisc32 ecos_20050912/packages/devs/flash/arm/mx35evb/current/src/board_spansionflash.c ecos_base/packages/devs/flash/arm/mx35evb/current/src/board_spansionflash.c
--- ecos_20050912/packages/devs/flash/arm/mx35evb/current/src/board_spansionflash.c	1969-12-31 18:00:00.000000000 -0600
+++ ecos_base/packages/devs/flash/arm/mx35evb/current/src/board_spansionflash.c	2008-02-26 00:44:42.000000000 -0600
@@ -0,0 +1,73 @@
+//==========================================================================
+//
+//      board_spansionflash.c
+//
+//      Flash programming for AMD Flash devices
+//
+//==========================================================================
+//####ECOSGPLCOPYRIGHTBEGIN####
+// -------------------------------------------
+// This file is part of eCos, the Embedded Configurable Operating System.
+// Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+//
+// eCos is free software; you can redistribute it and/or modify it under
+// the terms of the GNU General Public License as published by the Free
+// Software Foundation; either version 2 or (at your option) any later version.
+//
+// eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with eCos; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+//
+// As a special exception, if other files instantiate templates or use macros
+// or inline functions from this file, or you compile this file and link it
+// with other works to produce a work based on this file, this file does not
+// by itself cause the resulting work to be covered by the GNU General Public
+// License. However the source code for this file must still be made available
+// in accordance with section (3) of the GNU General Public License.
+//
+// This exception does not invalidate any other reasons why a work based on
+// this file might be covered by the GNU General Public License.
+//
+// Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+// at http://sources.redhat.com/ecos/ecos-license/
+// -------------------------------------------
+//####ECOSGPLCOPYRIGHTEND####
+//==========================================================================
+//#####DESCRIPTIONBEGIN####
+//
+// Author(s):    Patrick Doyle <wpd@delcomsys.com>
+// Contributors: Patrick Doyle <wpd@delcomsys.com>
+// Date:         2002-11-26
+// Purpose:      
+// Description:  
+//              
+//####DESCRIPTIONEND####
+//
+//==========================================================================
+
+#include <cyg/hal/hal_soc.h>
+
+//--------------------------------------------------------------------------
+// Device properties
+
+// We use the one SPANSION S29WS256N part on the EVB.
+#define CYGNUM_FLASH_INTERLEAVE (1)
+#define CYGNUM_FLASH_SERIES     (1)
+#define CYGNUM_FLASH_WIDTH      (16)
+#define CYGNUM_FLASH_BASE       (CS0_BASE_ADDR)
+
+#define CYGNUM_FLASH_TIMEOUT_QUERY 5000000
+#define CYGNUM_FLASH_TIMEOUT_ERASE_TIMER	100000000
+#define CYGNUM_FLASH_TIMEOUT_ERASE_COMPLETE	100000000
+#define CYGNUM_FLASH_TIMEOUT_PROGRAM		100000000
+//--------------------------------------------------------------------------
+// Platform specific extras
+
+//--------------------------------------------------------------------------
+// Now include the driver code.
+#include "cyg/io/flash_am29xxxxx.inl"
diff -urN -x CVS -x doc -x lwip_tcpip -x calmrisc16 -x calmrisc32 ecos_20050912/packages/devs/flash/arm/mxc/current/cdl/mxc_flash_select.cdl ecos_base/packages/devs/flash/arm/mxc/current/cdl/mxc_flash_select.cdl
--- ecos_20050912/packages/devs/flash/arm/mxc/current/cdl/mxc_flash_select.cdl	1969-12-31 18:00:00.000000000 -0600
+++ ecos_base/packages/devs/flash/arm/mxc/current/cdl/mxc_flash_select.cdl	2006-02-05 23:06:34.000000000 -0600
@@ -0,0 +1,96 @@
+# ====================================================================
+#####ECOSGPLCOPYRIGHTBEGIN####
+## -------------------------------------------
+## This file is part of eCos, the Embedded Configurable Operating System.
+## Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+##
+## eCos is free software; you can redistribute it and/or modify it under
+## the terms of the GNU General Public License as published by the Free
+## Software Foundation; either version 2 or (at your option) any later version.
+##
+## eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+## WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+## for more details.
+##
+## You should have received a copy of the GNU General Public License along
+## with eCos; if not, write to the Free Software Foundation, Inc.,
+## 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+##
+## As a special exception, if other files instantiate templates or use macros
+## or inline functions from this file, or you compile this file and link it
+## with other works to produce a work based on this file, this file does not
+## by itself cause the resulting work to be covered by the GNU General Public
+## License. However the source code for this file must still be made available
+## in accordance with section (3) of the GNU General Public License.
+##
+## This exception does not invalidate any other reasons why a work based on
+## this file might be covered by the GNU General Public License.
+##
+## Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+## at http://sources.redhat.com/ecos/ecos-license/
+## -------------------------------------------
+#####ECOSGPLCOPYRIGHTEND####
+# ====================================================================
+######DESCRIPTIONBEGIN####
+#
+# Author(s):      gthomas
+# Original data:  gthomas
+# Contributors:
+# Date:           2000-07-26
+#
+#####DESCRIPTIONEND####
+#
+# ====================================================================
+
+cdl_package CYGPKG_DEVS_FLASH_ONMXC {
+    display       "Support FLASH memory on Freescale MXC platforms"
+
+    implements    CYGHWR_IO_FLASH_DEVICE
+    parent        CYGPKG_IO_FLASH
+    active_if	  CYGPKG_IO_FLASH
+
+    include_dir   cyg/io
+
+    cdl_option CYGHWR_DEVS_FLASH_MXC_NOR {
+        display       "MXC platform NOR flash memory support"
+        default_value 0
+        description   "
+            When this option is enabled, it indicates NOR flash is 
+            supported on the MXC platforms"
+        define_proc {
+            puts $::cdl_system_header "#define MXCFLASH_SELECT_NOR"
+        }
+    }
+    cdl_option CYGHWR_DEVS_FLASH_MXC_NAND {
+        display       "MXC platform NAND flash memory support"
+        default_value 0
+        requires      { CYGSEM_IO_FLASH_READ_INDIRECT == 1 }
+        description   "
+            When this option is enabled, it indicates NAND flash is 
+            supported on the MXC platforms"
+        define_proc {
+            puts $::cdl_system_header "#define MXCFLASH_SELECT_NAND"
+        }
+        compile       mxc_nfc.c
+    }
+    cdl_option CYGHWR_DEVS_FLASH_MXC_MULTI {
+        display       "MXC platform multi flash memory support"
+        default_value 1
+        active_if     {CYGHWR_DEVS_FLASH_MXC_NAND && CYGHWR_DEVS_FLASH_MXC_NOR}
+        description   "
+            When this option is enabled, it indicates multi flashes are 
+            supported on the MXC platforms (like NAND and NOR)"
+        define_proc {
+            puts $::cdl_system_header "#define MXCFLASH_SELECT_MULTI"
+        }
+        compile       mxcflash_wrapper.c
+    }
+    cdl_interface CYGHWR_DEVS_FLASH_MXC_NAND_RESET_WORKAROUND {
+        display       "MXC platform NAND flash reset workaround support"
+        active_if     {CYGHWR_DEVS_FLASH_MXC_NAND}
+        description   "
+            When this option is enabled, it indicates 0xFFFF is used for
+            the NAND reset command instead of 0xFF."
+    }
+}
\ No newline at end of file
diff -urN -x CVS -x doc -x lwip_tcpip -x calmrisc16 -x calmrisc32 ecos_20050912/packages/devs/flash/arm/mxc/current/include/mxc_nand_parts.inl ecos_base/packages/devs/flash/arm/mxc/current/include/mxc_nand_parts.inl
--- ecos_20050912/packages/devs/flash/arm/mxc/current/include/mxc_nand_parts.inl	1969-12-31 18:00:00.000000000 -0600
+++ ecos_base/packages/devs/flash/arm/mxc/current/include/mxc_nand_parts.inl	2008-03-19 23:21:27.000000000 -0500
@@ -0,0 +1,340 @@
+#ifndef CYGONCE_DEVS_FLASH_MXC_NAND_PARTS_INL
+#define CYGONCE_DEVS_FLASH_MXC_NAND_PARTS_INL
+//==========================================================================
+//
+//      mxc_nfc.h
+//
+//      Flash programming to support NAND flash on Freescale MXC platforms
+//
+//==========================================================================
+//####ECOSGPLCOPYRIGHTBEGIN####
+// -------------------------------------------
+// This file is part of eCos, the Embedded Configurable Operating System.
+// Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+//
+// eCos is free software; you can redistribute it and/or modify it under
+// the terms of the GNU General Public License as published by the Free
+// Software Foundation; either version 2 or (at your option) any later version.
+//
+// eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with eCos; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+//
+// As a special exception, if other files instantiate templates or use macros
+// or inline functions from this file, or you compile this file and link it
+// with other works to produce a work based on this file, this file does not
+// by itself cause the resulting work to be covered by the GNU General Public
+// License. However the source code for this file must still be made available
+// in accordance with section (3) of the GNU General Public License.
+//
+// This exception does not invalidate any other reasons why a work based on
+// this file might be covered by the GNU General Public License.
+//
+// Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+// at http://sources.redhat.com/ecos/ecos-license/
+// -------------------------------------------
+//####ECOSGPLCOPYRIGHTEND####
+//==========================================================================
+//#####DESCRIPTIONBEGIN####
+//
+// Author(s):    Kevin Zhang <k.zhang@freescale.com>
+// Contributors: Kevin Zhang <k.zhang@freescale.com>
+// Date:         2006-01-23
+// Purpose:
+// Description:
+//
+//####DESCRIPTIONEND####
+//
+//==========================================================================
+
+    {
+        device_id  : 0x35ec, // Samsung K9F5608x0C (on EVB SDR memory card)
+        device_id2 : 0xFFFF,
+        device_id3 : 0xFFFF,
+        device_id4 : 0xFFFF,
+        page_size  : 512,
+        spare_size : 16,
+        pages_per_block : 32,
+        block_size : 0x4000,
+        block_count: 2048,
+        device_size: 0x2000000,
+        base_mask  : ~(0x2000000 - 1),
+        port_size  : MXC_NAND_8_BIT,
+        type       : NAND_SLC,
+        options    : NAND_BBT_SCAN1STPAGE | NAND_BBT_SCAN2NDPAGE,
+        fis_start_addr: 0x80000,       // first 0.5MB reserved for Redboot
+        bbt_blk_max_nr: 4,      // reserve 4 blocks for the bad block tables
+            // BI is fixed at 5th byte in the spare area. This value is not used
+        bi_off     : 0,
+        vendor_info: "Samsung K9F5608x0C 8-bit 512B page 32MB",
+    },
+    {
+        device_id  : 0x36ec, // Samsung K9F1208R0B (on MXC91131 EVB mem1)
+        device_id2 : 0xFFFF,
+        device_id3 : 0xFFFF,
+        device_id4 : 0xFFFF,
+        page_size  : 512,
+        spare_size : 16,
+        pages_per_block : 32,
+        block_size : 0x4000,
+        block_count: 4096,
+        device_size: 0x4000000,
+        base_mask  : ~(0x4000000 - 1),
+        port_size  : MXC_NAND_8_BIT,
+        type       : NAND_SLC,
+        options    : NAND_BBT_SCAN1STPAGE | NAND_BBT_SCAN2NDPAGE,
+        fis_start_addr: 0x80000,       // first 0.5MB reserved for Redboot
+        bbt_blk_max_nr: 4,      // reserve 4 blocks for the bad block tables
+            // BI is fixed at 5th byte in the spare area. This value is not used
+        bi_off     : 0,
+        vendor_info: "Samsung K9F1208R0B 8-bit 512B page 64MB",
+    },
+    {
+        device_id  : 0x76ec, // Samsung K9F1208x0B
+        device_id2 : 0xFFFF,
+        device_id3 : 0xFFFF,
+        device_id4 : 0xFFFF,
+        page_size  : 512,
+        spare_size : 16,
+        pages_per_block : 32,
+        block_size : 0x4000,
+        block_count: 4096,
+        device_size: 0x4000000,
+        base_mask  : ~(0x4000000 - 1),
+        port_size  : MXC_NAND_8_BIT,
+        type       : NAND_SLC,
+        options    : NAND_BBT_SCAN1STPAGE | NAND_BBT_SCAN2NDPAGE,
+        fis_start_addr: 0x80000,       // first 0.5MB reserved for Redboot
+        bbt_blk_max_nr: 4,      // reserve 4 blocks for the bad block tables
+            // BI is fixed at 5th byte in the spare area. This value is not used
+        bi_off     : 0,
+        vendor_info: "Samsung K9F1208x0B 8-bit 512B page 64MB",
+    },
+    {
+        device_id  : 0x79ec, // Samsung K9K1G08x0B (MX31 ADS 512B page 8 bit)
+        device_id2 : 0xFFFF,
+        device_id3 : 0xFFFF,
+        device_id4 : 0xFFFF,
+        page_size  : 512,
+        spare_size : 16,
+        pages_per_block : 32,
+        block_size : 0x4000,
+        block_count: 4096 * 2,
+        device_size: 0x4000000 * 2,
+        base_mask  : ~(0x4000000 * 2 - 1),
+        port_size  : MXC_NAND_8_BIT,
+        type       : NAND_SLC,
+        options    : NAND_BBT_SCAN1STPAGE | NAND_BBT_SCAN2NDPAGE,
+        fis_start_addr: 0x80000,       // first 0.5MB reserved for Redboot
+        bbt_blk_max_nr: 4,      // reserve 4 blocks for the bad block tables
+            // BI is fixed at 5th byte in the spare area. This value is not used
+        bi_off     : 0,
+        vendor_info: "Samsung K9K1G08x0B 8-bit 512B page 128MB",
+    },
+    {
+        device_id  : 0xf1ec, // Samsung K9F1G08U0A (MX31 ADS 2KB page 8 bit nand)
+        device_id2 : 0xFFFF,
+        device_id3 : 0xFFFF,
+        device_id4 : 0xFFFF,
+        page_size  : 512*4,
+        spare_size : 16*4,
+        pages_per_block : 64,
+        block_size : 64*2*1024,
+        block_count: 1024,
+        device_size: 128*1024*1024, // 128MB device =0x08000000
+        port_size  : MXC_NAND_8_BIT,
+        base_mask  : ~(0x08000000 - 1),
+        type       : NAND_SLC,
+        options    : NAND_BBT_SCAN1STPAGE | NAND_BBT_SCAN2NDPAGE,
+        fis_start_addr: 0x80000,       // first 0.5MB reserved for Redboot
+        bbt_blk_max_nr: 4,      // reserve 4 blocks for the bad block tables
+            // BI is at 4096th byte out of factory (0-indexed)
+            // our NFC read out data like this:
+            // | 528 | 528 | 528 | 528 | 528 | 528 | 528 | 528 |
+            //    P1      P2       P3         P4       P5        P6        P7        P8
+            // |0-527|528-1055/1056-1583/1584-2111/2112-2639/2640-3167/3168-3695/3696-4223 |
+            // So the last subpage starts: 3696th byte. 4096th byte is at offset 400.
+        bi_off     : 7 * 512 + 400,
+        vendor_info: "Samsung K9F1G08U0A 8-bit 2K page 128MB",
+    },
+    {
+        device_id  : 0xa1ec, // Samsung K9F1G08R0A (2KB page 8 bit nand)
+        device_id2 : 0xFFFF,
+        device_id3 : 0xFFFF,
+        device_id4 : 0xFFFF,
+        page_size  : 512*4,
+        spare_size : 16*4,
+        pages_per_block : 64,
+        block_size : 64*2*1024,
+        block_count: 1024,
+        device_size: 0x08000000, // 128MB device =0x08000000
+        port_size  : MXC_NAND_8_BIT,
+        base_mask  : ~(0x08000000 - 1),
+        type       : NAND_SLC,
+        fis_start_addr: 0x80000,       // first 0.5MB reserved for Redboot
+        bbt_blk_max_nr: 4,      // reserve 4 blocks for the bad block tables
+            // BI is at 2048th byte out of factory (0-indexed)
+            // our NFC read out data like this:
+            // | 528 | 528 | 528 | 528 |
+            //    P1      P2       P3         P4
+            // 0-527|528-1055/1056-1583/1584-2111
+            // So the last subpage starts: 1584th byte. 2048th byte is at offset 464.
+        bi_off     : 3 * 512 + 464, // BUF3 offset + 464
+        options    : NAND_BBT_SCAN1STPAGE | NAND_BBT_SCAN2NDPAGE,
+        vendor_info: "Samsung K9F1G08R0A 8-bit 2K page 128MB",
+    },
+    {
+        device_id  : 0xaaec, // Samsung K9F2G08R0A (2KB page 8 bit nand)
+        device_id2 : 0xFFFF,
+        device_id3 : 0xFFFF,
+        device_id4 : 0xFFFF,
+        page_size  : 512*4,
+        spare_size : 16*4,
+        pages_per_block : 64,
+        block_size : 64*2*1024,
+        block_count: 2048,
+        device_size: 0x10000000, // 256MB device =0x10000000
+        port_size  : MXC_NAND_8_BIT,
+        base_mask  : ~(0x10000000 - 1),
+        type       : NAND_SLC,
+        fis_start_addr: 0x80000,       // first 0.5MB reserved for Redboot
+        bbt_blk_max_nr: 4,      // reserve 4 blocks for the bad block tables
+            // BI is at 2048th byte out of factory (0-indexed)
+            // our NFC read out data like this:
+            // | 528 | 528 | 528 | 528 |
+            //    P1      P2       P3         P4
+            // 0-527|528-1055/1056-1583/1584-2111
+            // So the last subpage starts: 1584th byte. 2048th byte is at offset 464.
+        bi_off     : 3 * 512 + 464, // BUF3 offset + 464
+        options    : NAND_BBT_SCAN1STPAGE | NAND_BBT_SCAN2NDPAGE,
+        vendor_info: "Samsung K9F2G08R0A 8-bit 2K page 256MB",
+    },
+    {
+        device_id  : 0xd5ec, // Samsung K9LAG08U0M (2KB page 2G x 8 bit MLC nand)
+        device_id2 : 0x2555,
+        device_id3 : 0xFFFF,
+        device_id4 : 0xFFFF,
+        page_size  : 512*4,
+        spare_size : 16*4,
+        pages_per_block : 128,
+        block_size : 128*2*1024,
+        block_count: 8192,
+        device_size: 0x80000000, // 2GB device =0x8000,0000
+        port_size  : MXC_NAND_8_BIT,
+        base_mask  : ~(0x80000000 - 1),
+        type       : NAND_MLC,
+        fis_start_addr: 0x80000,       // first 0.5MB reserved for Redboot
+        bbt_blk_max_nr: 4,      // reserve 4 blocks for the bad block tables
+            // BI is at 2048th byte out of factory (0-indexed)
+            // our NFC read out data like this:
+            // | 528 | 528 | 528 | 528 |
+            //    P1      P2       P3         P4
+            // 0-527|528-1055/1056-1583/1584-2111
+            // So the last subpage starts: 1584th byte. 2048th byte is at offset 464.
+        bi_off     : 3 * 512 + 464, // BUF3 offset + 464
+        options    : NAND_BBT_SCANLSTPAGE,
+        vendor_info: "Samsung K9LAG08U0M 8-bit 2K page 2GB MLC",
+    },
+    {
+        device_id  : 0xd5ec,
+        device_id2 : 0xb614,
+        device_id3 : 0xec74,
+        device_id4 : 0xFFFF,
+        page_size  : 512*4,
+        spare_size : 16*4,
+        pages_per_block : 128,
+        block_size : 128*2*1024,
+        block_count: 8192,
+        device_size: 0x80000000, // 2GB device =0x8000,0000
+        port_size  : MXC_NAND_8_BIT,
+        base_mask  : ~(0x80000000 - 1),
+        type       : NAND_MLC,
+        vendor_info: "Samsung K9HCG08U5M 8-bit 2K page 8GB Quad MLC",
+    },
+    {
+        device_id  : 0xd7ec,
+        device_id2 : 0xb655,
+        device_id3 : 0xec78,
+        device_id4 : 0xFFFF,
+        page_size  : 512*8,
+//        row_cycle  : 3,
+        spare_size : 16*8,
+        pages_per_block : 128,
+        block_size : 128*4*1024,
+        block_count: 8192 / 2,  // for now
+        device_size: 0x80000000, // only 2GB supported
+        base_mask  : ~(0x80000000 - 1),
+        port_size  : MXC_NAND_8_BIT,
+        type       : NAND_MLC,
+        options    : NAND_BBT_SCANLSTPAGE,
+        fis_start_addr: 0x100000,       // first 1MB reserved for Redboot
+        bbt_blk_max_nr: 4,      // reserve 4 blocks for the bad block tables
+            // BI is at 4096th byte out of factory (0-indexed)
+            // our NFC read out data like this:
+            // | 528 | 528 | 528 | 528 | 528 | 528 | 528 | 528 |
+            //    P1      P2       P3         P4       P5        P6        P7        P8
+            // |0-527|528-1055/1056-1583/1584-2111/2112-2639/2640-3167/3168-3695/3696-4223 |
+            // So the last subpage starts: 3696th byte. 4096th byte is at offset 400.
+        bi_off     : 7 * 512 + 400,
+        vendor_info: "Samsung K9LBG08U0M 8-bit 4K page 4GB MLC. Only 2GB supported.",
+    },
+    {
+        device_id  : 0xD5AD, // Hynix HY27UV08BG5M 8-bit 2K page ?? GB MLC nand
+        device_id2 : 0xA555,
+        device_id3 : 0xAD68,
+        page_size  : 512*4,
+        spare_size : 16*4,
+        pages_per_block : 128,
+        block_size : 128*2*1024,
+        block_count: 2*2* 2048,
+        device_size: 0x80000000, // 2GB device
+        port_size  : MXC_NAND_8_BIT,
+        base_mask  : ~(0x80000000 - 1),
+        type       : NAND_MLC,
+        vendor_info: "Hynix HY27UV08BG5M 8-bit 2K page ?? GB MLC nand",
+    },
+    {
+        device_id  : 0xAD, // Hynix HYD0SQH0MF3(P) 16-bit 2K page 128MB (1Gb) MLC nand
+        device_id2 : 0xB1,
+        device_id3 : 0x80,
+        device_id4 : 0x55,
+        page_size  : 512*4,
+        spare_size : 16*4,
+        pages_per_block : 64,
+        block_size : 64*2*1024,
+        block_count: 1024,
+        device_size: 0x08000000, // 128MB device =0x0800,0000
+        port_size  : MXC_NAND_16_BIT,
+        base_mask  : ~(0x08000000 - 1),
+        type       : NAND_MLC,
+        vendor_info: "Hynix HYD0SQH0MF3(P) 16-bit 2K page 128MB MLC nand",
+    },
+    {
+        // Micron 29F32G08TAA 8-bit 2K page 4GB (32Gb) nand
+        // Even though it is 4GB device, so far we only use 2GB. Will work on it more
+        // once we have the schematic for this MX32 3DS board with Wolfson
+        // Note: this device doesn't work for NAND boot since it requires a
+        //       "reset" command issued to the NAND flash which is missing
+        //       from our NFC controller on i.MX31/32 and earlier.
+        device_id  : 0xD52C,
+        device_id2 : 0xA5D5,
+        device_id3 : 0xFFFF,
+        device_id4 : 0xFFFF,
+        page_size  : 512*4,
+        spare_size : 16*4,
+        pages_per_block : 128,
+        block_size : 128*2*1024,
+        block_count: 2 * 2 * 2048,
+        device_size: 0x80000000, // 2GB device
+        port_size  : MXC_NAND_8_BIT,
+        base_mask  : ~(0x80000000 - 1),
+        type       : NAND_MLC,
+        vendor_info: "Micron 29F32G08TAA 16-bit 2K page 4GB (32Gb) nand",
+    },
+
+#endif // CYGONCE_DEVS_FLASH_MXC_NAND_PARTS_INL
diff -urN -x CVS -x doc -x lwip_tcpip -x calmrisc16 -x calmrisc32 ecos_20050912/packages/devs/flash/arm/mxc/current/include/mxc_nand_specifics.h ecos_base/packages/devs/flash/arm/mxc/current/include/mxc_nand_specifics.h
--- ecos_20050912/packages/devs/flash/arm/mxc/current/include/mxc_nand_specifics.h	1969-12-31 18:00:00.000000000 -0600
+++ ecos_base/packages/devs/flash/arm/mxc/current/include/mxc_nand_specifics.h	2007-07-10 13:35:10.000000000 -0500
@@ -0,0 +1,61 @@
+#ifndef CYGONCE_DEVS_FLASH_MXC_NAND_SPECIFICS_H
+#define CYGONCE_DEVS_FLASH_MXC_NAND_SPECIFICS_H
+//==========================================================================
+//
+//      mxc_nand_specifics.h
+//
+//      Flash programming to support NAND flash on Freescale MXC platforms
+//
+//==========================================================================
+//####ECOSGPLCOPYRIGHTBEGIN####
+// -------------------------------------------
+// This file is part of eCos, the Embedded Configurable Operating System.
+// Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+//
+// eCos is free software; you can redistribute it and/or modify it under
+// the terms of the GNU General Public License as published by the Free
+// Software Foundation; either version 2 or (at your option) any later version.
+//
+// eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with eCos; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+//
+// As a special exception, if other files instantiate templates or use macros
+// or inline functions from this file, or you compile this file and link it
+// with other works to produce a work based on this file, this file does not
+// by itself cause the resulting work to be covered by the GNU General Public
+// License. However the source code for this file must still be made available
+// in accordance with section (3) of the GNU General Public License.
+//
+// This exception does not invalidate any other reasons why a work based on
+// this file might be covered by the GNU General Public License.
+//
+// Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+// at http://sources.redhat.com/ecos/ecos-license/
+// -------------------------------------------
+//####ECOSGPLCOPYRIGHTEND####
+//==========================================================================
+//#####DESCRIPTIONBEGIN####
+//
+// Author(s):    Kevin Zhang <k.zhang@freescale.com>
+// Contributors: Kevin Zhang <k.zhang@freescale.com>
+// Date:         2006-01-23
+// Purpose:      
+// Description:  
+//              
+//####DESCRIPTIONEND####
+//
+//==========================================================================
+
+#define CYGNUM_FLASH_INTERLEAVE         1
+#define CYGNUM_FLASH_SERIES             1
+#define CYGNUM_FLASH_WIDTH              8
+#define CYGNUM_FLASH_BASE               0
+#define CYGNUM_FLASH_BLANK              1
+
+#endif // CYGONCE_DEVS_FLASH_MXC_NAND_SPECIFICS_H
diff -urN -x CVS -x doc -x lwip_tcpip -x calmrisc16 -x calmrisc32 ecos_20050912/packages/devs/flash/arm/mxc/current/include/mxc_nfc.h ecos_base/packages/devs/flash/arm/mxc/current/include/mxc_nfc.h
--- ecos_20050912/packages/devs/flash/arm/mxc/current/include/mxc_nfc.h	1969-12-31 18:00:00.000000000 -0600
+++ ecos_base/packages/devs/flash/arm/mxc/current/include/mxc_nfc.h	2008-04-03 21:53:14.000000000 -0500
@@ -0,0 +1,333 @@
+#ifndef _MXC_NFC_H_
+#define _MXC_NFC_H_
+//==========================================================================
+//
+//      mxc_nfc.h
+//
+//      Flash programming to support NAND flash on Freescale MXC platforms
+//
+//==========================================================================
+//####ECOSGPLCOPYRIGHTBEGIN####
+// -------------------------------------------
+// This file is part of eCos, the Embedded Configurable Operating System.
+// Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+//
+// eCos is free software; you can redistribute it and/or modify it under
+// the terms of the GNU General Public License as published by the Free
+// Software Foundation; either version 2 or (at your option) any later version.
+//
+// eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with eCos; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+//
+// As a special exception, if other files instantiate templates or use macros
+// or inline functions from this file, or you compile this file and link it
+// with other works to produce a work based on this file, this file does not
+// by itself cause the resulting work to be covered by the GNU General Public
+// License. However the source code for this file must still be made available
+// in accordance with section (3) of the GNU General Public License.
+//
+// This exception does not invalidate any other reasons why a work based on
+// this file might be covered by the GNU General Public License.
+//
+// Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+// at http://sources.redhat.com/ecos/ecos-license/
+// -------------------------------------------
+//####ECOSGPLCOPYRIGHTEND####
+//==========================================================================
+//#####DESCRIPTIONBEGIN####
+//
+// Author(s):    Kevin Zhang <k.zhang@freescale.com>
+// Contributors: Kevin Zhang <k.zhang@freescale.com>
+// Date:         2006-01-23
+// Purpose:
+// Description:
+//
+//####DESCRIPTIONEND####
+//
+//==========================================================================
+
+#include <pkgconf/devs_flash_onmxc.h>
+#include "mxc_nand_specifics.h"
+
+#define NFC_DEBUG_MIN   1
+#define NFC_DEBUG_MED   2
+#define NFC_DEBUG_MAX   3
+#define NFC_DEBUG_DEF   NFC_DEBUG_MED
+
+#if defined(NFC_V1_1)
+#define PG_2K_DATA_OP_MULTI_CYCLES()        false
+#else
+#define PG_2K_DATA_OP_MULTI_CYCLES()        true
+#endif
+
+extern int _mxc_boot;
+typedef unsigned short u16;
+typedef unsigned int u32;
+typedef unsigned char u8;
+
+#define ADDR_INPUT_SIZE                 8
+//----------------------------------------------------------------------------
+// Common device details.
+#define FLASH_Read_ID                   (0x90)
+#if CYGHWR_DEVS_FLASH_MXC_NAND_RESET_WORKAROUND
+#define FLASH_Reset                     0xFFFF
+#else
+#define FLASH_Reset                     (0xFF)
+#endif
+#define FLASH_Read_Mode1                (0x00)
+#define FLASH_Read_Mode1_LG             (0x30)
+#define FLASH_Read_Mode2                (0x01)
+#define FLASH_Read_Mode3                (0x50)
+#define FLASH_Program                   (0x10)
+#define FLASH_Send_Data                 (0x80)
+#define FLASH_Status                    (0x70)
+#define FLASH_Block_Erase               (0x60)
+#define FLASH_Start_Erase               (0xD0)
+
+#define NAND_MAIN_BUF0                  (NFC_BASE + 0x000)
+#define NAND_MAIN_BUF1                  (NFC_BASE + 0x200)
+#define NAND_MAIN_BUF2                  (NFC_BASE + 0x400)
+#define NAND_MAIN_BUF3                  (NFC_BASE + 0x600)
+#if defined(NFC_V1_1)
+#define NAND_MAIN_BUF4                  (NFC_BASE + 0x800)
+#define NAND_MAIN_BUF5                  (NFC_BASE + 0xA00)
+#define NAND_MAIN_BUF6                  (NFC_BASE + 0xC00)
+#define NAND_MAIN_BUF7                  (NFC_BASE + 0xE00)
+#define NAND_SPAR_BUF0                  (NFC_BASE + 0x1000)
+#define NAND_SPAR_BUF1                  (NFC_BASE + 0x1040)
+#define NAND_SPAR_BUF2                  (NFC_BASE + 0x1080)
+#define NAND_SPAR_BUF3                  (NFC_BASE + 0x10C0)
+#define NAND_SPAR_BUF4                  (NFC_BASE + 0x1100)
+#define NAND_SPAR_BUF5                  (NFC_BASE + 0x1140)
+#define NAND_SPAR_BUF6                  (NFC_BASE + 0x1180)
+#define NAND_SPAR_BUF7                  (NFC_BASE + 0x11C0)
+#else 
+#define NAND_SPAR_BUF0                  (NFC_BASE + 0x800)
+#define NAND_SPAR_BUF1                  (NFC_BASE + 0x810)
+#define NAND_SPAR_BUF2                  (NFC_BASE + 0x820)
+#define NAND_SPAR_BUF3                  (NFC_BASE + 0x830)
+#define NAND_RESERVED                   (NFC_BASE + 0x840)
+#endif
+
+#define NFC_BUFSIZE_REG                 (NAND_REG_BASE + 0x00)
+#define RAM_BUFFER_ADDRESS_REG          (NAND_REG_BASE + 0x04)
+#define NAND_FLASH_ADD_REG              (NAND_REG_BASE + 0x06)
+#define NAND_FLASH_CMD_REG              (NAND_REG_BASE + 0x08)
+#define NFC_CONFIGURATION_REG           (NAND_REG_BASE + 0x0A)
+#define ECC_STATUS_RESULT_REG           (NAND_REG_BASE + 0x0C)
+#define ECC_RSLT_MAIN_AREA_REG          (NAND_REG_BASE + 0x0E)
+#define ECC_RSLT_SPARE_AREA_REG         (NAND_REG_BASE + 0x10)
+#define NF_WR_PROT_REG                  (NAND_REG_BASE + 0x12)
+#define NAND_FLASH_WR_PR_ST_REG         (NAND_REG_BASE + 0x18)
+#define NAND_FLASH_CONFIG1_REG          (NAND_REG_BASE + 0x1A)
+#define NAND_FLASH_CONFIG2_REG          (NAND_REG_BASE + 0x1C)
+#if defined(NFC_V1_1)
+#define UNLOCK_START_BLK_ADD_REG        (NAND_REG_BASE + 0x20)
+#define UNLOCK_END_BLK_ADD_REG          (NAND_REG_BASE + 0x22)
+#define UNLOCK_START_BLK_ADD1_REG       (NAND_REG_BASE + 0x24)
+#define UNLOCK_END_BLK_ADD1_REG         (NAND_REG_BASE + 0x26)
+#define UNLOCK_START_BLK_ADD2_REG       (NAND_REG_BASE + 0x28)
+#define UNLOCK_END_BLK_ADD2_REG         (NAND_REG_BASE + 0x2A)
+#define UNLOCK_START_BLK_ADD3_REG       (NAND_REG_BASE + 0x2C)
+#define UNLOCK_END_BLK_ADD3_REG         (NAND_REG_BASE + 0x2E)
+#else
+#define UNLOCK_START_BLK_ADD_REG        (NAND_REG_BASE + 0x14)
+#define UNLOCK_END_BLK_ADD_REG          (NAND_REG_BASE + 0x16)
+#endif
+
+enum nfc_internal_buf {
+    RAM_BUF_0,
+    RAM_BUF_1,
+    RAM_BUF_2,
+    RAM_BUF_3,
+    RAM_BUF_4,
+    RAM_BUF_5,
+    RAM_BUF_6,
+    RAM_BUF_7,
+};
+
+enum nfc_output_mode {
+    FDO_PAGE_SPARE      = 0x0008,
+    FDO_SPARE_ONLY      = 0x1008,  // LSB has to be 0x08
+    FDO_FLASH_ID        = 0x0010,
+    FDO_FLASH_STATUS    = 0x0020,
+};
+
+/*!
+ * Defined the "complete" address input operations which may involve
+ * more than one cycle of single address input operation.
+ */
+enum nfc_addr_ops {
+    ADDRESS_INPUT_READ_ID,
+    ADDRESS_INPUT_READ_PAGE,
+    ADDRESS_INPUT_PROGRAM_PAGE,
+    ADDRESS_INPUT_ERASE_BLOCK,
+};
+
+enum nfc_page_area {
+    NFC_SPARE_ONLY,
+    NFC_MAIN_ONLY,
+};
+
+enum {
+    MXC_NAND_8_BIT = 8,
+    MXC_NAND_16_BIT =  16,
+};
+
+enum {
+    NAND_SLC = 0,
+    NAND_MLC = 1,
+};
+
+// read column 464-465 byte but only 464 for bad block marker
+#define BAD_BLK_MARKER_464          (NAND_MAIN_BUF3 + 464)
+// read column 4-5 byte, but only 5 is used for swapped main area data
+#define BAD_BLK_MARKER_SP_5         (NAND_SPAR_BUF3 + 4)
+
+// Polls the NANDFC to wait for an operation to complete
+#define wait_op_done()                                                              \
+    do {                                                                            \
+        volatile int mxc_nfc_wait_loop;                                                      \
+        while ((readw(NAND_FLASH_CONFIG2_REG) & NAND_FLASH_CONFIG2_INT_DONE) == 0)  \
+            {for (mxc_nfc_wait_loop = 0; mxc_nfc_wait_loop < 100; mxc_nfc_wait_loop++);} \
+    } while (0)
+
+/*!
+ * NAND flash data output operation (reading data from NAND flash)
+ * @param buf_no    internal ram buffer number that will contain data
+ *                  to be outputted from the NAND flash after operation done
+ * @param mode      one of the mode defined in enum nfc_output_mode
+ */
+static void NFC_DATA_OUTPUT(enum nfc_internal_buf buf_no, enum nfc_output_mode mode,
+                            int ecc_en)
+{
+    u16 config1 = (ecc_en != 0) ? NAND_FLASH_CONFIG1_ECC_EN : 0;
+
+    config1 |= readw(NAND_FLASH_CONFIG1_REG);
+
+    if (mode == FDO_SPARE_ONLY) {
+        config1 |= NAND_FLASH_CONFIG1_SP_EN;
+    }
+
+    writew(config1, NAND_FLASH_CONFIG1_REG);
+    writew(buf_no, RAM_BUFFER_ADDRESS_REG);
+    writew(mode & 0xFF, NAND_FLASH_CONFIG2_REG);
+    wait_op_done();
+}
+
+static void NFC_CMD_INPUT(u32 cmd)
+{
+    writew(cmd, NAND_FLASH_CMD_REG);
+    writew(NAND_FLASH_CONFIG2_FCMD_EN, NAND_FLASH_CONFIG2_REG);
+    wait_op_done();
+}
+
+static u16 NFC_STATUS_READ(void)
+{
+    u16 flash_status;
+    u16 saved = readw(NAND_MAIN_BUF0);
+
+    NFC_CMD_INPUT(FLASH_Status);
+    NFC_DATA_OUTPUT(RAM_BUF_0, FDO_FLASH_STATUS, 1);
+    flash_status = readw(NAND_MAIN_BUF0) & 0x00FF;
+
+    // restore
+    writew(saved, NAND_MAIN_BUF0);
+
+    return flash_status;
+}
+
+/*!
+ * NAND flash data input operation (writing data to NAND flash)
+ * @param buf_no    internal ram buffer number containing data to be
+ *                  written into the NAND flash
+ * @param area      NFC_SPARE_ONLY or NFC_MAIN_ONLY,
+ * @param ecc_en    1 - ecc enabled; 0 - ecc disabled
+ */
+static void NFC_DATA_INPUT(enum nfc_internal_buf buf_no, enum nfc_page_area area,
+                           int ecc_en)
+{
+    u16 config1 = (ecc_en != 0) ? NAND_FLASH_CONFIG1_ECC_EN : 0;
+
+    config1 |= readw(NAND_FLASH_CONFIG1_REG);
+
+    if (area == NFC_SPARE_ONLY) {
+        config1 |= NAND_FLASH_CONFIG1_SP_EN;
+#ifdef CYGPKG_HAL_ARM_MXC91221
+        config1 &= ~NAND_FLASH_CONFIG1_ECC_EN;
+#endif
+    }
+
+    writew(config1, NAND_FLASH_CONFIG1_REG);
+    writew(buf_no, RAM_BUFFER_ADDRESS_REG);
+
+    // start operation
+    writew(NAND_FLASH_CONFIG2_FDI_EN, NAND_FLASH_CONFIG2_REG);
+    wait_op_done();
+}
+
+static void NFC_DATA_INPUT_2k(enum nfc_internal_buf buf_no)
+{
+    writew(buf_no, RAM_BUFFER_ADDRESS_REG);
+    writew(NAND_FLASH_CONFIG2_FDI_EN, NAND_FLASH_CONFIG2_REG);
+    wait_op_done();
+}
+
+/*!
+ * The NFC has to be preset before performing any operation
+ */
+static void NFC_PRESET(u32 max_block_count)
+{
+    // Unlock the internal RAM buffer
+    writew(NFC_CONFIGURATION_UNLOCKED, NFC_CONFIGURATION_REG);
+    // First Block to be unlocked
+    writew(0, UNLOCK_START_BLK_ADD_REG);
+    // Last Unlock Block
+    writew(max_block_count, UNLOCK_END_BLK_ADD_REG);
+    // Unlock Block Command
+    writew(NF_WR_PROT_UNLOCK, NF_WR_PROT_REG);
+}
+
+/*!
+ * Issue the address input operation
+ * @param       addr    the address for the address input operation
+ */
+static void NFC_ADDR_INPUT(u32 addr)
+{
+    if (nfc_debug) {
+        diag_printf("add = 0x%x, at 0x%x\n",
+                    addr & ((1 << ADDR_INPUT_SIZE) - 1), NAND_FLASH_ADD_REG);
+        diag_printf("NAND_FLASH_CONFIG2_REG=%x\n", NAND_FLASH_CONFIG2_REG);
+    }
+    writew(addr & ((1 << ADDR_INPUT_SIZE) - 1), NAND_FLASH_ADD_REG);
+    writew(NAND_FLASH_CONFIG2_FADD_EN, NAND_FLASH_CONFIG2_REG);
+    wait_op_done();
+}
+
+#if defined(NFC_V1_1)
+#define NFC_ARCH_INIT()		\
+		{		\
+			unsigned int tmp, reg;	\
+			tmp = flash_dev_info->page_size / 512; \
+			if(flash_dev_info->spare_size) {\
+				writew((flash_dev_info->spare_size>>1), \
+						ECC_RSLT_SPARE_AREA_REG);\
+			}	\
+			writew(0x2, NFC_CONFIGURATION_REG);\
+			reg = readw(NAND_FLASH_CONFIG1_REG)| 0x800; \
+			if((flash_dev_info->spare_size / tmp) > 16) \
+				reg &= ~1;	\
+			else 	\
+				reg |= 1; \
+			writew(reg, NAND_FLASH_CONFIG1_REG); \
+		}
+#else
+#define NFC_ARCH_INIT()
+#endif /*NFC_V1_1*/
+#endif // _MXC_NFC_H_
diff -urN -x CVS -x doc -x lwip_tcpip -x calmrisc16 -x calmrisc32 ecos_20050912/packages/devs/flash/arm/mxc/current/include/mxc_nfc_v2.h ecos_base/packages/devs/flash/arm/mxc/current/include/mxc_nfc_v2.h
--- ecos_20050912/packages/devs/flash/arm/mxc/current/include/mxc_nfc_v2.h	1969-12-31 18:00:00.000000000 -0600
+++ ecos_base/packages/devs/flash/arm/mxc/current/include/mxc_nfc_v2.h	2008-04-03 21:53:14.000000000 -0500
@@ -0,0 +1,314 @@
+#ifndef _MXC_NFC_V2_H_
+#define _MXC_NFC_V2_H_
+//==========================================================================
+//
+//      mxc_nfc_v2.h
+//
+//      Flash programming to support NAND flash on Freescale MXC platforms
+//
+//==========================================================================
+//####ECOSGPLCOPYRIGHTBEGIN####
+// -------------------------------------------
+// This file is part of eCos, the Embedded Configurable Operating System.
+// Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+//
+// eCos is free software; you can redistribute it and/or modify it under
+// the terms of the GNU General Public License as published by the Free
+// Software Foundation; either version 2 or (at your option) any later version.
+//
+// eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with eCos; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+//
+// As a special exception, if other files instantiate templates or use macros
+// or inline functions from this file, or you compile this file and link it
+// with other works to produce a work based on this file, this file does not
+// by itself cause the resulting work to be covered by the GNU General Public
+// License. However the source code for this file must still be made available
+// in accordance with section (3) of the GNU General Public License.
+//
+// This exception does not invalidate any other reasons why a work based on
+// this file might be covered by the GNU General Public License.
+//
+// Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+// at http://sources.redhat.com/ecos/ecos-license/
+// -------------------------------------------
+//####ECOSGPLCOPYRIGHTEND####
+//==========================================================================
+//#####DESCRIPTIONBEGIN####
+//
+// Author(s):    Kevin Zhang <k.zhang@freescale.com>
+// Contributors: Kevin Zhang <k.zhang@freescale.com>
+// Date:         2006-01-23
+// Purpose:
+// Description:
+//
+//####DESCRIPTIONEND####
+//
+//==========================================================================
+
+#include <pkgconf/devs_flash_onmxc.h>
+#include "mxc_nand_specifics.h"
+
+#define NFC_DEBUG_MIN   1
+#define NFC_DEBUG_MED   2
+#define NFC_DEBUG_MAX   3
+#define NFC_DEBUG_DEF   NFC_DEBUG_MED
+
+#define PG_2K_DATA_OP_MULTI_CYCLES()        false
+extern int _mxc_boot;
+typedef unsigned short u16;
+typedef unsigned int u32;
+typedef unsigned char u8;
+
+#define ADDR_INPUT_SIZE                 8
+//----------------------------------------------------------------------------
+// Common device details.
+#define FLASH_Read_ID                   (0x90)
+#if CYGHWR_DEVS_FLASH_MXC_NAND_RESET_WORKAROUND
+#define FLASH_Reset                     0xFFFF
+#else
+#define FLASH_Reset                     (0xFF)
+#endif
+#define FLASH_Read_Mode1                (0x00)
+#define FLASH_Read_Mode1_LG             (0x30)
+#define FLASH_Read_Mode2                (0x01)
+#define FLASH_Read_Mode3                (0x50)
+#define FLASH_Program                   (0x10)
+#define FLASH_Send_Data                 (0x80)
+#define FLASH_Status                    (0x70)
+#define FLASH_Block_Erase               (0x60)
+#define FLASH_Start_Erase               (0xD0)
+
+#define NAND_MAIN_BUF0                  (NFC_BASE + 0x000)
+#define NAND_MAIN_BUF1                  (NFC_BASE + 0x200)
+#define NAND_MAIN_BUF2                  (NFC_BASE + 0x400)
+#define NAND_MAIN_BUF3                  (NFC_BASE + 0x600)
+#if defined (NFC_V2_0)
+#define NAND_SPAR_BUF0                  (NFC_BASE + 0x800)
+#define NAND_SPAR_BUF1                  (NFC_BASE + 0x810)
+#define NAND_SPAR_BUF2                  (NFC_BASE + 0x820)
+#define NAND_SPAR_BUF3                  (NFC_BASE + 0x830)
+#define NAND_RESERVED                   (NFC_BASE + 0x840)
+#elif defined (NFC_V2_1)
+#define NAND_MAIN_BUF4                  (NFC_BASE + 0x800)
+#define NAND_MAIN_BUF5                  (NFC_BASE + 0xA00)
+#define NAND_MAIN_BUF6                  (NFC_BASE + 0xC00)
+#define NAND_MAIN_BUF7                  (NFC_BASE + 0xE00)
+#define NAND_SPAR_BUF0                  (NFC_BASE + 0x1000)
+#define NAND_SPAR_BUF1                  (NFC_BASE + 0x1040)
+#define NAND_SPAR_BUF2                  (NFC_BASE + 0x1080)
+#define NAND_SPAR_BUF3                  (NFC_BASE + 0x10C0)
+#define NAND_SPAR_BUF4                  (NFC_BASE + 0x1100)
+#define NAND_SPAR_BUF5                  (NFC_BASE + 0x1140)
+#define NAND_SPAR_BUF6                  (NFC_BASE + 0x1180)
+#define NAND_SPAR_BUF7                  (NFC_BASE + 0x11C0)
+#else
+#error NOT supported
+#endif
+
+#define ECC_STATUS_RESULT_REG           (NAND_REG_BASE + 0x08)
+
+enum nfc_internal_buf {
+    RAM_BUF_0 = 0x0 << 4,
+    RAM_BUF_1 = 0x1 << 4,
+    RAM_BUF_2 = 0x2 << 4,
+    RAM_BUF_3 = 0x3 << 4,
+    RAM_BUF_4 = 0x4 << 4,
+    RAM_BUF_5 = 0x5 << 4,
+    RAM_BUF_6 = 0x6 << 4,
+    RAM_BUF_7 = 0x7 << 4,
+};
+
+enum nfc_output_mode {
+    FDO_PAGE_SPARE      = 0x0008,
+    FDO_SPARE_ONLY      = 0x1008,  // LSB has to be 0x08
+    FDO_FLASH_ID        = 0x0010,
+    FDO_FLASH_STATUS    = 0x0020,
+};
+
+/*!
+ * Defined the "complete" address input operations which may involve
+ * more than one cycle of single address input operation.
+ */
+enum nfc_addr_ops {
+    ADDRESS_INPUT_READ_ID,
+    ADDRESS_INPUT_READ_PAGE,
+    ADDRESS_INPUT_PROGRAM_PAGE,
+    ADDRESS_INPUT_ERASE_BLOCK,
+};
+
+enum nfc_page_area {
+    NFC_SPARE_ONLY,
+    NFC_MAIN_ONLY,
+};
+
+enum {
+    MXC_NAND_8_BIT = 8,
+    MXC_NAND_16_BIT =  16,
+};
+
+enum {
+    NAND_SLC = 0,
+    NAND_MLC = 1,
+};
+
+// read column 464-465 byte but only 464 for bad block marker
+#define BAD_BLK_MARKER_464          (NAND_MAIN_BUF3 + 464)
+// read column 4-5 byte, but only 5 is used for swapped main area data
+#define BAD_BLK_MARKER_SP_5         (NAND_SPAR_BUF3 + 4)
+
+// Polls the NANDFC to wait for an operation to complete
+#define wait_op_done()                                                              \
+    do {                                                                            \
+        while ((readl(NFC_IPC_REG) & NFC_IPC_INT) == 0)  \
+            {} \
+        write_nfc_ip_reg(0, NFC_IPC_REG); \
+    } while (0)
+
+static void write_nfc_ip_reg(u32 val, u32 reg)
+{
+    writel(NFC_IPC_CREQ, NFC_IPC_REG);
+    while((readl(NFC_IPC_REG) & NFC_IPC_CACK) == 0);
+
+    writel(val, reg);
+    writel(0, NFC_IPC_REG);
+}
+
+/*!
+ * NAND flash data output operation (reading data from NAND flash)
+ * @param buf_no    internal ram buffer number that will contain data
+ *                  to be outputted from the NAND flash after operation done
+ * @param mode      one of the mode defined in enum nfc_output_mode
+ * @param ecc_en    1 - ecc enabled; 0 - ecc disabled
+ */
+static void NFC_DATA_OUTPUT(enum nfc_internal_buf buf_no, enum nfc_output_mode mode,
+                            int ecc_en)
+{
+    u32 v = readl(NFC_FLASH_CONFIG2_REG);
+
+    if ((v & NFC_FLASH_CONFIG2_ECC_EN) != 0 && ecc_en == 0) {
+        write_nfc_ip_reg(v & ~NFC_FLASH_CONFIG2_ECC_EN, NFC_FLASH_CONFIG2_REG);
+    }
+    if ((v & NFC_FLASH_CONFIG2_ECC_EN) == 0 && ecc_en != 0) {
+        write_nfc_ip_reg(v | NFC_FLASH_CONFIG2_ECC_EN, NFC_FLASH_CONFIG2_REG);
+    }
+
+    v = readl(NAND_CONFIGURATION1_REG);
+
+    if (mode == FDO_SPARE_ONLY) {
+        v = (v & ~0x31) | buf_no | NAND_CONFIGURATION1_SP_EN;
+    } else {
+        v = (v & ~0x31) | buf_no;
+    }
+
+    writel(v, NAND_CONFIGURATION1_REG);
+
+    writel(mode & 0xFF, NAND_LAUNCH_REG);
+    wait_op_done();
+}
+
+static void NFC_CMD_INPUT(u32 cmd)
+{
+    writel(cmd & 0xFFFF, NAND_ADD_CMD_REG);
+    writel(NAND_LAUNCH_FCMD, NAND_LAUNCH_REG);
+    wait_op_done();
+}
+
+static u16 NFC_STATUS_READ(void)
+{
+    u16 flash_status;
+    u16 saved = readw(NAND_MAIN_BUF0);
+
+    NFC_CMD_INPUT(FLASH_Status);
+    NFC_DATA_OUTPUT(RAM_BUF_0, FDO_FLASH_STATUS, 1);
+    flash_status = readw(NAND_MAIN_BUF0) & 0x00FF;
+
+    // restore
+    writew(saved, NAND_MAIN_BUF0);
+
+    return flash_status;
+}
+
+/*!
+ * NAND flash data input operation (writing data to NAND flash)
+ * @param buf_no    internal ram buffer number containing data to be
+ *                  written into the NAND flash
+ * @param area      NFC_SPARE_ONLY or NFC_MAIN_ONLY,
+ * @param ecc_en    1 - ecc enabled; 0 - ecc disabled
+ */
+static void NFC_DATA_INPUT(enum nfc_internal_buf buf_no, enum nfc_page_area area,
+                           int ecc_en)
+{
+    u32 v = readl(NFC_FLASH_CONFIG2_REG);
+
+    // setup config2 register for ECC enable or not
+    if ((v & NFC_FLASH_CONFIG2_ECC_EN) != 0 && ecc_en == 0) {
+        write_nfc_ip_reg(v & ~NFC_FLASH_CONFIG2_ECC_EN, NFC_FLASH_CONFIG2_REG);
+    }
+    if ((v & NFC_FLASH_CONFIG2_ECC_EN) == 0 && ecc_en != 0) {
+        write_nfc_ip_reg(v | NFC_FLASH_CONFIG2_ECC_EN, NFC_FLASH_CONFIG2_REG);
+    }
+
+    // setup config1 register for ram buffer number, spare-only or not
+    v = readl(NAND_CONFIGURATION1_REG);
+
+    if (area == NFC_SPARE_ONLY) {
+        v = (v & ~0x31) | buf_no | NAND_CONFIGURATION1_SP_EN;
+    } else {
+        v = (v & ~0x31) | buf_no;
+    }
+
+    writel(v, NAND_CONFIGURATION1_REG);
+
+    // start operation
+    writel(NAND_LAUNCH_FDI, NAND_LAUNCH_REG);
+    wait_op_done();
+}
+
+static void NFC_DATA_INPUT_2k(enum nfc_internal_buf buf_no)
+{
+    u32 v;
+
+    // setup config1 register for ram buffer number, spare-only or not
+    v = readl(NAND_CONFIGURATION1_REG);
+    v = (v & ~0x30) | buf_no;
+    writel(v, NAND_CONFIGURATION1_REG);
+
+    // start operation
+    writel(NAND_LAUNCH_FDI, NAND_LAUNCH_REG);
+    wait_op_done();
+}
+
+/*!
+ * The NFC has to be preset before performing any operation
+ */
+static void NFC_PRESET(u32 max_block_count)
+{
+    // not needed. It is done in plf_hardware_init()
+}
+
+/*!
+ * Issue the address input operation
+ * @param       addr    the address for the address input operation
+ */
+static void NFC_ADDR_INPUT(u32 addr)
+{
+    if (nfc_debug) {
+        diag_printf("add = 0x%x, at 0x%x\n",
+                    (addr & ((1 << ADDR_INPUT_SIZE) - 1)) << 16, NAND_ADD_CMD_REG);
+        diag_printf("NAND_LAUNCH_FADD=%x, NAND_LAUNCH_REG=%x\n", NAND_LAUNCH_FADD, NAND_LAUNCH_REG);
+    }
+    writel((addr & ((1 << ADDR_INPUT_SIZE) - 1)) << 16, NAND_ADD_CMD_REG);
+    writel(NAND_LAUNCH_FADD, NAND_LAUNCH_REG);
+    wait_op_done();
+}
+
+#define NFC_ARCH_INIT()
+
+#endif // _MXC_NFC_V2_H_
diff -urN -x CVS -x doc -x lwip_tcpip -x calmrisc16 -x calmrisc32 ecos_20050912/packages/devs/flash/arm/mxc/current/src/mxcflash_wrapper.c ecos_base/packages/devs/flash/arm/mxc/current/src/mxcflash_wrapper.c
--- ecos_20050912/packages/devs/flash/arm/mxc/current/src/mxcflash_wrapper.c	1969-12-31 18:00:00.000000000 -0600
+++ ecos_base/packages/devs/flash/arm/mxc/current/src/mxcflash_wrapper.c	2007-07-10 13:35:11.000000000 -0500
@@ -0,0 +1,180 @@
+//==========================================================================
+//
+//      mxcflash_wrapper.c
+//
+//      Flash programming wrapper to support both NOR and NAND flashes
+//
+//==========================================================================
+//####ECOSGPLCOPYRIGHTBEGIN####
+// -------------------------------------------
+// This file is part of eCos, the Embedded Configurable Operating System.
+// Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+//
+// eCos is free software; you can redistribute it and/or modify it under
+// the terms of the GNU General Public License as published by the Free
+// Software Foundation; either version 2 or (at your option) any later version.
+//
+// eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with eCos; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+//
+// As a special exception, if other files instantiate templates or use macros
+// or inline functions from this file, or you compile this file and link it
+// with other works to produce a work based on this file, this file does not
+// by itself cause the resulting work to be covered by the GNU General Public
+// License. However the source code for this file must still be made available
+// in accordance with section (3) of the GNU General Public License.
+//
+// This exception does not invalidate any other reasons why a work based on
+// this file might be covered by the GNU General Public License.
+//
+// Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+// at http://sources.redhat.com/ecos/ecos-license/
+// -------------------------------------------
+//####ECOSGPLCOPYRIGHTEND####
+//==========================================================================
+//#####DESCRIPTIONBEGIN####
+//
+// Author(s):    Kevin Zhang <k.zhang@freescale.com>
+// Contributors: Kevin Zhang <k.zhang@freescale.com>
+// Date:         2006-01-23
+// Purpose:      
+// Description:  
+//              
+//####DESCRIPTIONEND####
+//
+//==========================================================================
+
+#include <pkgconf/hal.h>
+#include <cyg/hal/hal_arch.h>
+#include <cyg/hal/hal_cache.h>
+#include <cyg/hal/hal_misc.h>
+#include <redboot.h>
+
+extern void norflash_query(void* data);
+extern int norflash_hwr_init(void);
+extern int norflash_hwr_map_error(int e);
+extern bool norflash_code_overlaps(void *start, void *end);
+extern int norflash_erase_block(void* block, unsigned int size);
+extern int norflash_program_buf(void* addr, void* data, int len);
+extern int norflash_lock_block(void* block);
+extern int norflash_unlock_block(void* block, int block_size, int blocks);
+
+extern void nandflash_query(void* data);
+extern int nandflash_hwr_init(void);
+extern int nandflash_hwr_map_error(int e);
+extern bool nandflash_code_overlaps(void *start, void *end);
+extern int nandflash_erase_block(void* block, unsigned int size);
+extern int nandflash_program_buf(void* addr, void* data, int len);
+extern int nandflash_lock_block(void* block);
+extern int nandflash_unlock_block(void* block, int block_size, int blocks);
+
+static int mxc_flash_warning_done = 0;
+
+void flash_query(void* data)
+{
+    if (IS_BOOTING_FROM_NOR() || IS_FIS_FROM_NOR()) {
+        norflash_query(data);
+    } else if (IS_BOOTING_FROM_NAND() || IS_FIS_FROM_NAND()) {
+        nandflash_query(data);
+    } else {
+        if (!mxc_flash_warning_done) {
+            mxc_flash_warning_done = 1;
+            diag_printf("1: Use \"factive [NOR|NAND]\" to select either NOR or NAND flash\n");
+        }
+    }
+}
+
+int flash_hwr_init(void)
+{
+    if (IS_BOOTING_FROM_NOR() || IS_FIS_FROM_NOR()) {
+        return norflash_hwr_init();
+    } else if (IS_BOOTING_FROM_NAND() || IS_FIS_FROM_NAND()) {
+        return nandflash_hwr_init();
+    } else {
+        if (!mxc_flash_warning_done)
+            mxc_flash_warning_done = 1;
+        diag_printf("2: Use \"factive [NOR|NAND]\" to select either NOR or NAND flash\n");
+        return -1;
+    }
+}
+
+int flash_hwr_map_error(int e)
+{
+    if (IS_BOOTING_FROM_NOR() || IS_FIS_FROM_NOR()) {
+        return norflash_hwr_map_error(e);
+    } else {
+        return nandflash_hwr_map_error(e);
+    }
+}
+
+bool flash_code_overlaps(void *start, void *end)
+{
+    if (IS_BOOTING_FROM_NOR() || IS_FIS_FROM_NOR()) {
+        return norflash_code_overlaps(start, end);
+    } else {
+        return nandflash_code_overlaps(start, end);
+    }
+}
+
+int flash_erase_block(void* block, unsigned int size)
+{
+    if (IS_BOOTING_FROM_NOR() || IS_FIS_FROM_NOR()) {
+        return norflash_erase_block(block, size);
+    } else {
+        return nandflash_erase_block(block, size);
+    }
+}
+
+int flash_program_buf(void* addr, void* data, int len)
+{
+    if (IS_BOOTING_FROM_NOR() || IS_FIS_FROM_NOR()) {
+        return norflash_program_buf(addr, data, len);
+    } else {
+        return nandflash_program_buf(addr, data, len);
+    }
+}
+
+int flash_lock_block(void* block)
+{
+    if (IS_BOOTING_FROM_NOR() || IS_FIS_FROM_NOR()) {
+        return norflash_lock_block(block);
+    } else {
+        return nandflash_lock_block(block);
+    }
+}
+
+int flash_unlock_block(void* block, int block_size, int blocks)
+{
+    if (IS_BOOTING_FROM_NOR() || IS_FIS_FROM_NOR()) {
+        return norflash_unlock_block(block, block_size, blocks);
+    } else {
+        return nandflash_unlock_block(block, block_size, blocks);
+    }
+}
+
+extern void mxc_nfc_print_info(void);
+
+static void mxc_flash_print_info(void)
+{
+    if (IS_BOOTING_FROM_NOR()) {
+        diag_printf("\nBooting from [NOR flash]\n");
+        MXC_ASSERT_NOR_BOOT();
+    } else if (IS_BOOTING_FROM_NAND()) {
+        diag_printf("\nBooting from [NAND flash]\n");
+        MXC_ASSERT_NAND_BOOT();
+        mxc_nfc_print_info();
+    } else if (IS_BOOTING_FROM_SDRAM()) {
+        diag_printf("\nBooting from [SDRAM]\n");
+    } else {
+        diag_printf("\n!!!Warning: Unknown boot source !!!\n");
+    }
+    diag_printf("\n");
+}
+
+RedBoot_init(mxc_flash_print_info, RedBoot_INIT_LAST);
diff -urN -x CVS -x doc -x lwip_tcpip -x calmrisc16 -x calmrisc32 ecos_20050912/packages/devs/flash/arm/mxc/current/src/mxc_nfc.c ecos_base/packages/devs/flash/arm/mxc/current/src/mxc_nfc.c
--- ecos_20050912/packages/devs/flash/arm/mxc/current/src/mxc_nfc.c	1969-12-31 18:00:00.000000000 -0600
+++ ecos_base/packages/devs/flash/arm/mxc/current/src/mxc_nfc.c	2008-04-03 22:06:30.000000000 -0500
@@ -0,0 +1,1797 @@
+//==========================================================================
+//
+//      mxc_nfc.c
+//
+//      Flash programming to support NAND flash on Freescale MXC platforms
+//
+//==========================================================================
+//####ECOSGPLCOPYRIGHTBEGIN####
+// -------------------------------------------
+// This file is part of eCos, the Embedded Configurable Operating System.
+// Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+//
+// eCos is free software; you can redistribute it and/or modify it under
+// the terms of the GNU General Public License as published by the Free
+// Software Foundation; either version 2 or (at your option) any later version.
+//
+// eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with eCos; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+//
+// As a special exception, if other files instantiate templates or use macros
+// or inline functions from this file, or you compile this file and link it
+// with other works to produce a work based on this file, this file does not
+// by itself cause the resulting work to be covered by the GNU General Public
+// License. However the source code for this file must still be made available
+// in accordance with section (3) of the GNU General Public License.
+//
+// This exception does not invalidate any other reasons why a work based on
+// this file might be covered by the GNU General Public License.
+//
+// Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+// at http://sources.redhat.com/ecos/ecos-license/
+// -------------------------------------------
+//####ECOSGPLCOPYRIGHTEND####
+//==========================================================================
+//#####DESCRIPTIONBEGIN####
+//
+// Author(s):    Kevin Zhang <k.zhang@freescale.com>
+// Contributors: Kevin Zhang <k.zhang@freescale.com>
+// Date:         2006-01-23 Initial version
+// Date:         2007-12-20 Update to support 4K page and bbt management.
+// Purpose:
+// Description:
+//   -- Add bad block management according to Linux NAND MTD implementation.
+//      Reference linux/drivers/mtd/nand/nand_bbt.c by Thomas Gleixner
+//      Summary:
+//         1. Last 4 blocks are reserved for one main BBT and one 
+//            mirror BBT (2 spare ones just in case a block turns bad.)
+//         2. The main BBT block's spare area starts with "Bbt0" followed
+//            by a version number starting from 1.
+//         3. The mirror BBT block's spare area starts with "1tbB" followed
+//            by a version number also starting from 1.
+//         4. The actual main area, starting from first page in the BBT block,
+//            is used to indicate if a block is bad or not through 2bit/block:
+//              * The table uses 2 bits per block
+//              * 11b: 	block is good
+//              * 00b: 	block is factory marked bad
+//              * 01b, 10b: 	block is marked bad due to wear
+//      Redboot operations: During boot, it searches for the marker for
+//                          either main BBT or mirror BBT based on the marker:
+//         case 1: Neither table is found:
+//                 Do the bad block scan of the whole flash with ECC off. Use
+//                 manufactor marked BI field to decide if a block is bad and
+//                 then build the BBT in RAM. Then write this table to both
+//                 main BBT block and mirror BBT block.
+//         case 2: Only one table is found:
+//                 Load the BBT table from the flash and stored in the RAM.
+//                 Then build the 2nd BBT table in the flash.
+//         case 3: If both tables found, load the one with higher version in the
+//                 RAM and then update the block with older BBT info with the 
+//                 newer one. If same version, just then read out the table in
+//                 RAM.
+//
+//####DESCRIPTIONEND####
+//
+//==========================================================================
+
+#include <pkgconf/hal.h>
+#include <cyg/hal/hal_arch.h>
+#include <cyg/hal/hal_cache.h>
+#include <redboot.h>
+#include <stdlib.h>
+static int nfc_debug = 0;
+
+#include CYGHWR_MEMORY_LAYOUT_H
+
+#include <cyg/hal/hal_io.h>
+#define  _FLASH_PRIVATE_
+#include <cyg/io/flash.h>
+
+#if defined(NFC_V2_0) || defined(NFC_V2_1)
+#include <cyg/io/mxc_nfc_v2.h>
+#else
+#include <cyg/io/mxc_nfc.h>
+#endif
+
+/* Search good / bad pattern on the first page only */
+#define NAND_BBT_SCAN1STPAGE    0x00000001
+/* Search good / bad pattern on the first and the second page */
+#define NAND_BBT_SCAN2NDPAGE	0x00000002
+/* Search good / bad pattern on the last page only */
+#define NAND_BBT_SCANLSTPAGE	0x00000004
+// todo: move to top
+#define ECC_FORCE_ON    1
+#define ECC_FORCE_OFF   2
+
+enum blk_bad_type
+{
+    BLK_BAD_FACTORY = 0,
+    BLK_BAD_RUNTIME = 1,
+};
+
+//#define diag_printf1    diag_printf
+#define diag_printf1(fmt,args...)
+#define MXC_UNLOCK_BLK_END      0xFFFF
+
+extern unsigned int hal_timer_count(void);
+int nfc_program_region(u32 addr, u32 buf, u32 len);
+int nfc_erase_region(u32 addr, u32 len, u32 skip_bad, bool verbose);
+
+static int nfc_write_pg_random(u32 adj_addr, u32 buf, enum nfc_page_area area,
+                               u32 ecc_force);
+static int nfc_read_pg_random(u32 adj_addr, u32 force);
+static int nfc_erase_blk(u32 ra);
+static void print_page (u32 addr, bool spare_only);
+static int nfc_read_page(u32 addr);
+static int nfc_read_page_sp(u32 addr);
+static int mxc_nfc_scan(bool lowlevel);
+static void read_nflash_id(void* id);
+static int nfc_program_blk(u32 ra, u32 buf, u32 len);
+
+// globals
+static int nand_flash_index = -1;
+static int g_ecc_enable = true;
+static int g_spare_only_read_ok = true;
+static int g_nfc_debug_level = NFC_DEBUG_MIN;
+static bool g_nfc_debug_measure = false;
+static bool g_is_2k_page = false;
+static bool g_is_4k_page = false;
+static unsigned int g_nfc_version = MXC_NFC_V1;
+
+#define nfc_printf(level, args...)          \
+    do {                                \
+        if (g_nfc_debug_level >= level)     \
+            diag_printf(args);          \
+    } while(0)
+
+#ifndef MXCFLASH_SELECT_MULTI
+void flash_query(void* data)
+#else
+void nandflash_query(void* data)
+#endif
+{
+    read_nflash_id(data);
+    nfc_printf(NFC_DEBUG_MAX, "%s(ID=0x%x: 0x%x, 0x%x, 0x%x)\n",
+               __FUNCTION__, *(u8*)(data), *(u8*)((u32)data+1),
+	       *(u8*)((u32)data+2), *(u8*)((u32)data+3));
+}
+
+#ifndef MXCFLASH_SELECT_MULTI
+int flash_program_buf(void* addr, void* data, int len)
+#else
+int nandflash_program_buf(void* addr, void* data, int len)
+#endif
+{
+    return nfc_program_region((u32) addr, (u32) data, (u32) len);
+}
+
+#ifndef MXCFLASH_SELECT_MULTI
+int flash_erase_block(void* block, unsigned int size)
+#else
+int nandflash_erase_block(void* block, unsigned int size)
+#endif
+{
+    return nfc_erase_region((u32) block, size, 1, 0);
+}
+
+#ifndef MXCFLASH_SELECT_MULTI
+bool flash_code_overlaps(void *start, void *end)
+#else
+bool nandflash_code_overlaps(void *start, void *end)
+#endif
+{
+    extern unsigned char _stext[], _etext[];
+
+    return ((((unsigned long)&_stext >= (unsigned long)start) &&
+             ((unsigned long)&_stext < (unsigned long)end)) ||
+            (((unsigned long)&_etext >= (unsigned long)start) &&
+             ((unsigned long)&_etext < (unsigned long)end)));
+}
+
+#ifndef MXCFLASH_SELECT_MULTI
+int flash_hwr_map_error(int e)
+#else
+int nandflash_hwr_map_error(int e)
+#endif
+{
+    return e;
+}
+
+#ifndef MXCFLASH_SELECT_MULTI
+int flash_lock_block(void* block)
+#else
+int nandflash_lock_block(void* block)
+#endif
+{
+    // Not supported yet
+    return 0;
+}
+
+#ifndef MXCFLASH_SELECT_MULTI
+int flash_unlock_block(void* block, int block_size, int blocks)
+#else
+int nandflash_unlock_block(void* block, int block_size, int blocks)
+#endif
+{
+    // Not supported yet
+    return 0;
+}
+
+//----------------------------------------------------------------------------
+// Now that device properties are defined, include magic for defining
+// accessor type and constants.
+#include <cyg/io/flash_dev.h>
+
+// Information about supported devices
+typedef struct flash_dev_info {
+    cyg_uint16   device_id;
+    cyg_uint16   device_id2;
+    cyg_uint16   device_id3;
+    cyg_uint16   device_id4;
+    cyg_uint16   page_size;
+    cyg_uint16   spare_size;
+    cyg_uint32   pages_per_block;
+    cyg_uint32   block_size;
+    cyg_int32    block_count;
+    cyg_uint32   base_mask;
+    cyg_uint32   device_size;
+    cyg_uint32   port_size;     // x8 or x16 IO
+    cyg_uint32   type;          // SLC vs MLC
+    cyg_uint32   options;
+    cyg_uint32   fis_start_addr;
+    cyg_uint32   bi_off;
+    cyg_uint32   bbt_blk_max_nr;
+    cyg_uint8    vendor_info[96];
+} flash_dev_info_t;
+
+static const flash_dev_info_t* flash_dev_info;
+static const flash_dev_info_t supported_devices[] = {
+#include <cyg/io/mxc_nand_parts.inl>
+};
+#define NUM_DEVICES (sizeof(supported_devices)/sizeof(flash_dev_info_t))
+
+#define NF_PG_SZ                    flash_dev_info->page_size
+#define NF_PG_PER_BLK               flash_dev_info->pages_per_block
+#define NF_DEV_SZ                   flash_dev_info->device_size
+#define NF_BLK_SZ                   flash_dev_info->block_size
+#define NF_BLK_CNT                  flash_dev_info->block_count
+#define NF_VEND_INFO                flash_dev_info->vendor_info
+#define NF_OPTIONS                  flash_dev_info->options
+#define NF_BBT_MAX_NR               flash_dev_info->bbt_blk_max_nr
+#define NF_OPTIONS                  flash_dev_info->options
+#define NF_BI_OFF                   flash_dev_info->bi_off
+
+#define NAND_PG_SHIFT               ((g_is_2k_page) ? 12 : ((g_is_4k_page) ? 13 : 9))
+#define NFC_ADJUST_ADDR(addr)       ((addr  / NF_PG_SZ) << NAND_PG_SHIFT)
+
+// Mask off the higher bits representing linear address of the nand flash
+#define MXC_NAND_LA_MASK            (NF_DEV_SZ - 1)
+
+#define NFC_DEVICE_ALIGN(a)         ((a) & MXC_NAND_LA_MASK & (~(NF_DEV_SZ - 1)))
+#define NFC_BLOCK_ALIGN(a)          ((a) & MXC_NAND_LA_MASK & (~(NF_BLK_SZ - 1)))
+#define NFC_PAGE_ALIGN(a)           ((a) & MXC_NAND_LA_MASK & (~(NF_PG_SZ - 1)))
+
+#define BLOCK_TO_OFFSET(blk)            (blk * NF_PG_PER_BLK * NF_PG_SZ)
+#define BLOCK_TO_PAGE(blk)              (blk * NF_PG_PER_BLK)
+#define BLOCK_PAGE_TO_OFFSET(blk, pge)  ((blk * NF_PG_PER_BLK + pge) * NF_PG_SZ)
+#define OFFSET_TO_BLOCK(offset)         ((offset / NF_PG_SZ) / NF_PG_PER_BLK)
+#define OFFSET_TO_PAGE(offset)          ((offset / NF_PG_SZ) % NF_PG_PER_BLK)
+
+static u8 *g_bbt, *g_page_buf;
+static u32 g_bbt_sz;
+static u32 g_main_bbt_addr = 0, g_mirror_bbt_page = 0;
+static u8 g_main_bbt_ver;
+//static u8 g_mirror_bbt_ver;
+static u8 g_main_bbt_des[] = "Bbt0";
+//static u8 g_mirror_bbt_des[] = "1tbB";
+static bool mxcnfc_init_ok = false;
+
+//mxc_nand_fixup_t nand_page_sz_2k_fixup;
+//mxc_nand_fixup_t nand_port_sz_x16_fixup;
+
+// this callback allows the platform specific function to be called right
+// after flash_dev_query()
+nfc_setup_func_t *nfc_setup = NULL;
+
+int
+#ifndef MXCFLASH_SELECT_MULTI
+flash_hwr_init(void)
+#else
+nandflash_hwr_init(void)
+#endif
+{
+    cyg_uint16 id[4];
+    int i;
+    nfc_printf(NFC_DEBUG_MAX, "%s()\n", __FUNCTION__);
+    NFC_CMD_INPUT(FLASH_Reset);
+
+    // Look through table for device data
+    flash_dev_info = supported_devices;
+    for (i = 0; i < NUM_DEVICES; i++) {
+        flash_dev_query(id);
+        if ((flash_dev_info->device_id == id[0]) &&
+            (flash_dev_info->device_id2 == 0xFFFF || flash_dev_info->device_id2 == id[1]))
+            break;
+        flash_dev_info++;
+    }
+
+    nfc_printf(NFC_DEBUG_MED, "%s(): %d out of NUM_DEVICES=%d, id=0x%x\n",
+               __FUNCTION__, i, (u32)NUM_DEVICES, flash_dev_info->device_id);
+
+    // Do we find the device? If not, return error.
+    if (NUM_DEVICES == i) {
+        diag_printf("Unrecognized NAND part: 0x%04x, 0x%04x, 0x%04x, 0x%04x\n",
+                    id[0], id[1], id[2], id[3]);
+        return FLASH_ERR_DRV_WRONG_PART;
+    }
+
+    if (NF_PG_SZ == 2048) {
+        g_is_2k_page = true;
+        g_spare_only_read_ok = false;
+    }
+    if (NF_PG_SZ == 4096) {
+        g_is_4k_page = true;
+        g_spare_only_read_ok = false;
+    }
+    if (nfc_setup) {
+        g_nfc_version = nfc_setup(NF_PG_SZ, flash_dev_info->port_size,
+                                  flash_dev_info->type);
+    }
+
+    NFC_ARCH_INIT();
+
+    nand_flash_index = i;
+    mxcnfc_init_ok = true;
+
+    g_bbt_sz = NF_BLK_CNT / 4;
+    g_bbt = (u8*)malloc(g_bbt_sz); // two bit for each block
+    if (g_bbt == NULL) {
+        diag_printf("%s(): malloc failed (%d)\n", __FUNCTION__, __LINE__);
+        return FLASH_ERR_PROTOCOL;
+    }
+
+    g_page_buf = (u8*)malloc(NF_PG_SZ); // for programming less than one page size buffer
+    if (g_page_buf == NULL) {
+        diag_printf("%s(): malloc failed (%d)\n", __FUNCTION__, __LINE__);
+        return FLASH_ERR_PROTOCOL;
+    }
+    memset(g_bbt, -1, g_bbt_sz);
+
+    // Hard wired for now
+    flash_info.block_size = NF_BLK_SZ;
+    flash_info.blocks = NF_BLK_CNT;
+    flash_info.start = (void *)0;
+    flash_info.end = (void *)NF_DEV_SZ;
+
+    diag_printf1("%s(g_bbt=%p)\n", __FUNCTION__, g_bbt);
+    mxc_nfc_scan(false); // look for table
+
+    diag_printf1("%s(): block_size=0x%x, blocks=0x%x, start=%p, end=%p\n",
+               __FUNCTION__, flash_info.block_size, flash_info.blocks,
+               flash_info.start, flash_info.end);
+
+    return FLASH_ERR_OK;
+}
+
+// used by redboot/current/src/flash.c
+int mxc_nand_fis_start(void)
+{
+    return flash_dev_info->fis_start_addr;
+}
+
+#define nfc_buf_mem_cpy     memcpy
+#ifndef nfc_buf_mem_cpy
+static void nfc_buf_mem_cpy(void *dst, void *src, u32 len)
+{
+    u16 *d = (u16*) dst, *s = (u16*) src;
+    if ((len & 1) != 0 || ((u32)dst & 1) != 0 || ((u32)src & 1) != 0) {
+        diag_printf("Error: len=0x%x, dst=%p, src=%p should be even number\n",
+                    len, dst, src);
+        return;
+    }
+    if (len == 0) {
+        return;
+    }
+    do {
+        *d++ = *s++;
+        len -= 2;
+    } while (len > 0);
+}
+#endif
+
+/*!
+ * Starts the address input cycles for different operations as defined in ops.
+ *
+ * @param ops           operations as defined in enum nfc_addr_ops
+ * @param adj_addr      starting address
+ * @param mask          mask for the full address range of the nand flash
+ *                      For 64MB flash, the mask should be 0x03FFFFFF (64MB-1)
+ * Note that the adj_addr argument is not linear address from user perspective,
+ * i.e. it is not the original passed-in value from user. It is the "adjusted"
+ * address from the the NAND flash perspective. The adjustment is done via
+ * NAND_PG_SHIFT. So don't call this function without massaging the address
+ * properly with NAND_PG_SHIFT.
+ */
+static void start_nfc_addr_ops(enum nfc_addr_ops ops, u32 adj_addr, u32 mask)
+{
+    u32 m = mask, a = adj_addr;
+
+    switch (ops) {
+    case ADDRESS_INPUT_READ_ID:
+        NFC_ADDR_INPUT(0);
+        return;
+    case ADDRESS_INPUT_READ_PAGE:
+    case ADDRESS_INPUT_PROGRAM_PAGE:
+        if (g_is_2k_page) {
+            NFC_ADDR_INPUT(a & 0xFF);
+            NFC_ADDR_INPUT((a >> 8) & 0xF);
+        } else if (g_is_4k_page) {
+            NFC_ADDR_INPUT(a & 0xFF);
+            NFC_ADDR_INPUT((a >> 8) & 0x1F);
+        } else {
+            NFC_ADDR_INPUT(a & 0xFF);
+        }
+        // don't break on purpose
+    case ADDRESS_INPUT_ERASE_BLOCK:
+        a >>= NAND_PG_SHIFT;
+        m >>= (g_is_2k_page ? 11 : (g_is_4k_page ? 12 : 9));
+        break;
+    default:
+        diag_printf("!!!!!! %s(): wrong ops: %d !!!!!\n", __FUNCTION__, ops);
+        return;
+    }
+
+    do {
+        NFC_ADDR_INPUT(a);
+        m >>= ADDR_INPUT_SIZE;
+        a >>= ADDR_INPUT_SIZE;
+    } while (m != 0);
+}
+
+static void read_nflash_id(void* id)
+{
+    volatile u32 *ptr = (u32*) NAND_MAIN_BUF0;
+    volatile u32 *id_32 = (u32*)id;
+
+    nfc_printf(NFC_DEBUG_MAX, "%s()\n", __FUNCTION__);
+    NFC_PRESET(MXC_UNLOCK_BLK_END);
+    NFC_CMD_INPUT(FLASH_Read_ID);
+    start_nfc_addr_ops(ADDRESS_INPUT_READ_ID, 0, 0);
+    NFC_DATA_OUTPUT(RAM_BUF_0, FDO_FLASH_ID, g_ecc_enable);
+
+    *id_32++ = *ptr++;
+    *id_32++ = *ptr++;
+}
+
+/*!
+ * Checks to see if a block is bad. If buf is not NULL, it indicates a valid
+ * BBT in the RAM. In this case, it assumes to have 2-bit to represent each 
+ * block for good or bad
+ *              * 11b: 	block is good
+ *              * 00b: 	block is factory marked bad
+ *              * 01b, 10b: 	block is marked bad due to wear
+ * If buf is NULL, then it indicates a low level scan based on the certain
+ * offset value in certain pages and certain offset to be non-0xFF. In this
+ * case, the HW ECC will be turned off.
+ *
+ * @param block     0-based block number
+ * @param buf       BBT buffer. Could be NULL (see above explanation)
+ *
+ * @return          1 if bad block; 0 otherwise
+ */
+static bool nfc_is_badblock(u32 block, u8 *buf)
+{
+    u32 off;       // byte offset
+    u32 sft;       // bit shift 0, 2, 4, 6
+    u32 addr;
+    u16 temp;
+    bool res = false;
+
+    if (buf) {
+        // use BBT
+        off = block >> 2;       // byte offset
+        sft = (block & 3) << 1;  // bit shift 0, 2, 4, 6
+        if (((buf[off] >> sft) & 0x3) != 0x3) {
+            res = true;
+        }
+        goto out;
+    }
+    // need to do low level scan with ECC off
+    if (NF_OPTIONS & NAND_BBT_SCAN1STPAGE) {
+        addr = block * NF_BLK_SZ; // TODO: overflow for over 4GB nand
+        nfc_read_pg_random(NFC_ADJUST_ADDR(addr), ECC_FORCE_OFF); // no ecc
+        if (g_is_2k_page || g_is_4k_page) {
+            temp = readw(NAND_MAIN_BUF0 + NF_BI_OFF);
+        } else {
+            temp = readw(NAND_SPAR_BUF0 + 4) >> 8; // BI is at 5th byte in spare area
+        }
+        if ((temp & 0xFF) != 0xFF)
+            res = true;
+    }
+    if (NF_OPTIONS & NAND_BBT_SCAN2NDPAGE) {
+        addr = block * NF_BLK_SZ + NF_PG_SZ; // TODO: overflow for over 4GB nand
+        nfc_read_pg_random(NFC_ADJUST_ADDR(addr), ECC_FORCE_OFF); // no ecc
+        if (g_is_2k_page || g_is_4k_page) {
+            temp = readw(NAND_MAIN_BUF0 + NF_BI_OFF);
+        } else {
+            temp = readw(NAND_SPAR_BUF0 + 4) >> 8; // BI is at 5th byte in spare area
+        }
+        if ((temp & 0xFF) != 0xFF)
+            res = true;
+    }
+    if (NF_OPTIONS & NAND_BBT_SCANLSTPAGE) {
+        if (g_is_4k_page || g_is_2k_page) {
+            // TODO: overflow for over 4GB nand
+            addr = (block + 1) * NF_BLK_SZ - NF_PG_SZ;
+            // we don't do partial page read here. No ecc either
+            nfc_read_pg_random(NFC_ADJUST_ADDR(addr), ECC_FORCE_OFF);
+            temp = readw((u32)NAND_MAIN_BUF0 + NF_BI_OFF);
+            if ((temp & 0xFF) != 0xFF)
+                res = true;
+        } else {
+            diag_printf("only 2K/4K page is supported\n");
+            // die here -- need to fix the SW
+            while (1);
+        }
+    }
+out:
+    return res;
+}
+
+/*
+ * Program g_bbt into the NAND block with offset at g_main_bbt_addr.
+ * This assumes that the g_bbt has been built already.
+ *
+ * If g_main_bbt_addr is 0, search for a free block from the bottom 4 blocks (but make
+ * sure not re-using the mirror block). If g_mirror_bbt_page is 0, do the same thing.
+ * Otherwise, just use g_main_bbt_addr, g_mirror_bbt_page numbers to prgram the 
+ * g_bbt into those two blocks.
+ * todo: need to do the version to see which one is newer.
+ * 
+ * @return  0 if successful; -1 otherwise.
+ */
+static int program_bbt_to_flash(void)
+{
+    int i = 0;
+    u32 addr, blk;
+
+    if (g_main_bbt_addr) {
+        // update the spare area before writing and version number
+        g_main_bbt_ver++;
+    } else {
+        // no existing main bbt table in flash, build one.
+        g_main_bbt_ver = 1; // first BBT version
+        for (i = 0; i < NF_BBT_MAX_NR; i++) {
+            blk = NF_BLK_CNT - i - 1;
+            addr = blk * NF_BLK_SZ;
+            if (g_mirror_bbt_page == addr || nfc_is_badblock(blk, g_bbt))
+                continue;
+            g_main_bbt_addr = addr;
+            break;
+        }
+    }
+    // todo: take care of bad block here if programming error?
+    if (i < NF_BBT_MAX_NR) {
+        nfc_erase_blk(g_main_bbt_addr);
+        writel(*(u32*)g_main_bbt_des, NAND_SPAR_BUF0);
+        writew(g_main_bbt_ver | 0xFF00, NAND_SPAR_BUF0 + 4);
+
+        nfc_program_blk(g_main_bbt_addr, (u32)g_bbt, g_bbt_sz);
+
+        diag_printf("\nWriting BBT at offset 0x%x size=%d\n", g_main_bbt_addr, g_bbt_sz);
+    } else {
+        diag_printf("Error: %s() failed to build main BBT in flash\n", __FUNCTION__);
+        return -1;
+    }
+    return 0;
+}
+
+/*!
+ * Unconditionally erase a block without checking the BI field.
+ * Note that there is NO error checking for passed-in ra.
+ *
+ * @param ra        starting address in the raw address space (offset)
+ *                  Must be block-aligned
+ * @return          0 if successful; -1 otherwise
+ */
+static int nfc_erase_blk(u32 ra)
+{
+    u16 flash_status;
+
+    NFC_CMD_INPUT(FLASH_Block_Erase);
+    // todo: replace MXC_NAND_LA_MASK with number of addr cycles
+    start_nfc_addr_ops(ADDRESS_INPUT_ERASE_BLOCK, NFC_ADJUST_ADDR(ra), MXC_NAND_LA_MASK);
+    NFC_CMD_INPUT(FLASH_Start_Erase);
+
+    flash_status = NFC_STATUS_READ();
+
+    // check I/O bit 0 to see if it is 0 for success
+    if((flash_status & 0x1) != 0) {
+        return -1;
+    }
+    return 0;
+}
+
+/*!
+ * Program a block of data in the flash. This function doesn't do
+ * bad block checking. But if program fails, it return error.
+ * Note: If "len" is less than a block it will program up to a page's
+ *       boundary. If not within a page boundary, then it fills the
+ *       rest of the page with 0xFF.
+ *
+ * @param ra        destination raw flash address
+ * @param buf       source address in the RAM
+ * @param len       len to be programmed
+ *
+ * @return          0 if successful; -1 otherwise
+ */
+static int nfc_program_blk(u32 ra, u32 buf, u32 len)
+{
+    for (; len >= NF_PG_SZ; len -= NF_PG_SZ) {
+        if (nfc_write_pg_random(NFC_ADJUST_ADDR(ra), buf, NFC_MAIN_ONLY, 0) != 0) {
+            return -1;
+        }
+        ra += NF_PG_SZ;
+        buf += NF_PG_SZ;
+    }
+    if (len != 0) {
+        memset(g_page_buf, 0xFF, NF_PG_SZ);
+        memcpy(g_page_buf, (void *)buf, len);
+        if (nfc_write_pg_random(NFC_ADJUST_ADDR(ra), (u32)g_page_buf, NFC_MAIN_ONLY, 0) != 0) {
+            return -1;
+        }
+    }
+    return 0;
+}
+
+static void mark_blk_bad(unsigned int block, unsigned char *buf,
+                                enum blk_bad_type bad_type)
+{
+    unsigned int off = block >> 2;       // byte offset - each byte can hold status for 4 blocks
+    unsigned int sft = (block & 3) << 1;  // bit shift 0, 2, 4, 6
+    unsigned char val = buf[off];
+    diag_printf1("buf[%d]=0x%x\n", off, buf[off]);
+
+    val &= ~(3 << sft) | (bad_type << sft);
+    buf[off] = val;
+    diag_printf1("buf[%d]=0x%x\n", off, val);
+}
+
+/*!
+ * Erase a range of NAND flash good blocks only.
+ * It skips bad blocks and update the BBT once it sees new bad block due to erase.
+ * @param addr          raw NAND flash address. it has to be block size aligned
+ * @param len           number of bytes
+ * @param skip_bad      if 1, don't erase bad block; otherwise, always erase
+ * @param verbose       use true to print more messages
+ *
+ * @return              FLASH_ERR_OK (0) if successful; non-zero otherwise
+ */
+int nfc_erase_region(u32 addr, u32 len, u32 skip_bad, bool verbose)
+{
+    u32 sz, blk, update = 0, skip = 0, j = 0;
+
+    nfc_printf(NFC_DEBUG_MED, "%s(addr=0x%x, len=0x%x)\n",
+               __FUNCTION__, addr, len);
+
+    if ((addr % NF_BLK_SZ) != 0 || (len % NF_BLK_SZ) != 0 || len == 0) {
+        diag_printf("%s(): invalid value or not aligned with block boundry\n", __FUNCTION__);
+        diag_printf("addr=0x%x, len=%d\n", addr, len);
+        return FLASH_ERR_INVALID;
+    }
+
+    // now addr has to be block aligned
+    for (sz = 0; sz < len; addr += NF_BLK_SZ, j++) {
+        blk = OFFSET_TO_BLOCK(addr);
+        if (skip_bad && nfc_is_badblock(blk, g_bbt)) {
+            diag_printf("\nWarning: %s(addr=0x%x, block=%d): skipping bad\n",
+                       __FUNCTION__, addr, blk);
+            skip++;
+            continue;
+        }
+        if (nfc_erase_blk(addr) != 0) {
+            diag_printf("\nError: %s2(addr=0x%x, block=%d): run-time erase error!\n",
+                       __FUNCTION__, addr, blk);
+            mark_blk_bad(blk, g_bbt, BLK_BAD_RUNTIME);
+            if (!skip_bad) {
+                sz += NF_BLK_SZ;
+            }
+            // we don't need to update the table immediately here since even
+            // with power loss now, we should see the same erase error again.
+            update++;
+            continue;
+        }
+        if (verbose) {
+            if ((j % 0x20) == 0)
+                diag_printf("\n%s 0x%08x: ", skip_bad ? "Erase" : "FORCE erase", addr);
+            diag_printf(".");
+        }
+        sz += NF_BLK_SZ;
+    }
+    if (update) {
+        if (program_bbt_to_flash() != 0) {
+            diag_printf("ERROR: TOO BAD! What can I do?\n");
+            return -1;
+        }
+        diag_printf("\n%s(new bad blocks=%d)\n\n", __FUNCTION__, update);
+    }
+    if (skip) {
+        diag_printf("\n%s(skip bad blocks=%d\n\n", __FUNCTION__, skip);
+    }
+    return FLASH_ERR_OK;
+}
+
+/*!
+ * Program a range of NAND flash in blocks only.
+ * It skips bad blocks and update the BBT once it sees new bad block due to program.
+ * @param addr          raw NAND flash address. it has to be block size aligned
+ * @param len           number of bytes
+ * @return              FLASH_ERR_OK (0) if successful; non-zero otherwise
+ */
+int nfc_program_region(u32 addr, u32 buf, u32 len)
+{
+    u32 sz, blk, update = 0, skip = 0;
+
+    diag_printf1("%s(addr=0x%x, len=0x%x)\n", __FUNCTION__, addr, len);
+
+    if ((addr % NF_BLK_SZ) != 0 || len == 0) {
+        diag_printf("%s(): invalid value or not aligned with block boundry\n", __FUNCTION__);
+        diag_printf("addr=0x%x, len=%d\n", addr, len);
+        return FLASH_ERR_INVALID;
+    }
+
+    // now addr has to be block aligned
+    for (; ; addr += NF_BLK_SZ) {
+        blk = OFFSET_TO_BLOCK(addr);
+        if (nfc_is_badblock(blk, g_bbt)) {
+            diag_printf("\nWarning: %s(addr=0x%x, block=%d): skipping bad\n",
+                       __FUNCTION__, addr, blk);
+            skip++;
+            continue;
+        }
+        sz = (len >= NF_BLK_SZ) ? NF_BLK_SZ : len;
+
+        if (nfc_program_blk(addr, buf, sz) != 0) {
+            diag_printf("\nError: %s2(addr=0x%x, block=%d): run-time program error!\n",
+                       __FUNCTION__, addr, blk);
+            mark_blk_bad(blk, g_bbt, BLK_BAD_RUNTIME);
+            // we don't need to update the table immediately here since even
+            // with power loss now, we should see the same program error again.
+            update++;
+            continue;
+        }
+
+        len -= NF_BLK_SZ;
+        buf += NF_BLK_SZ;
+        if (len == 0 || sz < NF_BLK_SZ)
+            break;
+    }
+    if (update) {
+        if (program_bbt_to_flash() != 0) {
+            diag_printf("ERROR: TOO BAD! What can I do?\n");
+            return -1;
+        }
+        diag_printf("\n%s(new bad blocks=%d\n", __FUNCTION__, update);
+    }
+    if (skip)
+        diag_printf("\n%s(skip bad blocks=%d\n", __FUNCTION__, skip);
+
+    return FLASH_ERR_OK;
+}
+
+/*! todo MXC_NAND_LA_MASK should go away
+ * Read data from raw NAND flash address to memory. The MSB of the passed-
+ * in flash address will be masked off inside the function.
+ * It skips bad blocks and read good blocks of data for "len" bytes.
+ *
+ * @param addr          NAND flash address. it has to be page aligned
+ * @param buf           memory buf where data will be copied to
+ * @param len           number of bytes
+ * @return              FLASH_ERR_OK (0) if successful; non-zero otherwise
+ */
+int nfc_read_region(u32 addr, u32 buf, u32 len)
+{
+    u32 sz, blk = 0, bad;
+
+    // make sure 32-bit aligned
+    len = (len + 3) & (~0x3);
+
+    diag_printf1("\n%s(addr=0x%x, buf=0x%x, len=0x%x)\n",
+               __FUNCTION__, addr, buf, len);
+
+    if (addr < (u32)(flash_info.start) || (addr + len) > (u32)(flash_info.end) || len == 0) {
+        diag_printf("\n%s(): Error: invalide address=0x%x, len=%d\n",
+                    __FUNCTION__, addr, len);
+        diag_printf("flash_info.start=%p, flash_info.end=%p\n", flash_info.start, flash_info.end);
+        return FLASH_ERR_INVALID;
+    }
+
+    if ((addr % NF_PG_SZ) != 0) {
+        diag_printf("\n%s(): invalid value or not aligned with page boundry\n", __FUNCTION__);
+        diag_printf("addr=0x%x, len=%d\n", addr, len);
+        return FLASH_ERR_INVALID;
+    }
+
+    for (sz = 0, bad = 0; sz < len;) {
+        if ((addr % NF_BLK_SZ) == 0) {
+            // only need to test block aligned page address
+            blk = OFFSET_TO_BLOCK(addr);
+            if (nfc_is_badblock(blk, g_bbt)) {
+                diag_printf("\nWarning: %s(addr=0x%x, block=%d): skipping bad\n",
+                           __FUNCTION__, addr, blk);
+                addr += NF_BLK_SZ;
+                if (bad++ >= (NF_BLK_CNT / 10)) {
+                    diag_printf("Found too many bad blocks (%d). Abort\n", bad);
+                    return FLASH_ERR_PROTOCOL;
+                }
+                continue;
+            }
+        }
+
+        if (nfc_read_page(addr) != 0) {
+            diag_printf("\nError: %s() can't handle read error at (addr=0x%x, block=%d)\n",
+                       __FUNCTION__, addr, blk);
+            return FLASH_ERR_INVALID;
+        }
+        // now do the copying
+        nfc_buf_mem_cpy((void*)buf, (void*)(NAND_MAIN_BUF0), NF_PG_SZ);
+
+        buf += NF_PG_SZ; sz += NF_PG_SZ; addr += NF_PG_SZ;
+    }
+    return FLASH_ERR_OK;
+}
+
+/*
+ * Support only either program for main area only. Or spare-area only for 512B.
+ * If one wants to write to the spare-area, then before calling this function,
+ * the spare area NFC RAM buffer has to be setup already. This function doesn't touch
+ * the spare area NFC RAM buffer.
+ * Note that:
+ *  1) If adj_addr's column address is all zero, then the ECC is always
+ *     ON unless the ecc_force argument is non-zero, which is mainly for testing.
+ *  2) If adj_addr's column address is non zeor, then the ECC is always
+ *     OFF unless the ecc_force argument is non-zero, which is mainly for testing.
+ *  3) Special treatment for barker code on certain platforms. The barker code
+ *     always stored in the beginning of the 1st spare area.
+ *
+ * @param   adj_addr        raw flash byte offset that has been adjusted with NAND_PG_SHIFT
+ * @param   buf             sdram buffer to be programmed into the NAND flash.
+ * @return  0 if successful; non-zero otherwise
+ */
+static int nfc_write_pg_random(u32 adj_addr, u32 buf, enum nfc_page_area area,
+                               u32 ecc_force)
+{
+    u16 flash_status;
+    u32 ecc = 1;
+    
+    // the 2nd condition is to test for unaligned page address -- ecc has to be off.
+    if (ecc_force == ECC_FORCE_OFF || (adj_addr & ((1 << NAND_PG_SHIFT) - 1)) != 0 ) {
+        ecc = 0;
+    }
+
+    diag_printf1("%s(0x%x, 0x%x, %d)\n", __FUNCTION__, adj_addr, buf, area);
+
+    switch (area) {
+    case NFC_MAIN_ONLY:
+        // No need to worry about the spare area
+        nfc_buf_mem_cpy((void *)NAND_MAIN_BUF0, (void *)buf, NF_PG_SZ);
+#ifdef BARKER_CODE_SWAP_LOC
+        // To replace the data at offset MXC_NAND_BOOT_LOAD_BARKER with
+        // the address of the NFC base. This is needed for certain platforms.
+        if ((u32)adj_addr <= BARKER_CODE_SWAP_LOC && (u32)(adj_addr + NF_PG_SZ - 1) > BARKER_CODE_SWAP_LOC) {
+            diag_printf("\n[INFO]: copy data at 0x%x to spare area and set it to 0x%x\n",
+                        BARKER_CODE_SWAP_LOC, BARKER_CODE_VAL);
+            writel(readl(NFC_BASE + BARKER_CODE_SWAP_LOC), NAND_SPAR_BUF0);
+            // todo: set BARKER_CODE_VAL and BARKER_CODE_SWAP_LOC for skye, etc.
+            writel(BARKER_CODE_VAL, NFC_BASE + BARKER_CODE_SWAP_LOC);
+        }
+#endif
+        break;
+    case NFC_SPARE_ONLY:
+        // This is used ONLY for testing when manually create "bad" blocks
+        diag_printf("Spare-only write. Testing purpose only\n");
+        diag_printf("%s(0x%x, 0x%x, %d)\n", __FUNCTION__, adj_addr, buf, area);
+        nfc_buf_mem_cpy((void *)(NAND_SPAR_BUF0), (void *)buf, 16);
+        if (!(g_is_2k_page || g_is_4k_page)) {
+            NFC_CMD_INPUT(FLASH_Read_Mode3);
+        }
+        break;
+    default:
+        diag_printf("NOT supported yet!\n");
+        return -1;
+    }
+
+    NFC_CMD_INPUT(FLASH_Send_Data);
+    start_nfc_addr_ops(ADDRESS_INPUT_PROGRAM_PAGE, adj_addr, MXC_NAND_LA_MASK);
+
+    NFC_DATA_INPUT(RAM_BUF_0, area, ecc);
+    if (g_is_4k_page && PG_2K_DATA_OP_MULTI_CYCLES()) {
+        diag_printf("4K page with multi cycle write is not supported\n");
+        // die here -- need to fix the SW
+        while (1);
+    }
+    if (g_is_2k_page && PG_2K_DATA_OP_MULTI_CYCLES()) {
+        NFC_DATA_INPUT_2k(RAM_BUF_1);
+        NFC_DATA_INPUT_2k(RAM_BUF_2);
+        NFC_DATA_INPUT_2k(RAM_BUF_3);
+    }
+    NFC_CMD_INPUT(FLASH_Program);
+
+    flash_status = NFC_STATUS_READ();
+    // check I/O bit 0 to see if it is 0 for success
+    if((flash_status & 0x1) != 0) {
+        diag_printf("Error: Run time program error. TODO: need to handle it. Copyback?\n");
+        diag_printf("Error %d: %s(page=%d, col=%d) status=0x%x\n",
+                    __LINE__, __FUNCTION__, adj_addr >> NAND_PG_SHIFT,
+                    adj_addr & ((1 << NAND_PG_SHIFT) -1), flash_status);
+
+        return -1;
+    }
+
+    return 0;
+}
+
+/*!
+ * Low level spare-only read. Only applies to 512 byte page NAND.
+ *
+ * @param addr          starting address to be read from the NAND flash
+ * @param buf           one of the internal buffers
+ * @return              0 if no error or 1-bit error; -1 otherwise
+ */
+static int nfc_sp_only_read_ll(u32 addr, enum nfc_internal_buf buf)
+{
+    volatile u16 temp;
+
+    NFC_CMD_INPUT(FLASH_Read_Mode3);
+    start_nfc_addr_ops(ADDRESS_INPUT_READ_PAGE, addr, MXC_NAND_LA_MASK);
+    NFC_DATA_OUTPUT(buf, FDO_SPARE_ONLY, g_ecc_enable);
+    temp = readw(ECC_STATUS_RESULT_REG);
+    NFC_CMD_INPUT(FLASH_Read_Mode1);
+
+    if (g_ecc_enable) {
+        if ((temp & 0x2) != 0x0) {
+            nfc_printf(NFC_DEBUG_MED, "\nError %d: %s(addr=0x%x): ECC status result reg=0x%x\n",
+                        __LINE__, __FUNCTION__, addr, temp);
+            return -1;
+        }
+    }
+
+    return 0;
+}
+
+/*!
+ * Read spare area from NAND flash to the 1st internal RAM buffer.
+ * Not supported for 2kB page NAND.
+ *
+ * @param addr          starting address to be read from the NAND flash
+ *
+ * @return              0 if no error or 1-bit error; -1 otherwise
+ */
+static int nfc_read_page_sp(u32 addr)
+{
+    if (g_spare_only_read_ok) {
+        if (g_is_2k_page || g_is_4k_page) {
+            diag_printf("spare-only read for 2k page is not supported\n");
+            return -1;
+        }
+        return nfc_sp_only_read_ll(addr, RAM_BUF_0);
+    }
+    return -1;
+}
+
+/*
+ * The adj_addr must have been adjusted with NAND_PG_SHIFT.
+ * See comments for start_nfc_addr_ops()
+ * This function read a page from flash at adj_addr byte offset.
+ * Note that:
+ *  1) If adj_addr's column address is all zero, then the ECC is always
+ *     ON unless the force argument is non-zero, which is mainly for testing.
+ *  2) If adj_addr's column address is non zeor, then the ECC is always
+ *     OFF unless the force argument is non-zero, which is mainly for testing.
+ *  3) Special treatment for barker code on certain platforms. The barker code
+ *     always copied from the beginning of the 1st spare area.
+ */
+static int nfc_read_pg_random(u32 adj_addr, u32 ecc_force)
+{
+    u32 t1, ecc = 1;
+    u8 t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0;
+    int res = 0;
+
+    if (ecc_force == ECC_FORCE_OFF || (adj_addr & ((1 << NAND_PG_SHIFT) - 1)) != 0 )
+        ecc = 0;
+
+    NFC_CMD_INPUT(FLASH_Read_Mode1);
+    start_nfc_addr_ops(ADDRESS_INPUT_READ_PAGE, adj_addr, MXC_NAND_LA_MASK);
+    if (g_is_2k_page || g_is_4k_page) {
+        NFC_CMD_INPUT(FLASH_Read_Mode1_LG);
+    }
+
+    NFC_DATA_OUTPUT(RAM_BUF_0, FDO_PAGE_SPARE, ecc);
+    if (g_nfc_version == MXC_NFC_V1) {
+        t1 = readw(ECC_STATUS_RESULT_REG);
+        if (g_is_2k_page && PG_2K_DATA_OP_MULTI_CYCLES()) {
+            NFC_DATA_OUTPUT(RAM_BUF_1, FDO_PAGE_SPARE, ecc);
+            t2 = readw(ECC_STATUS_RESULT_REG);
+            NFC_DATA_OUTPUT(RAM_BUF_2, FDO_PAGE_SPARE, ecc);
+            t3 = readw(ECC_STATUS_RESULT_REG);
+            NFC_DATA_OUTPUT(RAM_BUF_3, FDO_PAGE_SPARE, ecc);
+            t4 = readw(ECC_STATUS_RESULT_REG);
+        }
+
+        if (ecc && ((t1 & 0xA) != 0x0 || (t2 & 0xA) != 0x0 || (t3 & 0xA) != 0x0
+            || (t4 & 0xA) != 0x0)) {
+            diag_printf("\nError %d: %s(page=%d, col=%d): ECC status=0x%x:0x%x:0x%x:0x%x\n",
+                        __LINE__, __FUNCTION__, adj_addr >> NAND_PG_SHIFT,
+                        adj_addr & ((1 << NAND_PG_SHIFT) -1), t1, t2, t3, t4);
+            res = -1;
+            goto out;
+        }
+    } else if (g_nfc_version == MXC_NFC_V2) {
+        if (g_is_2k_page && PG_2K_DATA_OP_MULTI_CYCLES()) {
+            NFC_DATA_OUTPUT(RAM_BUF_1, FDO_PAGE_SPARE, ecc);
+            NFC_DATA_OUTPUT(RAM_BUF_2, FDO_PAGE_SPARE, ecc);
+            NFC_DATA_OUTPUT(RAM_BUF_3, FDO_PAGE_SPARE, ecc);
+        }
+        if (ecc) {
+            t1 = readl(ECC_STATUS_RESULT_REG);
+            if (g_is_2k_page || g_is_4k_page) {
+                t2 = (t1 >> 4) & 0xF;
+                t3 = (t1 >> 8) & 0xF;
+                t4 = (t1 >> 12) & 0xF;
+                if (g_is_4k_page) {
+                    t5 = (t1 >> 16) & 0xF;
+                    t6 = (t1 >> 20) & 0xF;
+                    t7 = (t1 >> 24) & 0xF;
+                    t8 = (t1 >> 28) & 0xF;
+                }
+            }
+            if ((t1 = (t1 & 0xF)) > 4 || t2 > 4 || t3 > 4 || t4 > 4 || t5 > 4 || t6 > 4 || t7 > 4 || t8 > 4) {
+                diag_printf("\nError %d: %s(page=%d, col=%d)\n",
+                            __LINE__, __FUNCTION__, adj_addr >> NAND_PG_SHIFT,
+                            adj_addr & ((1 << NAND_PG_SHIFT) -1));
+                diag_printf("   ECC status=%x:%x:%x:%x:%x:%x:%x:%x\n", t1, t2, t3, t4, t5, t6, t7, t8);
+                res = -1;
+                goto out;
+            }
+        }
+    } else {
+        diag_printf("Unknown NFC version: %d\n", g_nfc_version);
+        while (1);
+    }
+#ifdef BARKER_CODE_SWAP_LOC
+    // To replace the data at offset BARKER_CODE_SWAP_LOC with the address of the NFC base
+    // This is needed for certain platforms
+    if ((u32)adj_addr <= BARKER_CODE_SWAP_LOC && (u32)(adj_addr + NF_PG_SZ - 1) > BARKER_CODE_SWAP_LOC) {
+        diag_printf("\n[INFO]: copy back data from spare to 0x%x\n", BARKER_CODE_SWAP_LOC);
+        writel(readl(NAND_SPAR_BUF0), NFC_BASE + BARKER_CODE_SWAP_LOC);
+    }
+#endif
+
+out:
+    return res;
+}
+
+/*!
+ * Read a page's both main and spare area from NAND flash to the internal RAM buffer.
+ * It always reads data to the internal buffer 0.
+ *
+ * @param ra          starting address to be read from the NAND flash; must be page-aligned
+ *
+ * @return              0 if no error or 1-bit error; -1 otherwise
+ */
+static int nfc_read_page(u32 ra)
+{
+    u32 flash_addr;
+
+    if (ra % NF_PG_SZ) {
+        diag_printf("Non page-aligned read not supported here: 0x%x\n", ra);
+        return -1;
+    }
+    flash_addr = NFC_ADJUST_ADDR(ra);
+
+    return nfc_read_pg_random(flash_addr, ECC_FORCE_ON);
+}
+
+// Read data into buffer
+int flash_read_buf(void* addr, void* data, int len)
+{
+    if (IS_BOOTING_FROM_NOR() || IS_FIS_FROM_NOR()) {
+        memcpy(data, addr, len);
+        return 0;
+    } else {
+        return nfc_read_region((u32)addr, (u32)data, (u32)len);
+    }
+}
+
+void mxc_nfc_print_info(void)
+{
+    diag_printf("[0x%08x bytes]: %d blocks of %d pages of %d bytes each.\n",
+                NF_DEV_SZ, NF_BLK_CNT,
+                NF_PG_PER_BLK, NF_PG_SZ);
+}
+
+/*
+ * Look for the BBT table depending on the passed-in lowlevel value.
+ * @param   lowlevel    If true, then it does a low level scan based on factory
+ *                      marked BI(block info) field with ECC off to decide if a
+ *                      block is bad.
+ *                      If false, then it checks to see if an existing BBT in the
+ *                      flash or not. If not, then it returns -1. If yes, it will
+ *                      prints out the number of bad blocks.
+ *
+ * @return  number of bad blocks for the whole nand flash
+ * 
+ * Note: For a brand new flash, this function has to be called with
+ *       lowlevel=true.
+ *
+ *
+ */
+static int mxc_nfc_scan(bool lowlevel)
+{
+    u32 addr, bad = 0, i = 0, blk;
+    u32 count1 = 0, count2 = 0;
+    u8 *buf = 0;
+
+    nfc_printf(NFC_DEBUG_MAX, "%s()\n", __FUNCTION__);
+
+    if (g_nfc_debug_measure) {
+        count1 = hal_timer_count();
+    }
+    // read out the last 4 blocks for marker
+    // need to keep where is the td and md block number
+    if (!lowlevel) {
+        diag_printf("Searching for BBT table in the flash ...\n");
+        g_main_bbt_addr = 0;
+        for (i = 0; i < NF_BBT_MAX_NR; i++) {
+            blk = NF_BLK_CNT - i - 1;
+            addr = blk * NF_BLK_SZ;
+            if (nfc_read_pg_random(NFC_ADJUST_ADDR(addr), ECC_FORCE_ON) != 0)
+                continue;
+            if (*(u32 *)g_main_bbt_des == *(u32 *)NAND_SPAR_BUF0) {
+                diag_printf1("bingo\n");
+                g_main_bbt_addr = addr;
+                g_main_bbt_ver = readw(NAND_SPAR_BUF0 + 4);
+                if (nfc_read_region(addr, (u32)g_bbt, g_bbt_sz) != 0) {
+                    diag_printf("ERROR!!! Can't read BBT table at addr: 0x%x\n", addr);
+                    return -1;
+                }
+                diag_printf("\nFound version %d Bbt0 at block %d (0x%x)\n",
+                            g_main_bbt_ver, OFFSET_TO_BLOCK(g_main_bbt_addr), g_main_bbt_addr);
+                break;
+            }
+            // todo: finish up the mirror block detection also
+        }
+        if (!g_main_bbt_addr) {
+            diag_printf("No BBT table found. Need to do \"nand scan\" first\n");
+            return -1;
+        }
+        buf = g_bbt;
+    } else
+        diag_printf("Do low level scan to construct BBT\n");
+
+    // do some low level scan of each block and check for bad.
+    for (i = 0; i < NF_BLK_CNT; i++) {
+        if (nfc_is_badblock(i, buf)) {
+            // construct the bad block table
+            if (!buf)
+                mark_blk_bad(i, g_bbt, BLK_BAD_FACTORY);
+            bad++;
+            diag_printf("Block %d is bad\n", i);
+        }
+    }
+
+    diag_printf("Total bad blocks: %d\n", bad);
+    if (g_nfc_debug_measure) {
+        count2 = hal_timer_count();
+        diag_printf("counter1=0x%x, counter2=0x%x, diff=0x%x\n",
+                    count1, count2, count2 - count1);
+        diag_printf("Using [diff * 1000000 / 32768] to get usec\n");
+    }
+    return bad;
+}
+
+////////////////////////// "nand" commands support /////////////////////////
+// Image management functions
+local_cmd_entry("info",
+        "Show nand flash info (number of good/bad blocks)",
+        "[-f <raw address>] [-l <length>]",
+        nand_info,
+        NAND_cmds
+           );
+
+local_cmd_entry("show",
+        "Show a page main/spare areas or spare area only (-s)",
+        "-f <raw page address> [-s]",
+        nand_show,
+        NAND_cmds
+           );
+
+local_cmd_entry("read",
+        "Read data from nand flash into RAM",
+        "-f <raw addr> -b <mem_load_addr> -l <byte len> [-c <col>]\n \
+      Note -c is only for 2K-page for value <0, 2048+64-1>",
+        nand_read,
+        NAND_cmds
+           );
+
+local_cmd_entry("write",
+        "Write data from RAM into nand flash",
+        "-f <raw address> -b <memory_address> -l <image_length> [-c <col_addr>]",
+        nand_write,
+        NAND_cmds
+           );
+
+local_cmd_entry("erase",
+        "Erase nand flash contents",
+        "-f <raw address> -l <length> [-o] \n\
+                -o: force erase (even for bad blocks)",
+        nand_erase,
+        NAND_cmds
+           );
+
+local_cmd_entry("scan",
+        "Scan bad blocks and may also save bad block table into the NAND flash.",
+        "[-o] [-r] \n\
+                No argument: save existing bad block table (BBT) \n\
+                -r: re-scan with ECC off and save BBT -- for brand NEW flash \n\
+                -o: force erase all, reconstruct BBT (no ECC) and save BBT -- for development. ",
+        nand_scan,
+        NAND_cmds
+           );
+
+local_cmd_entry("debug",
+        "Various NAND debug features ",
+        "<0> min debug messages <default> \n\
+             <1> med debug messages \n\
+             <2> max debug messages \n\
+             <3> enable(default)/disable h/w ECC for both r/w \n\
+             <4> disable(default)/enalbe spare-only read \n\
+             <9> enable/disable measurement \n\
+             no parameter - display current debug setup",
+        nand_debug_fun,
+        NAND_cmds
+           );
+
+// Define table boundaries
+CYG_HAL_TABLE_BEGIN( __NAND_cmds_TAB__, NAND_cmds);
+CYG_HAL_TABLE_END( __NAND_cmds_TAB_END__, NAND_cmds);
+
+extern struct cmd __NAND_cmds_TAB__[], __NAND_cmds_TAB_END__;
+
+// CLI function
+static cmd_fun do_nand_cmds;
+RedBoot_nested_cmd("nand",
+           "Utility function to NAND flash using raw address",
+           "{cmds}",
+           do_nand_cmds,
+           __NAND_cmds_TAB__, &__NAND_cmds_TAB_END__
+          );
+
+static void nand_usage(char *why)
+{
+    diag_printf("*** invalid 'nand' command: %s\n", why);
+    cmd_usage(__NAND_cmds_TAB__, &__NAND_cmds_TAB_END__, "nand ");
+}
+
+static u32 curr_addr;
+static void nand_show(int argc, char *argv[])
+{
+    u32 ra;
+    bool flash_addr_set = false;
+    bool spar_only = false;
+    struct option_info opts[2];
+
+    init_opts(&opts[0], 'f', true, OPTION_ARG_TYPE_NUM,
+          (void *)&ra, (bool *)&flash_addr_set, "NAND FLASH memory byte address");
+    init_opts(&opts[1], 's', false, OPTION_ARG_TYPE_FLG,
+          (void *)&spar_only, (bool *)0, "Spare only");
+
+    if (!scan_opts(argc, argv, 2, opts, 2, 0, 0, "")) {
+        return;
+    }
+    if (!flash_addr_set) {
+        ra = curr_addr;
+        curr_addr += NF_PG_SZ;
+    } else {
+        curr_addr = ra;
+    }
+
+    if (ra % NF_PG_SZ) {
+        diag_printf("error: non-page aligned\n");
+        return;
+    }
+
+    if (nfc_is_badblock(OFFSET_TO_BLOCK(ra), g_bbt)) {
+        diag_printf("This is a bad block\n");
+    }
+
+    print_page(ra, spar_only);
+}
+
+/*!
+ * For low level nand read command. It doesn't check for bad block or not
+ */
+static void nand_read(int argc, char *argv[])
+{
+    int len;
+    u32 mem_addr, ra, col;
+    bool mem_addr_set = false;
+    bool flash_addr_set = false;
+    bool length_set = false;
+    bool col_set = false;
+    struct option_info opts[4];
+    int j = 0;
+    bool ecc_status = g_ecc_enable;;
+
+    init_opts(&opts[0], 'b', true, OPTION_ARG_TYPE_NUM,
+              (void *)&mem_addr, (bool *)&mem_addr_set, "memory base address");
+    init_opts(&opts[1], 'f', true, OPTION_ARG_TYPE_NUM,
+              (void *)&ra, (bool *)&flash_addr_set, "FLASH memory base address");
+    init_opts(&opts[2], 'l', true, OPTION_ARG_TYPE_NUM,
+              (void *)&len, (bool *)&length_set, "image length [in FLASH]");
+    init_opts(&opts[3], 'c', true, OPTION_ARG_TYPE_NUM,
+              (void *)&col, (bool *)&col_set, "column addr");
+
+    if (!scan_opts(argc, argv, 2, opts, 4, 0, 0, 0)) {
+        nand_usage("invalid arguments");
+        return;
+    }
+
+    if (!mem_addr_set || !flash_addr_set || !length_set) {
+        nand_usage("required parameter missing");
+        return;
+    }
+    if ((mem_addr < (CYG_ADDRESS)ram_start) ||
+        ((mem_addr+len) >= (CYG_ADDRESS)ram_end)) {
+        diag_printf("** WARNING: RAM address: %p may be invalid\n", (void *)mem_addr);
+        diag_printf("   valid range is %p-%p\n", (void *)ram_start, (void *)ram_end);
+    }
+
+    // Safety check - make sure the address range is not within the code we're running
+    if (flash_code_overlaps((void *)ra, (void *)(ra+len-1))) {
+        diag_printf("Can't program this region - contains code in use!\n");
+        return;
+    }
+
+    if (col_set) {
+        u32 flash_addr;
+
+        diag_printf("Random read at page %d, column %d\n",
+                    ra / NF_PG_SZ, col);
+        flash_addr = ((ra / NF_PG_SZ) << NAND_PG_SHIFT) + col;
+
+        if (g_is_2k_page || g_is_4k_page) {
+            g_ecc_enable = false;
+        }
+        nfc_read_pg_random(flash_addr, 0); // don't swap BI for 2k page
+        if (g_is_2k_page || g_is_4k_page) {
+            g_ecc_enable = ecc_status;
+        }
+        nfc_buf_mem_cpy((void *)mem_addr, (void *)NAND_MAIN_BUF0, NF_PG_SZ);
+        return;
+    }
+
+    // insure integer multiple of page size
+    len = (len + NF_PG_SZ - 1) & ~(NF_PG_SZ - 1);
+
+    do {
+        if (OFFSET_TO_BLOCK(ra) > (NF_BLK_CNT - 1)) {
+            diag_printf("Out of range: addr=0x%x\n", ra);
+            return;
+        }
+        if (nfc_read_page(ra) != 0) {
+            diag_printf("Error %d: uncorrectable ECC at addr 0x%x\n", __LINE__, ra);
+            diag_printf("should invoke bad block management to replace this block \n");
+            diag_printf("and then mark this block \"bad\". But Redboot doesn't do it yet.\n");
+        }
+        if ((j++ % 0x20) == 0)
+            diag_printf("\n%s 0x%08x: ", __FUNCTION__, ra);
+        diag_printf(".");
+
+        nfc_buf_mem_cpy((void *)mem_addr, (void *)NAND_MAIN_BUF0, NF_PG_SZ);
+
+        ra += NF_PG_SZ;
+        mem_addr += NF_PG_SZ;
+        len -= NF_PG_SZ;
+    } while (len > 0);
+    diag_printf("\n");
+}
+
+static void nand_write(int argc, char *argv[])
+{
+    int len, j = 0;
+    u32 mem_addr, ra, col;
+    bool mem_addr_set = false;
+    bool flash_addr_set = false;
+    bool length_set = false;
+    bool col_set = false;
+    struct option_info opts[4];
+    bool ecc_status = g_ecc_enable;;
+
+    init_opts(&opts[0], 'b', true, OPTION_ARG_TYPE_NUM,
+              (void *)&mem_addr, (bool *)&mem_addr_set, "memory base address");
+    init_opts(&opts[1], 'f', true, OPTION_ARG_TYPE_NUM,
+              (void *)&ra, (bool *)&flash_addr_set, "FLASH memory base address");
+    init_opts(&opts[2], 'l', true, OPTION_ARG_TYPE_NUM,
+              (void *)&len, (bool *)&length_set, "image length [in FLASH]");
+    init_opts(&opts[3], 'c', true, OPTION_ARG_TYPE_NUM,
+              (void *)&col, (bool *)&col_set, "column addr");
+    if (!scan_opts(argc, argv, 2, opts, 4, 0, 0, 0))
+    {
+        nand_usage("invalid arguments");
+        return;
+    }
+
+    if (!mem_addr_set || !flash_addr_set || !length_set) {
+        nand_usage("required parameter missing");
+        return;
+    }
+
+    if ((mem_addr < (CYG_ADDRESS)ram_start) ||
+        ((mem_addr+len) >= (CYG_ADDRESS)ram_end)) {
+        diag_printf("** WARNING: RAM address: %p may be invalid\n", (void *)mem_addr);
+        diag_printf("   valid range is %p-%p\n", (void *)ram_start, (void *)ram_end);
+    }
+
+    if (col_set) {
+        u32 flash_addr;
+
+        diag_printf("Random write at page %d, column %d\n",
+                    ra / NF_PG_SZ, col);
+        flash_addr = ((ra / NF_PG_SZ) << NAND_PG_SHIFT) + col;
+
+        if (g_is_2k_page || g_is_4k_page) {
+            g_ecc_enable = false;
+        }
+        nfc_write_pg_random(flash_addr, mem_addr, NFC_MAIN_ONLY, 0);
+        if (g_is_2k_page || g_is_4k_page) {
+            g_ecc_enable = ecc_status;
+        }
+        return;
+    }
+
+    if ((len % NF_PG_SZ) != 0) {
+        diag_printf("Not a full page write?\n\n");
+    }
+
+    do {
+        if (OFFSET_TO_BLOCK(ra) > (NF_BLK_CNT - 1)) {
+            diag_printf("Out of range: addr=0x%x\n", ra);
+            return;
+        }
+        if (nfc_is_badblock(OFFSET_TO_BLOCK(ra), g_bbt)) {
+            diag_printf("\nERROR: bad block at raw addr=0x%x(block=%d)\n",
+                       ra, OFFSET_TO_BLOCK(ra));
+            diag_printf("%s() failed\n", __FUNCTION__);
+            return;
+        }
+
+        if (nfc_write_pg_random(NFC_ADJUST_ADDR(ra), mem_addr, NFC_MAIN_ONLY, 0) != 0) {
+            if (g_nfc_debug_level >= NFC_DEBUG_DEF) {
+                diag_printf("Error %d: program error at addr 0x%x\n", __LINE__, ra);
+                diag_printf("should invoke bad block management to replace this block \n");
+                diag_printf("and then mark this block \"bad\". But Redboot doesn't do it yet.\n");
+            }
+            return;
+        }
+        if ((j++ % 0x20) == 0)
+            diag_printf("\nProgramming 0x%08x: ", ra);
+        diag_printf(".");
+
+        len -= NF_PG_SZ;
+        ra += NF_PG_SZ;
+        mem_addr += NF_PG_SZ;
+    } while (len > 0);
+    diag_printf("\n");
+}
+
+void nand_debug_fun(int argc, char *argv[])
+{
+    int opt;
+
+    if (argc == 3) {
+        opt = argv[2][0] - '0';
+        switch (opt) {
+        case 0:
+            g_nfc_debug_level = NFC_DEBUG_MIN;
+            break;
+        case 1:
+            g_nfc_debug_level = NFC_DEBUG_MED;
+            break;
+        case 2:
+            g_nfc_debug_level = NFC_DEBUG_MAX;
+            break;
+        case 3:
+            g_ecc_enable = g_ecc_enable? false: true;
+            break;
+        case 4:
+            // toggle g_spare_only_read_ok
+            g_spare_only_read_ok = g_spare_only_read_ok? false: true;
+            break;
+        case 9:
+            g_nfc_debug_measure = g_nfc_debug_measure? false: true;
+            break;
+
+        default:
+            diag_printf("%s(%s) not supported\n", __FUNCTION__, argv[2]);
+            break;
+
+        }
+    }
+    diag_printf("Current debug options are: \n");
+    diag_printf("    h/w ECC: %s\n", g_ecc_enable ? "on":"off");
+    diag_printf("    sp-only read: %s\n", g_spare_only_read_ok ? "on":"off");
+    diag_printf("    measurement: %s\n", g_nfc_debug_measure ? "on":"off");
+    diag_printf("    message level: %s\n", (g_nfc_debug_level == NFC_DEBUG_MIN) ? "min" : \
+        ((g_nfc_debug_level == NFC_DEBUG_MED) ? "med" : "max"));
+}
+
+static void nand_erase(int argc, char *argv[])
+{
+    u32 len, ra;
+    bool faddr_set = false;
+    bool force_erase_set = false;
+    bool length_set = false;
+    struct option_info opts[4];
+
+    init_opts(&opts[0], 'f', true, OPTION_ARG_TYPE_NUM,
+          (void **)&ra, (bool *)&faddr_set, "FLASH memory base address");
+    init_opts(&opts[1], 'l', true, OPTION_ARG_TYPE_NUM,
+          (void **)&len, (bool *)&length_set, "length in bytes");
+    init_opts(&opts[2], 'o', false, OPTION_ARG_TYPE_FLG,
+          (void **)&force_erase_set, (bool *)&force_erase_set, "force erases block");
+
+    if (!scan_opts(argc, argv, 2, opts, 4, 0, 0, 0)) {
+        nand_usage("invalid arguments");
+        return;
+    }
+
+    if (!faddr_set || !length_set) {
+        nand_usage("missing argument");
+        return;
+    }
+    if ((ra % NF_BLK_SZ) != 0 ||
+        (len % NF_BLK_SZ) != 0 || len == 0) {
+        diag_printf("Address or length is not block aligned or length is zero!\n");
+        diag_printf("Block size is 0x%x\n", NF_BLK_SZ);
+        return;
+    }
+
+    if (!verify_action("About to erase 0x%x bytes from nand offset 0x%x\n", len, ra)) {
+        diag_printf("** Aborted\n");
+        return;
+    }
+
+    // now ra is block aligned
+    if (force_erase_set == true) {
+        diag_printf("Force erase ...");
+        nfc_erase_region(ra, len, 0, 1);
+        diag_printf("\n");
+    } else {
+        nfc_erase_region(ra, len, 1, 1);
+    }
+    diag_printf("\n");
+}
+
+extern void romupdate(int argc, char *argv[]);
+static void nand_scan(int argc, char *argv[])
+{
+    bool force_erase = false;
+    bool force_rescan = false;
+    struct option_info opts[2];
+
+    init_opts(&opts[0], 'o', false, OPTION_ARG_TYPE_FLG,
+          (void *)&force_erase, (bool *)0, "force erases block first");
+
+    init_opts(&opts[1], 'r', false, OPTION_ARG_TYPE_FLG,
+          (void *)&force_rescan, (bool *)0, "force low level re-scan");
+
+    if (!scan_opts(argc, argv, 2, opts, 2, 0, 0, 0)) {
+        nand_usage("invalid arguments");
+        return;
+    }
+
+    if (!force_erase && !force_rescan && !g_main_bbt_addr) {
+        diag_printf("Need to build BBT table first with \"nand scan [-o|-r]\"\n");
+        return;
+    }
+    if (force_erase) {
+        diag_printf("Force erase first ...\n");
+        memset(g_bbt, -1, g_bbt_sz);
+        // do force erase, including bad blocks. After this call, g_bbt should be re-built
+        // for the whole NAND flash.
+        nfc_erase_region(0, NF_DEV_SZ, 0, 1);
+        g_main_bbt_addr = 0;
+        diag_printf("\n");
+    }
+    if (force_rescan) {
+        diag_printf("Force re-scan ...\n");
+        memset(g_bbt, -1, g_bbt_sz);
+        mxc_nfc_scan(true);
+        g_main_bbt_addr = 0;
+    }
+    // program g_bbt into the flash
+    diag_printf("Writing Bbt0 to flash\n");
+    if (program_bbt_to_flash() != 0) {
+        diag_printf("ERROR: TOO BAD! What can I do?\n");
+    } else
+        diag_printf("Format successful\n");
+
+    if (force_erase) {
+        romupdate(0, (char **)NULL);
+    }
+}
+
+static void nand_info(int argc, char *argv[])
+{
+    u32 i, j = 0, len, ra;
+    bool flash_addr_set = false;
+    bool flash_len_set = false;
+    struct option_info opts[2];
+
+    init_opts(&opts[0], 'f', true, OPTION_ARG_TYPE_NUM,
+          (void *)&ra, (bool *)&flash_addr_set, "NAND FLASH memory byte address");
+    init_opts(&opts[1], 'l', true, OPTION_ARG_TYPE_NUM,
+          (void *)&len, (bool *)&flash_len_set, "length");
+
+    if (!scan_opts(argc, argv, 2, opts, 2, 0, 0, 0)) {
+        nand_usage("invalid arguments");
+        return;
+    }
+
+    if (nand_flash_index == -1) {
+        diag_printf("Can't find valid NAND flash: %d\n", __LINE__);
+        return;
+    }
+
+    if (argc == 2) {
+        diag_printf("\nType:\t\t %s\n", NF_VEND_INFO);
+        diag_printf("Total size:\t 0x%08x bytes (%d MB)\n", NF_DEV_SZ, NF_DEV_SZ/0x100000);
+        diag_printf("Total blocks:\t 0x%x (%d)\n", NF_BLK_CNT, NF_BLK_CNT);
+        diag_printf("Block size:\t 0x%x (%d)\n", NF_BLK_SZ, NF_BLK_SZ);
+        diag_printf("Page size:\t 0x%x (%d)\n", NF_PG_SZ, NF_PG_SZ);
+        diag_printf("Pages per block: 0x%x (%d)\n", NF_PG_PER_BLK, NF_PG_PER_BLK);
+        return;
+    }
+
+    if (!flash_addr_set) {
+        diag_printf("Wrong argument\n");
+        return;
+    }
+    if (!flash_len_set) {
+        len = NF_BLK_SZ;
+    }
+
+    if (ra % NF_BLK_SZ) {
+        diag_printf("error: non-block aligned\n");
+        return;
+    }
+    if (mxc_nfc_scan(false) == -1) {
+        return;
+    }
+    diag_printf("\n");
+    for (i = 0;
+         i < ((len + NF_BLK_SZ - 1) / NF_BLK_SZ);
+         i++) {
+
+        if (nfc_is_badblock(OFFSET_TO_BLOCK(ra), g_bbt)) {
+            diag_printf("block %d at offset 0x%x is bad\n",
+                        OFFSET_TO_BLOCK(ra), ra);
+            j++;
+        }
+        ra += NF_BLK_SZ;
+    }
+    diag_printf("==================================\n");
+    diag_printf("Found %d bad block(s) out of %d\n\n", j, i);
+}
+
+static void do_nand_cmds(int argc, char *argv[])
+{
+    struct cmd *cmd;
+
+    if (!mxcnfc_init_ok) {
+        diag_printf("\nWarning:NAND flash hasn't been initialized. Try \"factive nand\" first\n\n");
+        return;
+    }
+
+    if (argc < 2) {
+        nand_usage("too few arguments");
+        return;
+    }
+    if ((cmd = cmd_search(__NAND_cmds_TAB__, &__NAND_cmds_TAB_END__,
+                          argv[1])) != (struct cmd *)0) {
+        (cmd->fun)(argc, argv);
+        return;
+    }
+    nand_usage("unrecognized command");
+}
+
+/*!
+ * Display a memory region by 16-bit words
+ * @param pkt   pointer to the starting address of the memory
+ * @param len   byte length of the buffer to be displayed
+ */
+static void print_pkt_16(u16* pkt, u32 len)
+{
+    diag_printf("******************** %d bytes********************\n", len);
+    u32 i = 0, tempLen = (len + 1) / 2;
+
+    while(tempLen >= 0)
+        {
+        if(tempLen >= 8) {
+            diag_printf("[%03x-%03x] ", i*2, ((i*2)+14));
+            diag_printf("%04x %04x %04x %04x %04x %04x %04x %04x\n",
+                        pkt[i], pkt[i+1], pkt[i+2], pkt[i+3],
+                        pkt[i+4], pkt[i+5], pkt[i+6], pkt[i+7]);
+        }
+        else {
+            if (tempLen == 0) {
+                diag_printf("*************************************************\n");
+                return;
+            }
+            diag_printf("[%03x-%03x] ", i*2, ((i*2)+14));
+            switch(tempLen) {
+                case 1:
+                    diag_printf("%04x\n", pkt[i]);
+                    break;
+                case 2:
+                    diag_printf("%04x %04x\n", pkt[i], pkt[i+1]);
+                    break;
+                case 3:
+                    diag_printf("%04x %04x %04x\n", pkt[i], pkt[i+1], pkt[i+2]);
+                    break;
+                case 4:
+                    diag_printf("%04x %04x %04x %04x\n", pkt[i],pkt[i+1], pkt[i+2],pkt[i+3]);
+                    break;
+                case 5:
+                    diag_printf("%04x %04x %04x %04x %04x\n", pkt[i], pkt[i+1], pkt[i+2], pkt[i+3],pkt[i+4]);
+                    break;
+                case 6:
+                    diag_printf("%04x %04x %04x %04x %04x %04x\n", pkt[i], pkt[i+1], pkt[i+2], pkt[i+3],pkt[i+4],
+                             pkt[i+5]);
+                    break;
+                case 7:
+                    diag_printf("%04x %04x %04x %04x %04x %04x %04x\n", pkt[i], pkt[i+1], pkt[i+2], pkt[i+3],pkt[i+4],
+                             pkt[i+5], pkt[i+6]);
+                    break;
+            }
+        }
+        tempLen -= 8;
+        i += 8;
+    }
+}
+
+// addr = starting byte address within NAND flash
+static void print_page (u32 addr, bool spare_only)
+{
+    u32 blk_num = OFFSET_TO_BLOCK(addr), pg_num = OFFSET_TO_PAGE(addr);
+
+    if (spare_only) {
+        if(nfc_read_page_sp(addr) != 0) {
+            diag_printf("Error %d: uncorrectable. But still printing ...\n", __LINE__);
+        }
+    } else {
+        if(nfc_read_page(addr) != 0) {
+            diag_printf("Error %d: uncorrectable. But still printing ...\n", __LINE__);
+        }
+    }
+
+    diag_printf("\n============ Printing block(%d) page(%d)  ==============\n",
+                blk_num, pg_num);
+
+    diag_printf("<<<<<<<<< spare area >>>>>>>>>\n");
+    print_pkt_16((u16*)(NAND_SPAR_BUF0), 16);
+
+    if (!spare_only) {
+        diag_printf("<<<<<<<<< main area >>>>>>>>>\n");
+        print_pkt_16((u16*)(NAND_MAIN_BUF0), NF_PG_SZ);
+    }
+
+    diag_printf("\n");
+}
diff -urN -x CVS -x doc -x lwip_tcpip -x calmrisc16 -x calmrisc32 ecos_20050912/packages/devs/flash/intel/28fxxx/current/cdl/flash_intel_28fxxx.cdl ecos_base/packages/devs/flash/intel/28fxxx/current/cdl/flash_intel_28fxxx.cdl
--- ecos_20050912/packages/devs/flash/intel/28fxxx/current/cdl/flash_intel_28fxxx.cdl	2005-04-22 12:58:26.000000000 -0500
+++ ecos_base/packages/devs/flash/intel/28fxxx/current/cdl/flash_intel_28fxxx.cdl	2005-09-13 23:56:26.000000000 -0500
@@ -151,4 +151,15 @@
             is implemented using the same command status definitions."
 
     }
-}
+    
+    cdl_option CYGHWR_DEVS_FLASH_INTEL_28F256L18 {
+        display       "Intel 28F256L18 flash memory support"
+        default_value 0
+        implements    CYGHWR_IO_FLASH_BLOCK_LOCKING
+        implements    CYGINT_DEVS_FLASH_INTEL_VARIANTS
+        description   "
+            When this option is enabled, the Intel flash driver will be
+            able to recognize and handle the 28F256L18
+            part in the family."
+    }
+}
diff -urN -x CVS -x doc -x lwip_tcpip -x calmrisc16 -x calmrisc32 ecos_20050912/packages/devs/flash/intel/28fxxx/current/include/flash_28fxxx.inl ecos_base/packages/devs/flash/intel/28fxxx/current/include/flash_28fxxx.inl
--- ecos_20050912/packages/devs/flash/intel/28fxxx/current/include/flash_28fxxx.inl	2002-12-12 15:15:28.000000000 -0600
+++ ecos_base/packages/devs/flash/intel/28fxxx/current/include/flash_28fxxx.inl	2007-07-10 13:41:12.000000000 -0500
@@ -74,6 +74,8 @@
 typedef void (*call_t)(char* str, ...);
 extern void diag_printf(char* str, ...);
 call_t d_print = &diag_printf;
+#else
+#define d_print(fmt,args...)
 #endif
 
 //----------------------------------------------------------------------------
@@ -81,7 +83,9 @@
 #define FLASH_Read_ID                   FLASHWORD( 0x90 )
 #define FLASH_Reset                     FLASHWORD( 0xFF )
 #define FLASH_Program                   FLASHWORD( 0x40 )
-#define FLASH_Write_Buffer              FLASHWORD( 0xe8 )
+#define FLASH_Program_M18               FLASHWORD( 0x41 )
+#define FLASH_Write_Buffer              FLASHWORD( 0xE8 )
+#define FLASH_Write_Buffer_M18          FLASHWORD( 0xE9 )
 #define FLASH_Block_Erase               FLASHWORD( 0x20 )
 #define FLASH_Confirm                   FLASHWORD( 0xD0 )
 #define FLASH_Resume                    FLASHWORD( 0xD0 )
@@ -158,6 +162,7 @@
 //----------------------------------------------------------------------------
 // Functions that put the flash device into non-read mode must reside
 // in RAM.
+#ifndef MXCFLASH_SELECT_MULTI
 void flash_query(void* data) __attribute__ ((section (".2ram.flash_query")));
 int  flash_erase_block(void* block, unsigned int size) 
     __attribute__ ((section (".2ram.flash_erase_block")));
@@ -168,11 +173,22 @@
     __attribute__ ((section (".2ram.flash_lock_block")));
 int flash_unlock_block(void* block, int block_size, int blocks)
     __attribute__ ((section (".2ram.flash_unlock_block")));
+#else
+void norflash_query(void* data);
+int norflash_erase_block(void* block, unsigned int block_size);
+int norflash_program_buf(void* addr, void* data, int len,
+                      unsigned long block_mask, int buffer_size);
+int  norflash_lock_block(void* addr);
+int norflash_unlock_block(void* block, int block_size, int blocks);
+#endif //MXCFLASH_SELECT_MULTI
 
 //----------------------------------------------------------------------------
 // Initialize driver details
-int
-flash_hwr_init(void)
+#ifndef MXCFLASH_SELECT_MULTI
+int flash_hwr_init(void)
+#else
+int norflash_hwr_init(void)
+#endif
 {
     int i;
     flash_data_t id[2];
@@ -204,8 +220,11 @@
 
 //----------------------------------------------------------------------------
 // Map a hardware status to a package error
-int
-flash_hwr_map_error(int e)
+#ifndef MXCFLASH_SELECT_MULTI
+int flash_hwr_map_error(int e)
+#else
+int norflash_hwr_map_error(int e)
+#endif
 {
     return e;
 }
@@ -213,8 +232,11 @@
 
 //----------------------------------------------------------------------------
 // See if a range of FLASH addresses overlaps currently running code
-bool
-flash_code_overlaps(void *start, void *end)
+#ifndef MXCFLASH_SELECT_MULTI
+bool flash_code_overlaps(void *start, void *end)
+#else
+bool norflash_code_overlaps(void *start, void *end)
+#endif
 {
     extern unsigned char _stext[], _etext[];
 
@@ -231,8 +253,11 @@
 // device(s) in series. It is assumed that any devices in series
 // will be of the same type.
 
-void
-flash_query(void* data)
+#ifndef MXCFLASH_SELECT_MULTI
+void flash_query(void* data)
+#else
+void norflash_query(void* data)
+#endif
 {
     volatile flash_data_t *ROM;
     flash_data_t* id = (flash_data_t*) data;
@@ -261,8 +286,11 @@
 
 //----------------------------------------------------------------------------
 // Erase Block
-int
-flash_erase_block(void* block, unsigned int block_size)
+#ifndef MXCFLASH_SELECT_MULTI
+int flash_erase_block(void* block, unsigned int block_size)
+#else
+int norflash_erase_block(void* block, unsigned int block_size)
+#endif
 {
     int res = FLASH_ERR_OK;
     int timeout;
@@ -294,16 +322,16 @@
         ROM[0] = FLASH_Clear_Status;
 
         // Erase block
-        ROM[0] = FLASH_Block_Erase;
+        *b_v = FLASH_Block_Erase;
         *b_v = FLASH_Confirm;
 
-        timeout = 5000000;
-        while(((stat = ROM[0]) & FLASH_Status_Ready) != FLASH_Status_Ready) {
+        timeout = 50000000;
+        while(((stat = *b_v) & FLASH_Status_Ready) != FLASH_Status_Ready) {
             if (--timeout == 0) break;
         }
     
         // Restore ROM to "normal" mode
-        ROM[0] = FLASH_Reset;
+        *b_v = FLASH_Reset;
 
         if (stat & FLASH_ErrorMask) {
             if (!(stat & FLASH_ErrorErase)) {
@@ -340,9 +368,14 @@
 
 //----------------------------------------------------------------------------
 // Program Buffer
-int
-flash_program_buf(void* addr, void* data, int len,
+
+#ifndef MXCFLASH_SELECT_MULTI
+int flash_program_buf(void* addr, void* data, int len,
                   unsigned long block_mask, int buffer_size)
+#else
+int norflash_program_buf(void* addr, void* data, int len,
+                     unsigned long block_mask, int buffer_size)
+#endif
 {
     flash_data_t stat = 0;
     int timeout;
@@ -354,11 +387,77 @@
     volatile flash_data_t* data_p = (flash_data_t*) data;
 
     int res = FLASH_ERR_OK;
-
+    
     // Base address of device(s) being programmed. 
     ROM = FLASH_P2V((unsigned long)addr & flash_dev_info->base_mask);
     BA = FLASH_P2V((unsigned long)addr & ~(flash_dev_info->block_size - 1));
 
+#ifdef CYGPKG_HAL_ARM_MXC30031ADS
+    d_print("ROM=%p, BA=%p\n", ROM, BA);
+    ROM = BA;
+
+    CYGHWR_FLASH_WRITE_ENABLE();
+    
+    // Clear any error conditions
+    BA[0] = FLASH_Clear_Status;
+    addr_v = FLASH_P2V(addr_p);
+    d_print("%s: len=0x%x, *addr_v=0x%x, *data_p=0x%x, addr_v=%p, addr_p=%p\n", 
+             __FUNCTION__, len, *addr_v, *data_p, addr_v, addr_p);
+
+    while (len > 0) {
+        int wc = (len >= 0x400) ? 0x400: len;
+        len -= 0x400;
+
+        wc = (wc + 1) & ~0x1;
+
+        timeout = 50000000;
+        do {
+            *addr_v = FLASH_Write_Buffer_M18;
+            if (--timeout == 0) {
+                res = FLASH_ERR_DRV_TIMEOUT;
+                d_print("flash_program_buf0: addr_v=0x%x, *addr_v=0x%x, *data_p=0x%x\n", 
+                         addr_v, *addr_v, *data_p);
+                goto bad;
+            }
+        } while(((stat = *addr_v) & FLASH_Status_Ready) != FLASH_Status_Ready);
+
+        *addr_v = (wc / 2) - 1;
+        //memcpy(addr_v, data_p, wc);
+        for (; wc > 0; wc -= 2) {
+            *addr_v++ = *data_p++;
+        }
+
+        // confirm
+        *addr_p = FLASH_Confirm;
+        timeout = 50000000;
+        while(((stat = *addr_p) & FLASH_Status_Ready) != FLASH_Status_Ready) {
+            if (--timeout == 0) {
+                res = FLASH_ERR_DRV_TIMEOUT;
+                d_print("flash_program_buf0: addr_v=0x%x, *addr_v=0x%x, *data_p=0x%x\n", 
+                         addr_v, *addr_v, *data_p);
+                goto bad;
+            }
+        }
+        if (stat & FLASH_ErrorMask) {
+            if (!(stat & FLASH_ErrorProgram))
+                res = FLASH_ERR_HWR;    // Unknown error
+            else {
+                if (stat & FLASH_ErrorLowVoltage)
+                    res = FLASH_ERR_LOW_VOLTAGE;
+                else if (stat & FLASH_ErrorLocked)
+                    res = FLASH_ERR_PROTECT;
+                else
+                    res = FLASH_ERR_PROGRAM;
+            }
+            break;
+        }
+        addr_p[0] = FLASH_Clear_Status;
+        addr_p[0] = FLASH_Reset;
+
+        addr_p += 512;
+    }
+#else //CYGPKG_HAL_ARM_MXC30031ADS
+
     CYGHWR_FLASH_WRITE_ENABLE();
     
     // Clear any error conditions
@@ -376,10 +475,10 @@
             if (wc > len) wc = len;
             len -= wc;
             wc = wc / ((CYGNUM_FLASH_WIDTH/8)*CYGNUM_FLASH_INTERLEAVE);  // Word count
-            timeout = 5000000;
+            timeout = 50000000;
             
             *BA = FLASH_Write_Buffer;
-            while(((stat = ROM[0]) & FLASH_Status_Ready) != FLASH_Status_Ready) {
+            while(((stat = BA[0]) & FLASH_Status_Ready) != FLASH_Status_Ready) {
                 if (--timeout == 0) {
                     res = FLASH_ERR_DRV_TIMEOUT;
                     goto bad;
@@ -393,9 +492,9 @@
             }
             *BA = FLASH_Confirm;
             
-            ROM[0] = FLASH_Read_Status;
-            timeout = 5000000;
-            while(((stat = ROM[0]) & FLASH_Status_Ready) != FLASH_Status_Ready) {
+            *BA = FLASH_Read_Status;
+            timeout = 50000000;
+            while(((stat = BA[0]) & FLASH_Status_Ready) != FLASH_Status_Ready) {
                 if (--timeout == 0) {
                     res = FLASH_ERR_DRV_TIMEOUT;
                     goto bad;
@@ -407,12 +506,14 @@
 
     while (len > 0) {
         addr_v = FLASH_P2V(addr_p++);
-        ROM[0] = FLASH_Program;
+			*addr_v = FLASH_Program;
         *addr_v = *data_p;
-        timeout = 5000000;
-        while(((stat = ROM[0]) & FLASH_Status_Ready) != FLASH_Status_Ready) {
+        timeout = 50000000;
+        while(((stat = *addr_v) & FLASH_Status_Ready) != FLASH_Status_Ready) {
             if (--timeout == 0) {
                 res = FLASH_ERR_DRV_TIMEOUT;
+                d_print("flash_program_buf0: addr_v=0x%x, *addr_v=0x%x, *data_p=0x%x\n", 
+                         addr_v, *addr_v, *data_p);
                 goto bad;
             }
         }
@@ -432,12 +533,14 @@
         ROM[0] = FLASH_Clear_Status;
         ROM[0] = FLASH_Reset;
         if (*addr_v != *data_p++) {
+        d_print("flash_program_buf: addr_v=0x%x, *addr_v=0x%x, *data_p=0x%x\n", 
+                 addr_v, *addr_v, *data_p);
             res = FLASH_ERR_DRV_VERIFY;
             break;
         }
         len -= sizeof( flash_data_t );
     }
-
+#endif //CYGPKG_HAL_ARM_MXC30031ADS
     // Restore ROM to "normal" mode
  bad:
     ROM[0] = FLASH_Reset;            
@@ -452,8 +555,11 @@
 #ifdef CYGHWR_IO_FLASH_BLOCK_LOCKING
 //----------------------------------------------------------------------------
 // Lock block
-int
-flash_lock_block(void* block)
+#ifndef MXCFLASH_SELECT_MULTI
+int flash_lock_block(void* block)
+#else
+int norflash_lock_block(void* block)
+#endif
 {
     volatile flash_data_t *ROM;
     int res = FLASH_ERR_OK;
@@ -467,9 +573,7 @@
     if (!flash_dev_info->locking)
         return res;
 
-#ifdef DEBUG
     d_print("flash_lock_block %08x\n", block);
-#endif
 
     ROM = (volatile flash_data_t*)((unsigned long)block & flash_dev_info->base_mask);
 
@@ -478,22 +582,25 @@
                  (flash_dev_info->bootblocks[0] == ((unsigned long)block - (unsigned long)ROM)));
     if (bootblock) {
         len = flash_dev_info->bootblocks[len_ix++];
+        d_print("\nboot block\n");
     } else {
         len = flash_dev_info->block_size;
     }
 
     CYGHWR_FLASH_WRITE_ENABLE();
-    
+
     while (len > 0) {
         b_v = FLASH_P2V(b_p);
-
+#ifdef CYGPKG_HAL_ARM_MXC30031ADS
+        ROM = b_v;
+#endif
         // Clear any error conditions
         ROM[0] = FLASH_Clear_Status;
 
         // Set lock bit
         *b_v = FLASH_Set_Lock;
         *b_v = FLASH_Set_Lock_Confirm;  // Confirmation
-        while(((state = ROM[0]) & FLASH_Status_Ready) != FLASH_Status_Ready) {
+        while(((state = *b_v) & FLASH_Status_Ready) != FLASH_Status_Ready) {
             if (--timeout == 0) {
                 res = FLASH_ERR_DRV_TIMEOUT;
                 break;
@@ -525,8 +632,11 @@
 //----------------------------------------------------------------------------
 // Unlock block
 
-int
-flash_unlock_block(void* block, int block_size, int blocks)
+#ifndef MXCFLASH_SELECT_MULTI
+int flash_unlock_block(void* block, int block_size, int blocks)
+#else
+int norflash_unlock_block(void* block, int block_size, int blocks)
+#endif
 {
     volatile flash_data_t *ROM;
     int res = FLASH_ERR_OK;
@@ -653,6 +763,7 @@
                  (flash_dev_info->bootblocks[0] == ((unsigned long)block - (unsigned long)ROM)));
     if (bootblock) {
         len = flash_dev_info->bootblocks[len_ix++];
+        d_print("\nboot block\n");
     } else {
         len = flash_dev_info->block_size;
     }
@@ -664,12 +775,15 @@
         b_v = FLASH_P2V(b_p);
 
         // Clear any error conditions
+#ifdef CYGPKG_HAL_ARM_MXC30031ADS
+        ROM = b_v;
+#endif
         ROM[0] = FLASH_Clear_Status;
 
         // Clear lock bit
         *b_v = FLASH_Clear_Lock;
         *b_v = FLASH_Clear_Lock_Confirm;  // Confirmation
-        while(((state = ROM[0]) & FLASH_Status_Ready) != FLASH_Status_Ready) {
+        while(((state = *b_v) & FLASH_Status_Ready) != FLASH_Status_Ready) {
             if (--timeout == 0) {
                 res = FLASH_ERR_DRV_TIMEOUT;
                 break;
diff -urN -x CVS -x doc -x lwip_tcpip -x calmrisc16 -x calmrisc32 ecos_20050912/packages/devs/flash/intel/28fxxx/current/include/flash_28fxxx_parts.inl ecos_base/packages/devs/flash/intel/28fxxx/current/include/flash_28fxxx_parts.inl
--- ecos_20050912/packages/devs/flash/intel/28fxxx/current/include/flash_28fxxx_parts.inl	2005-04-22 12:58:26.000000000 -0500
+++ ecos_base/packages/devs/flash/intel/28fxxx/current/include/flash_28fxxx_parts.inl	2007-05-31 00:07:00.000000000 -0500
@@ -194,7 +194,7 @@
         banked     : false
     },
 #endif
-	
+
 #ifdef CYGHWR_DEVS_FLASH_INTEL_28F160S5
     {   // 28F160S5
         device_id  : FLASHWORD(0x00d0),
@@ -246,7 +246,57 @@
     },
 #endif
 
-#endif // 16 bit devices
+#ifdef CYGHWR_DEVS_FLASH_INTEL_28F256L18
+    {   // 28F256L18-T
+        device_id  : FLASHWORD(0x880d),
+        block_size : 0x20000 * CYGNUM_FLASH_INTERLEAVE,
+        block_count: 256,
+        device_size:  0x2000000 * CYGNUM_FLASH_INTERLEAVE,
+        base_mask  : ~(0x2000000 * CYGNUM_FLASH_INTERLEAVE - 1),
+        locking    : true,
+        buffered_w : true,
+        bootblock  : true,
+        bootblocks : {0x1fe0000 * CYGNUM_FLASH_INTERLEAVE,
+                       0x008000 * CYGNUM_FLASH_INTERLEAVE,
+                       0x008000 * CYGNUM_FLASH_INTERLEAVE,
+                       0x008000 * CYGNUM_FLASH_INTERLEAVE,
+                       0x008000 * CYGNUM_FLASH_INTERLEAVE,
+                       0
+                     },
+        banked     : false
+    },
+    {   // 28F256L18-B
+        device_id  : FLASHWORD(0x8810),
+        block_size : 0x20000 * CYGNUM_FLASH_INTERLEAVE,
+        block_count: 256,
+        device_size:  0x2000000 * CYGNUM_FLASH_INTERLEAVE,
+        base_mask  : ~(0x2000000 * CYGNUM_FLASH_INTERLEAVE - 1),
+        locking    : true,
+        buffered_w : true,
+        bootblock  : true,
+        bootblocks : { 0x000000 * CYGNUM_FLASH_INTERLEAVE,
+                       0x008000 * CYGNUM_FLASH_INTERLEAVE,
+                       0x008000 * CYGNUM_FLASH_INTERLEAVE,
+                       0x008000 * CYGNUM_FLASH_INTERLEAVE,
+                       0x008000 * CYGNUM_FLASH_INTERLEAVE,
+                       0
+                     },
+        banked     : false
+    },
+    {   // M18
+        device_id  : FLASHWORD(0x887E),
+        block_size : 0x40000 * CYGNUM_FLASH_INTERLEAVE,
+        block_count: 256,
+        device_size:  0x4000000 * CYGNUM_FLASH_INTERLEAVE,
+        base_mask  : ~(0x4000000 * CYGNUM_FLASH_INTERLEAVE - 1),
+        locking    : true,
+        buffered_w : true,
+        bootblock  : false,
+        banked     : false
+    },
+
+#endif
 
+#endif // 16 bit devices
 
-#endif // CYGONCE_DEVS_FLASH_INTEL_28FXXX_PARTS_INL
+#endif // CYGONCE_DEVS_FLASH_INTEL_28FXXX_PARTS_INL
diff -urN -x CVS -x doc -x lwip_tcpip -x calmrisc16 -x calmrisc32 ecos_20050912/packages/devs/flash/intel/strata/current/cdl/flash_strata.cdl ecos_base/packages/devs/flash/intel/strata/current/cdl/flash_strata.cdl
--- ecos_20050912/packages/devs/flash/intel/strata/current/cdl/flash_strata.cdl	2004-08-21 03:37:48.000000000 -0500
+++ ecos_base/packages/devs/flash/intel/strata/current/cdl/flash_strata.cdl	2005-09-13 23:56:27.000000000 -0500
@@ -89,4 +89,4 @@
         }
     }
 }
-
+
diff -urN -x CVS -x doc -x lwip_tcpip -x calmrisc16 -x calmrisc32 ecos_20050912/packages/devs/flash/intel/strata/current/src/flash_unlock_block.c ecos_base/packages/devs/flash/intel/strata/current/src/flash_unlock_block.c
--- ecos_20050912/packages/devs/flash/intel/strata/current/src/flash_unlock_block.c	2004-08-21 03:37:48.000000000 -0500
+++ ecos_base/packages/devs/flash/intel/strata/current/src/flash_unlock_block.c	2005-09-13 23:56:27.000000000 -0500
@@ -139,4 +139,4 @@
     ROM[0] = FLASH_Reset;
 
     return stat;
-}
+}
diff -urN -x CVS -x doc -x lwip_tcpip -x calmrisc16 -x calmrisc32 ecos_20050912/packages/devs/flash/intel/strata/current/src/strata.c ecos_base/packages/devs/flash/intel/strata/current/src/strata.c
--- ecos_20050912/packages/devs/flash/intel/strata/current/src/strata.c	2004-01-26 17:59:10.000000000 -0600
+++ ecos_base/packages/devs/flash/intel/strata/current/src/strata.c	2005-09-13 23:56:27.000000000 -0500
@@ -107,7 +107,7 @@
         buffer_size = 0;
 #else // CYGOPT_FLASH_IS_BOOTBLOCK
          && (strncmp(qp->id, "QRY", 3) == 0)) {
-        num_regions = _si(qp->num_regions)+1;
+        num_regions = _si(qp->num_regions)+2;
         region_size = _si(qp->region_size)*256;       
         if (_si(qp->buffer_size)) {
             buffer_size = CYGNUM_FLASH_DEVICES << _si(qp->buffer_size);
@@ -184,4 +184,4 @@
              ((unsigned long)&_etext < (unsigned long)end)));
 }
 
-// EOF strata.c
+// EOF strata.c
diff -urN -x CVS -x doc -x lwip_tcpip -x calmrisc16 -x calmrisc32 ecos_20050912/packages/devs/i2c/arm/mxc/current/cdl/mxc_i2c.cdl ecos_base/packages/devs/i2c/arm/mxc/current/cdl/mxc_i2c.cdl
--- ecos_20050912/packages/devs/i2c/arm/mxc/current/cdl/mxc_i2c.cdl	1969-12-31 18:00:00.000000000 -0600
+++ ecos_base/packages/devs/i2c/arm/mxc/current/cdl/mxc_i2c.cdl	2007-11-29 16:04:56.000000000 -0600
@@ -0,0 +1,55 @@
+# ====================================================================
+#
+#      mxc_i2c.cdl
+#
+#      A Freescale MXC I2C package.
+#
+# ====================================================================
+#####ECOSGPLCOPYRIGHTBEGIN####
+## -------------------------------------------
+## This file is part of eCos, the Embedded Configurable Operating System.
+## Copyright (C) 1998, 1999, 2000, 2001, 2002, 2004 Red Hat, Inc.
+## Copyright (C) 2004 eCosCentric, Ltd
+##
+## eCos is free software; you can redistribute it and/or modify it under
+## the terms of the GNU General Public License as published by the Free
+## Software Foundation; either version 2 or (at your option) any later version.
+##
+## eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+## WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+## for more details.
+##
+## You should have received a copy of the GNU General Public License along
+## with eCos; if not, write to the Free Software Foundation, Inc.,
+## 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+##
+## As a special exception, if other files instantiate templates or use macros
+## or inline functions from this file, or you compile this file and link it
+## with other works to produce a work based on this file, this file does not
+## by itself cause the resulting work to be covered by the GNU General Public
+## License. However the source code for this file must still be made available
+## in accordance with section (3) of the GNU General Public License.
+##
+## This exception does not invalidate any other reasons why a work based on
+## this file might be covered by the GNU General Public License.
+##
+## -------------------------------------------
+#####ECOSGPLCOPYRIGHTEND####
+# ====================================================================
+######DESCRIPTIONBEGIN####
+#
+# Author(s):      Kevin Zhang
+# Contributors:
+# Date:           2006-08-23
+#
+#####DESCRIPTIONEND####
+# ====================================================================
+
+cdl_package CYGPKG_DEVS_MXC_I2C {
+    display     "I2C driver for FSL MXC-based platforms"
+
+    compile     -library=libextras.a mxc_i2c.c
+    
+    include_dir   cyg/io
+}
diff -urN -x CVS -x doc -x lwip_tcpip -x calmrisc16 -x calmrisc32 ecos_20050912/packages/devs/i2c/arm/mxc/current/include/mxc_i2c.h ecos_base/packages/devs/i2c/arm/mxc/current/include/mxc_i2c.h
--- ecos_20050912/packages/devs/i2c/arm/mxc/current/include/mxc_i2c.h	1969-12-31 18:00:00.000000000 -0600
+++ ecos_base/packages/devs/i2c/arm/mxc/current/include/mxc_i2c.h	2007-11-29 16:04:56.000000000 -0600
@@ -0,0 +1,70 @@
+//==========================================================================
+//
+//      mxc_i2c.h
+//
+//      I2C support on Freescale MXC platforms
+//
+//==========================================================================
+//####ECOSGPLCOPYRIGHTBEGIN####
+// -------------------------------------------
+// This file is part of eCos, the Embedded Configurable Operating System.
+// Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+//
+// eCos is free software; you can redistribute it and/or modify it under
+// the terms of the GNU General Public License as published by the Free
+// Software Foundation; either version 2 or (at your option) any later version.
+//
+// eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with eCos; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+//
+// As a special exception, if other files instantiate templates or use macros
+// or inline functions from this file, or you compile this file and link it
+// with other works to produce a work based on this file, this file does not
+// by itself cause the resulting work to be covered by the GNU General Public
+// License. However the source code for this file must still be made available
+// in accordance with section (3) of the GNU General Public License.
+//
+// This exception does not invalidate any other reasons why a work based on
+// this file might be covered by the GNU General Public License.
+//
+// Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+// at http://sources.redhat.com/ecos/ecos-license/
+// -------------------------------------------
+//####ECOSGPLCOPYRIGHTEND####
+//==========================================================================
+
+#ifndef __MXC_I2C_H__
+#define __MXC_I2C_H__
+
+#define I2C_AR                      0x0
+#define I2C_IFDR                    0x4
+#define I2C_I2CR                    0x8
+#define I2C_I2SR                    0xC
+#define I2C_I2DR                    0x10
+
+#define I2C_I2CR_IEN                (1 << 7)
+#define I2C_I2CR_IIEN               (1 << 6)
+#define I2C_I2CR_MSTA               (1 << 5)
+#define I2C_I2CR_MTX                (1 << 4)
+#define I2C_I2CR_TXAK               (1 << 3)
+#define I2C_I2CR_RSTA               (1 << 2)
+
+#define I2C_I2SR_ICF                (1 << 7)
+#define I2C_I2SR_IAAS               (1 << 6)
+#define I2C_I2SR_IBB                (1 << 5)
+#define I2C_I2SR_IAL                (1 << 4)
+#define I2C_I2SR_SRW                (1 << 2)
+#define I2C_I2SR_IIF                (1 << 1)
+#define I2C_I2SR_RXAK               (1 << 0)
+
+int i2c_init(unsigned int base, unsigned int baud);
+unsigned int pmic_reg(unsigned int reg, unsigned int val, unsigned int write);
+unsigned int i2c_xchg_single(unsigned int data, unsigned int base);
+
+#endif				/* __MXC_I2C_H__ */
diff -urN -x CVS -x doc -x lwip_tcpip -x calmrisc16 -x calmrisc32 ecos_20050912/packages/devs/i2c/arm/mxc/current/src/mxc_i2c.c ecos_base/packages/devs/i2c/arm/mxc/current/src/mxc_i2c.c
--- ecos_20050912/packages/devs/i2c/arm/mxc/current/src/mxc_i2c.c	1969-12-31 18:00:00.000000000 -0600
+++ ecos_base/packages/devs/i2c/arm/mxc/current/src/mxc_i2c.c	2007-11-29 16:04:56.000000000 -0600
@@ -0,0 +1,593 @@
+//==========================================================================
+//
+//      mxc_i2c.c
+//
+//      I2C support on Freescale MXC platforms
+//
+//==========================================================================
+//####ECOSGPLCOPYRIGHTBEGIN####
+// -------------------------------------------
+// This file is part of eCos, the Embedded Configurable Operating System.
+// Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+//
+// eCos is free software; you can redistribute it and/or modify it under
+// the terms of the GNU General Public License as published by the Free
+// Software Foundation; either version 2 or (at your option) any later version.
+//
+// eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with eCos; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+//
+// As a special exception, if other files instantiate templates or use macros
+// or inline functions from this file, or you compile this file and link it
+// with other works to produce a work based on this file, this file does not
+// by itself cause the resulting work to be covered by the GNU General Public
+// License. However the source code for this file must still be made available
+// in accordance with section (3) of the GNU General Public License.
+//
+// This exception does not invalidate any other reasons why a work based on
+// this file might be covered by the GNU General Public License.
+//
+// Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+// at http://sources.redhat.com/ecos/ecos-license/
+// -------------------------------------------
+//####ECOSGPLCOPYRIGHTEND####
+//==========================================================================
+
+#include <redboot.h>
+#include <stdlib.h>
+#include <pkgconf/hal.h>
+#include <cyg/hal/hal_arch.h>
+#include <cyg/hal/hal_cache.h>
+#include <cyg/hal/hal_io.h>
+
+#include <cyg/hal/fsl_board.h>
+#include <cyg/io/mxc_i2c.h>
+
+extern void mxc_i2c_init(unsigned int module_base);
+
+//#define MXC_I2C_DEBUG
+#undef MXC_I2C_DEBUG
+
+#ifdef MXC_I2C_DEBUG
+#define diag_printf1    diag_printf
+#else
+#define diag_printf1(fmt,args...)
+#endif
+
+struct clk_div_table {
+	int reg_value;
+	int div;
+};
+
+static const struct clk_div_table i2c_clk_table[] = {
+	{0x20, 22}, {0x21, 24}, {0x22, 26}, {0x23, 28},
+	{0, 30}, {1, 32}, {0x24, 32}, {2, 36},
+	{0x25, 36}, {0x26, 40}, {3, 42}, {0x27, 44},
+	{4, 48}, {0x28, 48}, {5, 52}, {0x29, 56},
+	{6, 60}, {0x2A, 64}, {7, 72}, {0x2B, 72},
+	{8, 80}, {0x2C, 80}, {9, 88}, {0x2D, 96},
+	{0xA, 104}, {0x2E, 112}, {0xB, 128}, {0x2F, 128},
+	{0xC, 144}, {0xD, 160}, {0x30, 160}, {0xE, 192},
+	{0x31, 192}, {0x32, 224}, {0xF, 240}, {0x33, 256},
+	{0x10, 288}, {0x11, 320}, {0x34, 320}, {0x12, 384},
+	{0x35, 384}, {0x36, 448}, {0x13, 480}, {0x37, 512},
+	{0x14, 576}, {0x15, 640}, {0x38, 640}, {0x16, 768},
+	{0x39, 768}, {0x3A, 896}, {0x17, 960}, {0x3B, 1024},
+	{0x18, 1152}, {0x19, 1280}, {0x3C, 1280}, {0x1A, 1536},
+	{0x3D, 1536}, {0x3E, 1792}, {0x1B, 1920}, {0x3F, 2048},
+	{0x1C, 2304}, {0x1D, 2560}, {0x1E, 3072}, {0x1F, 3840},
+	{0, 0}
+};
+
+extern unsigned int i2c_base_addr[];
+extern unsigned int i2c_num;
+
+#define ERR_TX		    -1
+#define ERR_RX		    -2
+#define ERR_ARB_LOST	-3
+#define ERR_NO_ACK	    -4
+#define ERR_XFER	    -5
+#define ERR_RX_ACK      -6
+
+static inline int wait_till_busy(unsigned int base)
+{
+	while((readw(base + I2C_I2SR) & I2C_I2SR_IBB) == 0) {
+		if (readw(base + I2C_I2SR) & I2C_I2SR_IAL) {
+            diag_printf("Error: arbitration lost!\n");
+			return ERR_ARB_LOST;
+        }
+	}
+	return 0;
+}
+
+#define I2C_WRITE   0
+#define I2C_READ    1
+
+struct mxc_i2c_data {
+	unsigned char *data;
+	unsigned int sz;
+};
+
+static unsigned int g_i2c_addr;
+static unsigned int g_dev_addr_width, g_dev_reg_width;
+static unsigned int g_dev_address;
+static unsigned char g_dev_value[4];
+static unsigned int g_i2c_nr = -1;
+
+static struct mxc_i2c_data g_dev_addr;
+static struct mxc_i2c_data g_dev_val;
+
+static inline int is_bus_free(unsigned int base)
+{
+    return ((readw(base + I2C_I2SR) & I2C_I2SR_IBB) == 0);
+}
+
+#define ASSERT_NO_ARBITRATION_LOST(stat)  \
+{ \
+	if (stat & I2C_I2SR_IAL) { \
+		diag_printf("Error %d: Arbitration lost\n", __LINE__); \
+		return ERR_ARB_LOST; \
+	} \
+}
+
+#define WAIT_RXAK_LOOPS     1000000
+
+static inline unsigned short wait_op_done(unsigned int base, int is_tx)
+{
+    volatile unsigned short v;
+    int i = WAIT_RXAK_LOOPS;
+
+    while ((((v = readw(base + I2C_I2SR)) & I2C_I2SR_IIF) == 0 ||
+           (v & I2C_I2SR_ICF) == 0) && --i > 0) {
+        if (v & I2C_I2SR_IAL) {
+            diag_printf("Error %d: Arbitration lost\n", __LINE__);
+            return ERR_ARB_LOST;
+        }
+
+    }
+    if (i <= 0) {
+        diag_printf("Error: timeout unexpected\n");
+        return -1;
+    }
+    if (is_tx) {
+        if (v & I2C_I2SR_IAL) {
+            diag_printf("Error %d: Arbitration lost\n", __LINE__);
+            return ERR_ARB_LOST;
+        }
+    }
+    return 0;
+}
+
+//
+// For master TX, always expect a RXAK signal to be set!
+static int tx_byte(unsigned char *data, unsigned int base)
+{
+    diag_printf1("%s(data=0x%02x, base=0x%x)\n", __FUNCTION__, *data, base);
+
+    // clear both IAL and IIF bits
+    writew(0, base + I2C_I2SR);
+
+    writew(*data, base + I2C_I2DR);
+    
+    if (wait_op_done(base, 1) != 0)
+        return -1;
+
+    return 0;
+}
+
+// For master RX
+static int rx_bytes(unsigned char *data, unsigned int base, int sz)
+{
+    unsigned short i2cr;
+    int i;
+
+    for (i = 0; sz > 0; sz--, i++) {
+        if (wait_op_done(base, 0) != 0)
+            return -1;
+
+        // clear both IAL and IIF bits
+        writew(0, base + I2C_I2SR);
+
+        // the next two if-statements setup for the next read control register value
+        if (sz == 1) {
+            // last byte --> generate STOP
+            i2cr = readw(base + I2C_I2CR);
+            writew(i2cr & ~(I2C_I2CR_MSTA | I2C_I2CR_MTX), base + I2C_I2CR);
+        }
+        if (sz == 2) {
+            // 2nd last byte --> set TXAK bit to NOT generate ACK
+            i2cr = readw(base + I2C_I2CR);
+            writew(i2cr | I2C_I2CR_TXAK, base + I2C_I2CR);
+        }
+
+        // read the true data
+        data[i] = readw(base + I2C_I2DR);
+        diag_printf1("OK 0x%02x\n", data[i]);
+    }
+    return 0;
+}
+
+static int i2c_xfer(unsigned int i2c_nr,
+                    unsigned char dev_addr,
+                    struct mxc_i2c_data *dev_reg, 
+                    struct mxc_i2c_data *dev_reg_val,
+                    int dir)
+{
+	unsigned char dev_reg_sz = dev_reg->sz, dev_reg_val_sz = dev_reg_val->sz;
+    unsigned int base = i2c_base_addr[i2c_nr];
+    unsigned char i, data;
+    unsigned short i2cr;
+    int ret = 0;
+
+    if (dev_reg_val_sz == 0 || dev_reg_sz == 0) {
+        diag_printf("Invalid dev_reg_val_sz=%d, dev_reg_sz=%d\n",
+                    dev_reg_val_sz, dev_reg_sz);
+        return -1;
+    }
+
+    // reset and enable I2C
+    writew(0, base + I2C_I2CR);
+    writew(I2C_I2CR_IEN, base + I2C_I2CR);
+
+    // Step 1: generate START signal
+	// 1.1 make sure bus is free
+    if (!is_bus_free(base)) {
+        diag_printf("I2C %d is busy\n", i2c_nr);
+		return -1;
+	}
+	// 1.2 clear both IAL and IIF bits
+    writew(0, base + I2C_I2SR);
+	
+    // 1.3 assert START signal and also indicate TX mode
+    i2cr = I2C_I2CR_IEN | I2C_I2CR_MSTA | I2C_I2CR_MTX;
+	writew(i2cr, base + I2C_I2CR);
+	
+	// 1.4 make sure bus is busy after the START signal
+    if (wait_till_busy(base) != 0) {
+		diag_printf("I2C bus never gets busy after START. TX failed\n");
+		return ERR_TX;
+	}
+	
+	// Step 2: send slave address + read/write at the LSB
+	data = (dev_addr << 1) | I2C_WRITE;
+    if (tx_byte(&data, base) != 0) {
+        return -1;
+    }
+
+    // Step 3: send I2C device register address
+	for (i = 0; dev_reg_sz > 0; dev_reg_sz--, i++) {
+        data = dev_reg->data[i];
+        diag_printf1("sending I2C=0x%x device register: data=0x%x, byte %d\n",
+                     base, data, i);
+        if (tx_byte(&data, base) != 0) {
+            return -1;
+        }
+    }
+    // Step 4: read/write data
+    if (dir == I2C_READ) {
+        // do repeat-start
+        i2cr = readw(base + I2C_I2CR);
+        writew(i2cr | I2C_I2CR_RSTA, base + I2C_I2CR);
+
+        // send slave address again, but indicate read operation
+        data = (dev_addr << 1) | I2C_READ;
+        if (tx_byte(&data, base) != 0) {
+            return -1;
+        }
+
+        // change to receive mode
+        i2cr = readw(base + I2C_I2CR);
+        if (dev_reg_val_sz == 1) {
+            // if only one byte to read, make sure don't send ack
+            i2cr |= I2C_I2CR_TXAK;
+        }
+        writew(i2cr & ~I2C_I2CR_MTX, base + I2C_I2CR);
+        // dummy read
+        readw(base + I2C_I2DR);
+//        hal_delay_us(1);
+
+        // now reading ...
+        if (rx_bytes(dev_reg_val->data, base, dev_reg_val_sz) != 0) {
+            diag_printf("Error: failed to receive\n");
+            return -1;
+        }
+    } else {
+        // I2C_WRITE
+        for (i = 0; dev_reg_val_sz > 0; dev_reg_val_sz--, i++) {
+            // send device register value
+            data = dev_reg_val->data[i];
+            if ((ret = tx_byte(&data, base)) != 0) {
+                diag_printf("Error: failed to tx byte: 0x%x\n", data);
+                break;
+            }
+        }
+        // generate STOP by clearing MSTA bit
+        writew(I2C_I2CR_IEN | I2C_I2CR_MTX, base + I2C_I2CR);
+    }
+
+	return ret;
+}
+
+/*!
+ * Initialize and enable a i2c module -- mainly enable the I2C clock, module
+ * itself and the I2C clock prescaler.
+ *
+ * @param   base        base address of i2c module (also assigned for I2Cx_CLK)
+ * @param   baue        the desired data rate
+ *
+ * @return              0 if successful; non-zero otherwise
+ */
+int i2c_init(unsigned int base, unsigned int baud)
+{
+    unsigned int clock = get_main_clock(IPG_PER_CLK);
+    int div = clock / baud;
+    struct clk_div_table *p = (struct clk_div_table *)&i2c_clk_table[0];
+
+    g_dev_addr.data = (unsigned char *) &g_dev_address;
+    g_dev_addr.sz = g_dev_addr_width;
+    g_dev_val.data = g_dev_value;
+    g_dev_val.sz = g_dev_reg_width;
+
+    mxc_i2c_init(base);
+
+    // reset and enable I2C
+    writew(0, base + I2C_I2CR);
+    writew(I2C_I2CR_IEN, base + I2C_I2CR);
+
+    while (p->div != 0) {
+        if (div <= p->div)
+            break;
+        p++;
+    }
+    
+    if (p->div == 0) {
+        diag_printf("Error: can't meet I2C baud rate request (%d) for 0x%x)\n",
+                    baud, base);
+        return -1;
+    }
+
+    diag_printf1("baud=%d, div=%d, reg_val=%d\n", baud, p->div, p->reg_value);
+
+    writew(p->reg_value, base + I2C_IFDR);
+
+    diag_printf1("requested data rate is: %d, actual rate is: %d\n",
+                 baud, clock / p->div);
+
+    return 0;
+}
+
+static void do_i2c(int argc, char *argv[]);
+RedBoot_cmd("i2c",
+            "i2c R/W operations as master",
+            "<i2c slave addr> <register index> [<regisetr val>]]",
+            do_i2c
+           );
+
+
+static void do_i2c(int argc,char *argv[])
+{
+    int dir = I2C_READ, i;
+    unsigned long v;
+    
+    if (g_i2c_nr == -1) {
+        diag_printf("I2C module [%d] not initialized. Issue i2c_init first\n\n", g_i2c_nr);
+        return;
+    }
+    if (argc == 1) {
+        diag_printf("\tRead:  i2c <i2c_dev_addr> <dev_reg_addr>\n");
+        diag_printf("\tWrite: i2c <i2c_dev_addr> <dev_reg_addr> <dev_reg_val>\n");
+        return;
+    }
+
+    if (!parse_num(*(&argv[1]), (unsigned long *)&g_i2c_addr, &argv[1], ":")) {
+        diag_printf("Error: Invalid parameter %d\n", __LINE__);
+        return;
+    }
+
+    if (!parse_num(*(&argv[2]), (unsigned long *)&g_dev_address, &argv[2], ":")) {
+        diag_printf("Error: Invalid parameter %d\n", __LINE__);
+        return;
+    }
+
+    if (argc == 4) {
+        if (!parse_num(*(&argv[3]), &v, &argv[3], ":")) {
+            diag_printf("Error: Invalid parameter\n");
+            return;
+        }
+        dir = I2C_WRITE;
+        diag_printf("Writing I2C[%d] for addr 0x%x register 0x%x with value 0x%08lx\n",
+                    g_i2c_nr, g_i2c_addr, g_dev_address, v);
+        for (i = 0; i < g_dev_reg_width; i++) {
+            g_dev_value[i] = v >> (8 * (g_dev_reg_width - i - 1)) & 0xff;
+        }
+        diag_printf1("testing reversed data: 0x%08x\n", *(unsigned int*)g_dev_value);
+
+    } else {
+        diag_printf("Reading I2C [%d] from slave addr [0x%x] register [0x%x]\n",
+                    g_i2c_nr, g_i2c_addr,  g_dev_address);
+    }
+
+    if (i2c_xfer(g_i2c_nr, g_i2c_addr, &g_dev_addr, &g_dev_val, dir) != 0) {
+        diag_printf("Error I2C transfer\n\n");
+        return;
+    }
+
+    if (dir == I2C_READ) {
+        diag_printf("--->  ");
+        for (i = 0; i < g_dev_reg_width; i++) {
+            diag_printf("0x%02x ", g_dev_val.data[i]);
+        }
+        diag_printf("\n\n");
+    }
+}
+
+static void do_i2c_init(int argc, char *argv[]);
+RedBoot_cmd("i2c_init",
+            "Initialize i2c (i2c_num is 0-indexed)",
+            "<i2c_num> <frequency> <device addr width> <device reg width>",
+            do_i2c_init
+           );
+
+static void do_i2c_init(int argc,char *argv[])
+{
+    unsigned freq;
+
+    if (argc == 1 || argc != 5) {
+        diag_printf("\ni2c_init <i2c_num> <frequency> <device addr width> <device reg width>\n\n");
+        return;
+    }
+
+    if (!parse_num(*(&argv[1]), (unsigned long *)&g_i2c_nr, &argv[1], ":")) {
+        diag_printf("Error: Invalid parameter\n");
+        return;
+    }
+    
+    if (g_i2c_nr > i2c_num - 1) {
+        diag_printf("invalide i2c number: %d, max number is: %d\n", g_i2c_nr, i2c_num - 1);
+        return;
+    }
+    diag_printf1("i2c max number is: %d\n", i2c_num - 1);
+
+    if (!parse_num(*(&argv[2]), (unsigned long *)&freq, &argv[2], ":")) {
+        diag_printf("Error: Invalid parameter\n");
+        return;
+    }
+    if (!parse_num(*(&argv[3]), (unsigned long *)&g_dev_addr_width, &argv[3], ":")) {
+        diag_printf("Error: Invalid parameter\n");
+        return;
+    }
+    if (!parse_num(*(&argv[4]), (unsigned long *)&g_dev_reg_width, &argv[4], ":")) {
+        diag_printf("Error: Invalid parameter\n");
+        return;
+    }
+
+    i2c_init(i2c_base_addr[g_i2c_nr], freq);
+    
+    diag_printf("initializing i2c:%d, addr-width:%d, data-width:%d\n\n",
+                g_i2c_nr, g_dev_addr_width, g_dev_reg_width);
+}
+
+#ifdef PMIC_I2C_BASE
+static void mxc_pmic_i2c_init(void)
+{
+    volatile unsigned int rev_id;
+
+    i2c_init(PMIC_I2C_BASE, 40000);      // 40kHz data rate
+
+    rev_id = pmic_reg(7, 0, 0);
+    diag_printf("PMIC ID: 0x%08x [Rev: ", rev_id);
+    switch (rev_id & 0x1F) {
+    case 0x1:
+        diag_printf("1.0");
+        break;
+    case 0x9:
+        diag_printf("1.1");
+        break;
+    case 0xA:
+        diag_printf("1.2");
+        break;
+    case 0x10:
+        diag_printf("2.0");
+        break;
+    case 0x11:
+        diag_printf("2.1");
+        break;
+    case 0x18:
+        diag_printf("3.0");
+        break;
+    case 0x19:
+        diag_printf("3.1");
+        break;
+    case 0x1A:
+        diag_printf("3.2");
+        break;
+    case 0x2:
+        diag_printf("3.2A");
+        break;
+    case 0x1B:
+        diag_printf("3.3");
+        break;
+    case 0x1D:
+        diag_printf("3.5");
+        break;
+    default:
+        diag_printf("unknown");
+        break;
+    }
+    diag_printf("]\n");
+}
+
+RedBoot_init(mxc_pmic_i2c_init, RedBoot_INIT_PRIO(100));
+
+static void do_pmic(int argc, char *argv[]);
+RedBoot_cmd("pmic",
+            "Read/Write internal PMIC register",
+            "<reg num> [value to be written]",
+            do_pmic
+           );
+
+static void do_pmic(int argc,char *argv[])
+{
+    unsigned int reg, temp, val = 0, write = 0;
+
+    if (argc == 1) {
+        diag_printf("\tRead:  pmic <reg num>\n");
+        diag_printf("\tWrite: pmic <reg num> <value to be written>\n");
+        return;
+    }
+
+    if (!parse_num(*(&argv[1]), (unsigned long *)&reg, &argv[1], ":")) {
+        diag_printf("Error: Invalid parameter\n");
+        return;
+    }
+
+    if (argc == 3) {
+        if (!parse_num(*(&argv[2]), (unsigned long *)&val, &argv[2], ":")) {
+            diag_printf("Error: Invalid parameter\n");
+            return;
+        }
+        write = 1;
+    }
+
+    temp = pmic_reg(reg, val, write);
+
+    diag_printf("\tval: 0x%08x\n\n", temp);
+}
+
+/*!
+ * To read/write to a PMIC register. For write, it does another read for the
+ * actual register value.
+ *
+ * @param   reg         register number inside the PMIC
+ * @param   val         data to be written to the register; don't care for read
+ * @param   write       0 for read; 1 for write
+ *
+ * @return              the actual data in the PMIC register
+ */
+unsigned int pmic_reg(unsigned int reg, unsigned int val, unsigned int write)
+{
+    unsigned int temp;
+
+    if (reg > 63 || write > 1 ) {
+        diag_printf("<reg num> = %d is invalide. Should be less then 63\n", reg);
+        return 0;
+    }
+    val = (write << 31) | (reg << 25) | (val & 0x00FFFFFF);
+    diag_printf1("reg=0x%x, val=0x%08x\n", reg, val);
+
+    temp = i2c_xchg_single(val, PMIC_I2C_BASE);
+
+    if (write) {
+        val &= ~(1 << 31);
+        temp = i2c_xchg_single(val, PMIC_I2C_BASE);
+    }
+
+    return temp;
+}
+#endif // PMIC_I2C_BASE
diff -urN -x CVS -x doc -x lwip_tcpip -x calmrisc16 -x calmrisc32 ecos_20050912/packages/devs/spi/arm/mxc/current/cdl/spi.cdl ecos_base/packages/devs/spi/arm/mxc/current/cdl/spi.cdl
--- ecos_20050912/packages/devs/spi/arm/mxc/current/cdl/spi.cdl	1969-12-31 18:00:00.000000000 -0600
+++ ecos_base/packages/devs/spi/arm/mxc/current/cdl/spi.cdl	2008-02-28 12:03:03.000000000 -0600
@@ -0,0 +1,94 @@
+# ====================================================================
+#
+#      spi.cdl
+#
+#      A Freescale MXC SPI package.
+#
+# ====================================================================
+#####ECOSGPLCOPYRIGHTBEGIN####
+## -------------------------------------------
+## This file is part of eCos, the Embedded Configurable Operating System.
+## Copyright (C) 1998, 1999, 2000, 2001, 2002, 2004 Red Hat, Inc.
+## Copyright (C) 2004 eCosCentric, Ltd
+##
+## eCos is free software; you can redistribute it and/or modify it under
+## the terms of the GNU General Public License as published by the Free
+## Software Foundation; either version 2 or (at your option) any later version.
+##
+## eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+## WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+## for more details.
+##
+## You should have received a copy of the GNU General Public License along
+## with eCos; if not, write to the Free Software Foundation, Inc.,
+## 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+##
+## As a special exception, if other files instantiate templates or use macros
+## or inline functions from this file, or you compile this file and link it
+## with other works to produce a work based on this file, this file does not
+## by itself cause the resulting work to be covered by the GNU General Public
+## License. However the source code for this file must still be made available
+## in accordance with section (3) of the GNU General Public License.
+##
+## This exception does not invalidate any other reasons why a work based on
+## this file might be covered by the GNU General Public License.
+##
+## -------------------------------------------
+#####ECOSGPLCOPYRIGHTEND####
+# ====================================================================
+######DESCRIPTIONBEGIN####
+#
+# Author(s):      Kevin Zhang
+# Contributors:
+# Date:           2006-08-23
+#
+#####DESCRIPTIONEND####
+# ====================================================================
+
+cdl_package CYGPKG_DEVS_MXC_SPI {
+    display     "SPI driver for FSL MXC-based platforms"
+
+    compile     -library=libextras.a mxc_spi.c
+
+    include_dir   cyg/io
+
+    cdl_option CYGHWR_DEVS_FSL_SPI_VER_XX {
+        display       "SPI for MX21/MX27 support"
+        default_value 0
+        description   " "
+        define_proc {
+            puts $::cdl_system_header "#define MXC_SPI_VER_XX"
+        }
+    }
+    cdl_option CYGHWR_DEVS_FSL_SPI_VER_0_4 {
+        display       "SPI version 0.4 support for MX31"
+        default_value 0
+        description   "
+            When this option is enabled, it indicates the SPI version
+            is 0.4"
+        define_proc {
+            puts $::cdl_system_header "#define MXC_SPI_VER_0_4"
+        }
+    }
+    cdl_option CYGHWR_DEVS_FSL_SPI_VER_0_7 {
+        display       "SPI version 0.7 support"
+        default_value 0
+        description   "
+            When this option is enabled, it indicates the SPI version
+            is 0.7"
+        define_proc {
+            puts $::cdl_system_header "#define MXC_SPI_VER_0_7"
+        }
+    }
+    cdl_option CYGHWR_DEVS_FSL_SPI_VER_2_3 {
+        display       "SPI version 2.3 support"
+        default_value 0
+        description   "
+            When this option is enabled, it indicates the SPI version
+            is 2.3"
+        define_proc {
+            puts $::cdl_system_header "#define MXC_SPI_VER_2_3"
+        }
+    }
+}
diff -urN -x CVS -x doc -x lwip_tcpip -x calmrisc16 -x calmrisc32 ecos_20050912/packages/devs/spi/arm/mxc/current/include/mxc_spi.h ecos_base/packages/devs/spi/arm/mxc/current/include/mxc_spi.h
--- ecos_20050912/packages/devs/spi/arm/mxc/current/include/mxc_spi.h	1969-12-31 18:00:00.000000000 -0600
+++ ecos_base/packages/devs/spi/arm/mxc/current/include/mxc_spi.h	2008-03-17 22:37:03.000000000 -0500
@@ -0,0 +1,190 @@
+//==========================================================================
+//
+//      mxc_spi.h
+//
+//      SPI support on Freescale MXC platforms
+//
+//==========================================================================
+//####ECOSGPLCOPYRIGHTBEGIN####
+// -------------------------------------------
+// This file is part of eCos, the Embedded Configurable Operating System.
+// Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+//
+// eCos is free software; you can redistribute it and/or modify it under
+// the terms of the GNU General Public License as published by the Free
+// Software Foundation; either version 2 or (at your option) any later version.
+//
+// eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with eCos; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+//
+// As a special exception, if other files instantiate templates or use macros
+// or inline functions from this file, or you compile this file and link it
+// with other works to produce a work based on this file, this file does not
+// by itself cause the resulting work to be covered by the GNU General Public
+// License. However the source code for this file must still be made available
+// in accordance with section (3) of the GNU General Public License.
+//
+// This exception does not invalidate any other reasons why a work based on
+// this file might be covered by the GNU General Public License.
+//
+// Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+// at http://sources.redhat.com/ecos/ecos-license/
+// -------------------------------------------
+//####ECOSGPLCOPYRIGHTEND####
+//==========================================================================
+//#####DESCRIPTIONBEGIN####
+//
+// Author(s):    Kevin Zhang <k.zhang@freescale.com>
+// Contributors:
+// Date:         2006-08-24
+// Purpose:
+// Description:
+//
+//####DESCRIPTIONEND####
+//
+//==========================================================================
+
+#ifndef __MXC_SPI_H__
+#define __MXC_SPI_H__
+
+#define SPI_RX_REG_OFF              0x0
+#define SPI_TX_REG_OFF              0x4
+#define SPI_CTRL_REG_OFF            0x8
+
+#if defined(MXC_SPI_VER_0_4)
+#define SPI_INT_CTRL_REG_OFF        0xC
+#define SPI_DMA_REG_OFF             0x10
+#define SPI_INT_STAT_REG_OFF        0x14
+#define SPI_PERIOD_REG_OFF          0x18
+#define SPI_TEST_REG_OFF            0x1C
+
+#define SPI_INT_STAT_RR             (1 << 3)
+
+#define SPI_CTRL_REG_XCH_BIT        (1 << 2)
+#define SPI_CTRL_REG_RATE_SH        16  // start from bit 16
+#define SPI_CTRL_REG_RATE_WD        3   // 3-bit width
+
+#define SPI_CTRL_REG_BIT_COUNT32    (0x1F << 8)  // 32-bit xfer
+#define SPI_CTRL_REG_BIT_COUNT23    (0x16 << 8)  // 23-bit xfer
+#define SPI_CTRL_CS0                (0 << 24)
+#define SPI_CTRL_CS1                (1 << 24)
+#define SPI_CTRL_CS2                (2 << 24)
+#define SPI_CTRL_CS3                (3 << 24)
+#define SPI_CTRL_CS_MASK            (3 << 24)
+#define SPI_CTRL_SSPOL_HIGH         (1 << 7)
+#define SPI_CTRL_SSCTL_SET          (1 << 6)
+#define SPI_CTRL_SCLK_POL_LOW       (1 << 4)
+#define SPI_CTRL_MODE_MASTER        (1 << 1)
+#define SPI_CTRL_EN                 (1 << 0)
+#define SPI_TEST_REG_RXCNT_OFFSET   4
+#define SPI_TEST_REG_RXCNT_MASK     (0xF << 4)
+
+#elif defined(MXC_SPI_VER_0_7)
+#define SPI_INT_CTRL_REG_OFF        0xC
+#define SPI_DMA_REG_OFF             0x10
+#define SPI_INT_STAT_REG_OFF        0x14
+#define SPI_PERIOD_REG_OFF          0x18
+#define SPI_TEST_REG_OFF            0x1C
+
+#define SPI_INT_STAT_RR             (1 << 3)
+
+#define SPI_CTRL_REG_XCH_BIT        (1 << 2)
+#define SPI_CTRL_REG_RATE_SH        16  // start from bit 16
+#define SPI_CTRL_REG_RATE_WD        3   // 3-bit width
+
+#define SPI_CTRL_REG_BIT_COUNT46    (0x2D << 20)  // 48-bit xfer
+#define SPI_CTRL_REG_BIT_COUNT32    (0x1F << 20)  // 32-bit xfer
+#define SPI_CTRL_REG_BIT_COUNT23    (0x16 << 20)  // 23-bit xfer
+#define SPI_CTRL_CS0                (0 << 12)
+#define SPI_CTRL_CS1                (1 << 12)
+#define SPI_CTRL_CS2                (2 << 12)
+#define SPI_CTRL_CS3                (3 << 12)
+#define SPI_CTRL_CS_MASK            (3 << 12)
+#define SPI_CTRL_SSPOL_HIGH         (1 << 7)
+#define SPI_CTRL_SSCTL_SET          (1 << 6)
+#define SPI_CTRL_SCLK_POL_LOW       (1 << 4)
+#define SPI_CTRL_MODE_MASTER        (1 << 1)
+#define SPI_CTRL_EN                 (1 << 0)
+#define SPI_TEST_REG_RXCNT_OFFSET   4
+#define SPI_TEST_REG_RXCNT_MASK     (0xF << 4)
+
+
+#elif defined(MXC_SPI_VER_2_3)
+#define SPI_INT_CTRL_REG_OFF        0x10
+#define SPI_DMA_REG_OFF             0x14
+#define SPI_INT_STAT_REG_OFF        0x18
+#define SPI_PERIOD_REG_OFF          0x1C
+#define SPI_TEST_REG_OFF            0x20
+
+#define SPI_INT_STAT_RR             (1 << 3)
+
+#define SPI_CTRL_REG_XCH_BIT        (1 << 2)
+#define SPI_CTRL_REG_RATE_SH        12  // start from bit 12
+#define SPI_CTRL_REG_RATE_WD        4   // 3-bit width
+
+#define SPI_CTRL_REG_BIT_COUNT32    (0x1F << 20)  // 32-bit xfer
+#define SPI_CTRL_REG_BIT_COUNT23    (0x16 << 20)  // 23-bit xfer
+#define SPI_CTRL_REG_BIT_COUNT46    (0x2D << 20)  // 46-bit xfer
+#define SPI_CTRL_CS0                (0 << 18)
+#define SPI_CTRL_CS1                (1 << 18)
+#define SPI_CTRL_CS2                (2 << 18)
+#define SPI_CTRL_CS3                (3 << 18)
+#define SPI_CTRL_CS_MASK            (3 << 18)
+#define SPI_CTRL_MODE_MASTER_0      (1 << 4)
+#define SPI_CTRL_MODE_MASTER_1      (1 << 5)
+#define SPI_CTRL_MODE_MASTER_2      (1 << 6)
+#define SPI_CTRL_MODE_MASTER_3      (1 << 7)
+#define SPI_CTRL_EN                 (1 << 0)
+#define SPI_TEST_REG_RXCNT_OFFSET   8
+#define SPI_TEST_REG_RXCNT_MASK     (0x7F << 8)
+#else
+// For MX27
+#define SPI_INT_CTRL_REG_OFF        0xC
+#define SPI_INT_STAT_REG_OFF        0xC
+#define SPI_TEST_REG_OFF            0x10
+#define SPI_PERIOD_REG_OFF          0x14
+#define SPI_DMA_REG_OFF             0x18
+#define SPI_RESET_REG_OFF           0x1C
+
+#define SPI_INT_STAT_RR             (1 << 4)
+
+#define SPI_CTRL_REG_XCH_BIT        (1 << 9)
+#define SPI_CTRL_REG_RATE_SH        14  // start from bit 14
+#define SPI_CTRL_REG_RATE_WD        5   // 5-bit width
+
+#define SPI_CTRL_BURST_EN           (1 << 23)
+#define SPI_CTRL_SDHC_SPI_EN        (1 << 22)
+#define SPI_CTRL_SWAP_EN            (1 << 21)
+#define SPI_CTRL_CS0                (0 << 19)
+#define SPI_CTRL_CS1                (1 << 19)
+#define SPI_CTRL_CS2                (2 << 19)
+#define SPI_CTRL_CS_MASK            (3 << 19)
+#define SPI_CTRL_SSPOL_HIGH         (1 << 8)
+#define SPI_CTRL_SSCTL_SET          (1 << 7)
+#define SPI_CTRL_SCLK_POL_LOW       (1 << 5)
+#define SPI_CTRL_REG_BIT_COUNT32    0x1F   // 32-bit xfer
+#define SPI_CTRL_REG_BIT_COUNT23    0x16   // 23-bit xfer
+#define SPI_CTRL_MODE_MASTER        (1 << 11)
+#define SPI_CTRL_EN                 (1 << 10)
+#define SPI_TEST_REG_RXCNT_OFFSET   4
+#define SPI_TEST_REG_RXCNT_MASK     (0xF << 4)
+
+#endif
+
+int spi_init(unsigned int base, unsigned int baud, unsigned int ctrl_val);
+unsigned int pmic_reg(unsigned int reg, unsigned int val, unsigned int write);
+unsigned int spi_xchg_single(unsigned int data, unsigned int base);
+
+#ifdef CPLD_SPI_BASE
+unsigned int spi_cpld_xchg_single(unsigned int data, unsigned int data1, unsigned int base);
+unsigned int cpld_reg(unsigned int reg, unsigned int val, unsigned int read);
+unsigned int cpld_reg_xfer(unsigned int reg, unsigned int val, unsigned int read);
+#endif   /* CPLD_SPI_BASE */
+
+#endif				/* __MXC_SPI_H__ */
diff -urN -x CVS -x doc -x lwip_tcpip -x calmrisc16 -x calmrisc32 ecos_20050912/packages/devs/spi/arm/mxc/current/src/mxc_spi.c ecos_base/packages/devs/spi/arm/mxc/current/src/mxc_spi.c
--- ecos_20050912/packages/devs/spi/arm/mxc/current/src/mxc_spi.c	1969-12-31 18:00:00.000000000 -0600
+++ ecos_base/packages/devs/spi/arm/mxc/current/src/mxc_spi.c	2007-12-19 15:53:56.000000000 -0600
@@ -0,0 +1,440 @@
+//==========================================================================
+//
+//      mxc_spi.c
+//
+//      SPI support on Freescale MXC platforms
+//
+//==========================================================================
+//####ECOSGPLCOPYRIGHTBEGIN####
+// -------------------------------------------
+// This file is part of eCos, the Embedded Configurable Operating System.
+// Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+//
+// eCos is free software; you can redistribute it and/or modify it under
+// the terms of the GNU General Public License as published by the Free
+// Software Foundation; either version 2 or (at your option) any later version.
+//
+// eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with eCos; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+//
+// As a special exception, if other files instantiate templates or use macros
+// or inline functions from this file, or you compile this file and link it
+// with other works to produce a work based on this file, this file does not
+// by itself cause the resulting work to be covered by the GNU General Public
+// License. However the source code for this file must still be made available
+// in accordance with section (3) of the GNU General Public License.
+//
+// This exception does not invalidate any other reasons why a work based on
+// this file might be covered by the GNU General Public License.
+//
+// Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+// at http://sources.redhat.com/ecos/ecos-license/
+// -------------------------------------------
+//####ECOSGPLCOPYRIGHTEND####
+//==========================================================================
+//#####DESCRIPTIONBEGIN####
+//
+// Author(s):    Kevin Zhang <k.zhang@freescale.com>
+// Contributors:
+// Date:         2006-08-24
+// Purpose:
+// Description:
+//
+//####DESCRIPTIONEND####
+//
+//==========================================================================
+
+#include <redboot.h>
+#include <stdlib.h>
+#include <pkgconf/hal.h>
+#include <cyg/hal/hal_arch.h>
+#include <cyg/hal/hal_cache.h>
+#include <cyg/hal/hal_io.h>
+
+#include <cyg/hal/fsl_board.h>
+#include <cyg/io/mxc_spi.h>
+
+void clock_spi_enable(unsigned int spi_clk);
+
+#undef MXC_SPI_DEBUG
+//#define MXC_SPI_DEBUG
+
+#ifdef MXC_SPI_DEBUG
+#define diag_printf1    diag_printf
+#else
+#define diag_printf1(fmt,args...)
+#endif
+
+#if defined(MXC_SPI_VER_0_7) || defined(MXC_SPI_VER_0_4)
+const unsigned int baud_rate_div[] = {
+    4, 8, 16, 32, 64, 128, 256, 512,
+};
+static int version = 1;
+#elif defined(MXC_SPI_VER_XX)
+const unsigned int baud_rate_div[] = {
+    3, 4, 6, 8, 12, 16, 24, 32, 48, 64, 96, 128, 192, 256, 384, 512,
+};
+static int version = 2;
+#elif defined(MXC_SPI_VER_2_3)
+const unsigned int baud_rate_div[] = {
+    1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,
+};
+static int version = 3;
+#else
+#error No SPI version defined
+#endif
+
+const int BAUD_RATE_DIV_MAX = sizeof(baud_rate_div) / sizeof(unsigned int);
+
+/*!
+ * It is for the master mode operation to exchange a single word with
+ * external device.
+ *
+ * @param   data        data to be transferred
+ * @param   base        base address of the spi module
+ *
+ * @return              the value received from the Rx register
+ */
+unsigned int spi_xchg_single(unsigned int data, unsigned int base)
+{
+    volatile unsigned int cfg_reg = readl(base + SPI_CTRL_REG_OFF);
+
+    hal_delay_us(100);
+
+    writel(data, base + SPI_TX_REG_OFF);
+
+    cfg_reg |= SPI_CTRL_REG_XCH_BIT;
+
+    writel(cfg_reg, base + SPI_CTRL_REG_OFF);
+
+    while ((readl(base + SPI_INT_STAT_REG_OFF) & SPI_INT_STAT_RR) == 0) {
+    }
+
+    return readl(base + SPI_RX_REG_OFF);
+}
+
+/*!
+ * Initialize and enable a spi module
+ *
+ * @param   base        base address of spi module (also assigned for SPIx_CLK)
+ * @param   baue        the desired data rate
+ * @param   ctrl_val    control register value EXCEPT the data rate
+ *
+ * @return              0 if successful; non-zero otherwise
+ */
+int spi_init(unsigned int base, unsigned int baud, unsigned int ctrl_val)
+{
+    unsigned int clock = get_peri_clock(base);
+    int i, div = clock / baud;
+
+    clock_spi_enable(base);
+
+    diag_printf1("base=0x%x, baue=%d, ctrl_val=0x%x, div=%d, clock=%d\n",
+                base, baud, ctrl_val, div, clock);
+
+    for (i = 0; i < BAUD_RATE_DIV_MAX; i++) {
+        if (div <= baud_rate_div[i]) {
+            break;
+        }
+    }
+    if (i == BAUD_RATE_DIV_MAX) {
+        diag_printf("Baud rate requested (%d) is too slow for spi(0x%x)\n",
+                    baud, base);
+        return -1;
+    }
+
+    // to adjust for differen spi versions
+    if (version == 2) {
+        ctrl_val |= ((i + 1) << SPI_CTRL_REG_RATE_SH);
+    } else
+        ctrl_val |= (i << SPI_CTRL_REG_RATE_SH);
+
+
+    diag_printf1("ctrl_val=0x%x, i=%d, SPI_CTRL_REG_RATE_SH=%d\n",
+                ctrl_val, i, SPI_CTRL_REG_RATE_SH);
+
+    writel(SPI_CTRL_EN, base + SPI_CTRL_REG_OFF);
+
+    writel(ctrl_val, base + SPI_CTRL_REG_OFF);
+
+    writel(0, base + SPI_INT_CTRL_REG_OFF);
+    diag_printf1("requested data rate is: %d, actual rate is: %d\n",
+                 baud, clock / baud_rate_div[i]);
+
+    return 0;
+}
+
+#ifdef PMIC_SPI_BASE
+static void mxc_pmic_init(void)
+{
+    volatile unsigned int rev_id;
+    unsigned int ctrl;
+
+    ctrl = SPI_CTRL_REG_BIT_COUNT32 | SPI_CTRL_SSPOL_HIGH |
+           SPI_CTRL_MODE_MASTER | SPI_CTRL_EN;
+    ctrl |= PMIC_SPI_CHIP_SELECT_NO;
+
+    spi_init(PMIC_SPI_BASE, 4000000,      // 4MHz data rate
+             ctrl);
+
+    rev_id = pmic_reg(7, 0, 0);
+    diag_printf("PMIC ID: 0x%08x [Rev: ", rev_id);
+    switch (rev_id & 0x1F) {
+    case 0x1:
+        diag_printf("1.0");
+        break;
+    case 0x9:
+        diag_printf("1.1");
+        break;
+    case 0xA:
+        diag_printf("1.2");
+        break;
+    case 0x10:
+        diag_printf("2.0");
+        break;
+    case 0x11:
+        diag_printf("2.1");
+        break;
+    case 0x18:
+        diag_printf("3.0");
+        break;
+    case 0x19:
+        diag_printf("3.1");
+        break;
+    case 0x1A:
+        diag_printf("3.2");
+        break;
+    case 0x2:
+        diag_printf("3.2A");
+        break;
+    case 0x1B:
+        diag_printf("3.3");
+        break;
+    case 0x1D:
+        diag_printf("3.5");
+        break;
+    default:
+        diag_printf("unknown");
+        break;
+    }
+    diag_printf("]\n");
+}
+
+RedBoot_init(mxc_pmic_init, RedBoot_INIT_PRIO(100));
+
+static void do_pmic(int argc, char *argv[]);
+RedBoot_cmd("pmic",
+            "Read/Write internal PMIC register",
+            "<reg num> [value to be written]",
+            do_pmic
+           );
+
+static void do_pmic(int argc,char *argv[])
+{
+    unsigned int reg, temp, val = 0, write = 0;
+
+    if (argc == 1) {
+        diag_printf("\tRead:  pmic <reg num>\n");
+        diag_printf("\tWrite: pmic <reg num> <value to be written>\n");
+        return;
+    }
+
+    if (!parse_num(*(&argv[1]), (unsigned long *)&reg, &argv[1], ":")) {
+        diag_printf("Error: Invalid parameter\n");
+        return;
+    }
+
+    if (argc == 3) {
+        if (!parse_num(*(&argv[2]), (unsigned long *)&val, &argv[2], ":")) {
+            diag_printf("Error: Invalid parameter\n");
+            return;
+        }
+        write = 1;
+    }
+
+    temp = pmic_reg(reg, val, write);
+
+    diag_printf("\tval: 0x%08x\n\n", temp);
+}
+
+/*!
+ * To read/write to a PMIC register. For write, it does another read for the
+ * actual register value.
+ *
+ * @param   reg         register number inside the PMIC
+ * @param   val         data to be written to the register; don't care for read
+ * @param   write       0 for read; 1 for write
+ *
+ * @return              the actual data in the PMIC register
+ */
+unsigned int pmic_reg(unsigned int reg, unsigned int val, unsigned int write)
+{
+    unsigned int temp;
+
+    if (reg > 63 || write > 1 ) {
+        diag_printf("<reg num> = %d is invalide. Should be less then 63\n", reg);
+        return 0;
+    }
+    val = (write << 31) | (reg << 25) | (val & 0x00FFFFFF);
+    diag_printf1("reg=0x%x, val=0x%08x\n", reg, val);
+
+    temp = spi_xchg_single(val, PMIC_SPI_BASE);
+
+    if (write) {
+        val &= ~(1 << 31);
+        temp = spi_xchg_single(val, PMIC_SPI_BASE);
+    }
+
+    return temp;
+}
+#endif // PMIC_SPI_BASE
+
+#ifdef CPLD_SPI_BASE
+
+unsigned int spi_cpld_xchg_single(unsigned int data, unsigned int data1, unsigned int base)
+{
+    volatile unsigned int cfg_reg = readl(base + SPI_CTRL_REG_OFF);
+    unsigned int temp;
+
+    /* Activate the SS signal */
+    cfg_reg |= CPLD_SPI_CHIP_SELECT_NO;
+    writel(cfg_reg, CPLD_SPI_BASE + SPI_CTRL_REG_OFF);
+
+    /* Write the data */
+    writel(data, base + SPI_TX_REG_OFF);
+    writel(data1, base + SPI_TX_REG_OFF);
+
+    cfg_reg |= SPI_CTRL_REG_XCH_BIT;
+    writel(cfg_reg, base + SPI_CTRL_REG_OFF);
+
+    while ((((cfg_reg = readl(base + SPI_TEST_REG_OFF)) &
+              SPI_TEST_REG_RXCNT_MASK) >> SPI_TEST_REG_RXCNT_OFFSET) != 2) {
+    }
+
+    /* Deactivate the SS signal */
+    cfg_reg = readl(base + SPI_CTRL_REG_OFF);
+    cfg_reg &= ~SPI_CTRL_CS_MASK;
+    writel(cfg_reg, base + SPI_CTRL_REG_OFF);
+
+    /* Read from RX FIFO, second entry contains the data */
+    temp = readl(base + SPI_RX_REG_OFF);
+    temp = readl(base + SPI_RX_REG_OFF);
+    return ((temp >> 6) & 0xffff);
+}
+
+static void mxc_cpld_spi_init(void)
+{
+    unsigned int ctrl;
+
+    ctrl = SPI_CTRL_REG_BIT_COUNT46 | CPLD_SPI_CTRL_MODE_MASTER | SPI_CTRL_EN;
+
+    spi_init(CPLD_SPI_BASE, 18000000,      // 54MHz data rate
+             ctrl);
+}
+
+RedBoot_init(mxc_cpld_spi_init, RedBoot_INIT_PRIO(102));
+
+static void do_cpld(int argc, char *argv[]);
+
+RedBoot_cmd("spi_cpld",
+            "Read/Write 16-bit internal CPLD register over CSPI",
+            "<reg num> [16-bit value to be written]",
+            do_cpld
+           );
+
+static void do_cpld(int argc,char *argv[])
+{
+    unsigned int reg, temp, val = 0, read = 1;
+
+    if (argc == 1) {
+        diag_printf("\tRead:  spi_cpld <reg num>\n");
+        diag_printf("\tWrite: spi_cpld <reg num> <value to be written>\n");
+        return;
+    }
+
+    if (!parse_num(*(&argv[1]), (unsigned long *)&reg, &argv[1], ":")) {
+        diag_printf("Error: Invalid parameter\n");
+        return;
+    }
+
+    if (argc == 3) {
+        if (!parse_num(*(&argv[2]), (unsigned long *)&val, &argv[2], ":")) {
+            diag_printf("Error: Invalid parameter\n");
+            return;
+        }
+        read = 0;
+    }
+
+    temp = cpld_reg(reg, val, read);
+
+    diag_printf("\tval: 0x%04x\n\n", temp);
+}
+
+/*!
+ * To read/write to a CPLD register.
+ *
+ * @param   reg         register number inside the CPLD
+ * @param   val         data to be written to the register; don't care for read
+ * @param   read        0 for write; 1 for read
+ *
+ * @return              the actual data in the CPLD register
+ */
+unsigned int cpld_reg_xfer(unsigned int reg, unsigned int val, unsigned int read)
+{
+    unsigned int local_val1, local_val2;
+
+    reg >>= 1;
+
+    local_val1 = (read << 13) | ((reg & 0x0001FFFF) >> 5) | 0x00001000;
+    if (read) {
+        //local_val1 = (read << 22) | (reg << 4) | 0x00200004;
+        //local_val2 = 0x1F;
+        local_val2 = ( ((reg & 0x0000001F) << 27) | 0x0200001f);
+
+    } else {
+        //local_val1 = (read << 22) | (reg << 4) | 0x00200007;
+        //local_val2 = ((val & 0xFFFF) << 6) | 0x00400027;
+        local_val2 = ( ((reg & 0x0000001F) << 27) | ((val & 0x0000FFFF) << 6) | 0x03C00027);
+
+    }
+
+    diag_printf1("reg=0x%x, val=0x%08x\n", reg, val);
+    return spi_cpld_xchg_single(local_val1, local_val2, CPLD_SPI_BASE);
+}
+
+/*!
+ * To read/write to a CPLD register. For write, it does another read for the
+ * actual register value.
+ *
+ * @param   reg         register number inside the CPLD
+ * @param   val         data to be written to the register; don't care for read
+ * @param   read        0 for write; 1 for read
+ *
+ * @return              the actual data in the CPLD register
+ */
+unsigned int cpld_reg(unsigned int reg, unsigned int val, unsigned int read)
+{
+    unsigned int temp;
+
+    if (reg > 0x20068 || read > 1 ) {
+        diag_printf("<reg num> = %x is invalid. Should be less then 0x20068\n", reg);
+        return 0;
+    }
+
+    temp = cpld_reg_xfer(reg, val, read);
+    diag_printf1("reg=0x%x, val=0x%08x\n", reg, val);
+
+    if (read == 0) {
+        temp = cpld_reg_xfer(reg, val, 1);
+    }
+
+    return temp;
+}
+
+#endif // CPLD_SPI_BASE
diff -urN -x CVS -x doc -x lwip_tcpip -x calmrisc16 -x calmrisc32 ecos_20050912/packages/devs/usb/mxc/current/cdl/usbs_mxc.cdl ecos_base/packages/devs/usb/mxc/current/cdl/usbs_mxc.cdl
--- ecos_20050912/packages/devs/usb/mxc/current/cdl/usbs_mxc.cdl	1969-12-31 18:00:00.000000000 -0600
+++ ecos_base/packages/devs/usb/mxc/current/cdl/usbs_mxc.cdl	2006-08-18 10:11:20.000000000 -0500
@@ -0,0 +1,58 @@
+# ====================================================================
+#
+#      usbs_mxc.cdl
+#
+#      USB device driver for the FSL MXC family of processors.
+#
+# ====================================================================
+#####ECOSGPLCOPYRIGHTBEGIN####
+## -------------------------------------------
+## This file is part of eCos, the Embedded Configurable Operating System.
+## Copyright (C) 2002 Bart Veer
+## Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+##
+## eCos is free software; you can redistribute it and/or modify it under
+## the terms of the GNU General Public License as published by the Free
+## Software Foundation; either version 2 or (at your option) any later version.
+##
+## eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+## WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+## for more details.
+##
+## You should have received a copy of the GNU General Public License along
+## with eCos; if not, write to the Free Software Foundation, Inc.,
+## 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+##
+## As a special exception, if other files instantiate templates or use macros
+## or inline functions from this file, or you compile this file and link it
+## with other works to produce a work based on this file, this file does not
+## by itself cause the resulting work to be covered by the GNU General Public
+## License. However the source code for this file must still be made available
+## in accordance with section (3) of the GNU General Public License.
+##
+## This exception does not invalidate any other reasons why a work based on
+## this file might be covered by the GNU General Public License.
+##
+## Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+## at http://sources.redhat.com/ecos/ecos-license/
+## -------------------------------------------
+#####ECOSGPLCOPYRIGHTEND####
+# ====================================================================
+######DESCRIPTIONBEGIN####
+#
+# Author(s):      yili
+# Contributors:
+# Date:           2006-08-15
+#
+#####DESCRIPTIONEND####
+# ====================================================================
+
+cdl_package CYGPKG_DEVS_USB_MXC {
+    display     "FSL mxc USB Device Driver"
+    compile -library=libextras.a mxc-pcd.c
+    
+    description "
+        The FSL mxc family of processors implements an
+        on-chip USB device controller."
+}
diff -urN -x CVS -x doc -x lwip_tcpip -x calmrisc16 -x calmrisc32 ecos_20050912/packages/devs/usb/mxc/current/ChangeLog ecos_base/packages/devs/usb/mxc/current/ChangeLog
--- ecos_20050912/packages/devs/usb/mxc/current/ChangeLog	1969-12-31 18:00:00.000000000 -0600
+++ ecos_base/packages/devs/usb/mxc/current/ChangeLog	2006-08-18 10:11:20.000000000 -0500
@@ -0,0 +1,38 @@
+2006-08-15  Yi Li  <yili@freescale.com>
+
+	* USB device driver work started.
+
+//===========================================================================
+//####ECOSGPLCOPYRIGHTBEGIN####
+// -------------------------------------------
+// This file is part of eCos, the Embedded Configurable Operating System.
+// Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+//
+// eCos is free software; you can redistribute it and/or modify it under
+// the terms of the GNU General Public License as published by the Free
+// Software Foundation; either version 2 or (at your option) any later version.
+//
+// eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with eCos; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+//
+// As a special exception, if other files instantiate templates or use macros
+// or inline functions from this file, or you compile this file and link it
+// with other works to produce a work based on this file, this file does not
+// by itself cause the resulting work to be covered by the GNU General Public
+// License. However the source code for this file must still be made available
+// in accordance with section (3) of the GNU General Public License.
+//
+// This exception does not invalidate any other reasons why a work based on
+// this file might be covered by the GNU General Public License.
+//
+// Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+// at http://sources.redhat.com/ecos/ecos-license/
+// -------------------------------------------
+//####ECOSGPLCOPYRIGHTEND####
+//===========================================================================
diff -urN -x CVS -x doc -x lwip_tcpip -x calmrisc16 -x calmrisc32 ecos_20050912/packages/devs/usb/mxc/current/include/mxc-hardware.h ecos_base/packages/devs/usb/mxc/current/include/mxc-hardware.h
--- ecos_20050912/packages/devs/usb/mxc/current/include/mxc-hardware.h	1969-12-31 18:00:00.000000000 -0600
+++ ecos_base/packages/devs/usb/mxc/current/include/mxc-hardware.h	2008-03-06 11:18:31.000000000 -0600
@@ -0,0 +1,418 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/* Modified from Belcarra Linux USB driver by Yi Li */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+typedef unsigned short u16;
+typedef unsigned int u32;
+typedef unsigned char u8;
+
+#define CONFIG_ARCH_MXC91321 1
+
+#define IO_ADDRESS(x)  (x)
+#define cpu_to_le16(x) (x)
+#define le16_to_cpu(x) (x)
+
+#if defined (CONFIG_ARCH_MXC91321)
+#define MUX_I		0
+#define MUX_F		8
+#define PAD_I		10
+#define _MXC_BUILD_PIN(gp,gi,mi,mf,pi,pf) ((mi << MUX_I) | (mf << MUX_F) | (pi << PAD_I))
+#define PIN_USB_VPIN   _MXC_BUILD_PIN(0, 4, 70, 3, 93, 1)
+#define PIN_USB_VPOUT  _MXC_BUILD_PIN(0, 5, 70, 2, 93, 0)
+#define PIN_USB_VMIN   _MXC_BUILD_PIN(0, 6, 70, 1, 92, 2)
+#define PIN_USB_XRXD   _MXC_BUILD_PIN(0, 7, 70, 0, 92, 1)
+#define PIN_USB_VMOUT  _MXC_BUILD_PIN(0, 2, 71, 1, 94, 0)
+#define PIN_USB_TXENB  _MXC_BUILD_PIN(0, 3, 71, 0, 93, 2)
+#define PIN_TO_IOMUX_INDEX(pin) ((pin >> MUX_I) & ((1 << (MUX_F - MUX_I)) - 1))
+#define PIN_TO_IOMUX_FIELD(pin) ((pin >> MUX_F) & ((1 << (PAD_I - MUX_F)) - 1))
+#define IOMUXC_BASE_ADDR        0x50000000
+#define MUX_CTL_BIT_LEN         8
+#endif
+
+#if defined (CONFIG_ARCH_MXC91321)
+#define OTG_BASE_ADDR           0x50020000
+#endif
+
+#define OTG_CORE_BASE     		(OTG_BASE_ADDR+0x000)	
+#define OTG_FUNC_BASE     		(OTG_BASE_ADDR+0x040)	
+#define OTG_DMA_BASE      		(OTG_BASE_ADDR+0x800)	
+#define OTG_EP_BASE       		(OTG_BASE_ADDR+0x400)	
+#define OTG_SYS_BASE      		(OTG_BASE_ADDR+0x600)	
+
+#define OTG_DATA_BASE           (OTG_BASE_ADDR+0x1000)	
+
+#define SYS_CTRL_OTG_WU_INT_STAT                (1 << 26)
+#define SYS_CTRL_FNT_WU_INT_STAT                (1 << 24)
+
+#define SYS_CTRL_OTG_WU_INT_EN                  (1 << 18)
+#define SYS_CTRL_FNT_WU_INT_EN                  (1 << 16)
+
+#define OTG_CORE_HWMODE                         (OTG_CORE_BASE+0x00)
+
+#define XCVR_D_D                                0x00
+#define XCVR_SE0_D_NEW                          0x02
+#define XCVR_D_SE0_NEW                          0x01
+#define XCVR_SE0_SE0                            0x03
+
+#define MODULE_ANASDBEN                         (1 << 14)
+#define MODULE_OTGXCVR                          (0x3 << 6)
+#define MODULE_HOSTXCVR                         (0x3 << 4)
+#define MODULE_CRECFG                           (0x3)
+#define MODULE_CRECFG_HHNP                      (0x0)
+#define MODULE_CRECFG_HOST                      (0x1)
+#define MODULE_CRECFG_FUNC                      (0x2)
+#define MODULE_CRECFG_SHNP                      (0x3)
+
+#define OTG_CORE_CINT_STAT                      (OTG_CORE_BASE+0x04)	//  32bit core int status reg
+
+#define MODULE_FCINTDSPEN                       (1 << 6)
+
+#define MODULE_ASHNPINT                         (1 << 5)
+#define MODULE_ASFCINT                          (1 << 4)
+#define MODULE_ASHCINT                          (1 << 3)
+#define MODULE_HNPINT                           (1 << 2)
+#define MODULE_FCINT                            (1 << 1)
+#define MODULE_HCINT                            (1)
+
+#define OTG_CORE_CINT_STEN                      (OTG_CORE_BASE+0x08)	//  32bit core int enable reg
+#define OTG_CORE_CINT_STEN_CLR                  (OTG_CORE_BASE+0x3c)	//  32bit core int enable clear reg
+
+#define MODULE_ASHNPINT_EN                      (1 << 5)
+#define MODULE_ASFCINT_EN                       (1 << 4)
+#define MODULE_ASHCINT_EN                       (1 << 3)
+#define MODULE_HNPINT_EN                        (1 << 2)
+#define MODULE_FCINT_EN                         (1 << 1)
+#define MODULE_HCINT_EN                         (1)
+
+#define OTG_CORE_CLK_CTRL                       (OTG_CORE_BASE+0x0C)	//  32bit core clock control reg
+
+#define MODULE_FUNC_CLK                         (1 << 2)
+#define MODULE_MAIN_CLK                         (1)
+
+#define OTG_CORE_RST_CTRL                       (OTG_CORE_BASE+0x10)	// 32bit core reset control reg
+
+#define MODULE_RSTI2C                           (1 << 15)
+#define MODULE_RSTCTRL                          (1 << 5)
+#define MODULE_RSTFC                            (1 << 4)
+#define MODULE_RSTFSIE                          (1 << 3)
+#define MODULE_RSTRH                            (1 << 2)
+#define MODULE_RSTHSIE                          (1 << 1)
+#define MODULE_RSTHC                            (1)
+
+#define OTG_CORE_FRM_INTVL                      (OTG_CORE_BASE+0x14)	//  32bit core frame interval reg
+
+#define MODULE_RESET_FRAME                      (1 << 15)
+
+#define OTG_CORE_FRM_REMAIN                     (OTG_CORE_BASE+0x18)	//  32bit core frame remaining reg
+
+#define OTG_CORE_HNP_CSTAT                      (OTG_CORE_BASE+0x1C)	//  32bit core HNP current state reg
+
+#define MODULE_HNPDAT                           (1 << 30)
+#define MODULE_VBUSBSE                          (1 << 29)
+#define MODULE_VBUSABSV                         (1 << 28)
+#define MODULE_VBUSGTAVV                        (1 << 27)
+
+#define MODULE_ARMTHNPE                         (1 << 25)
+#define MODULE_BHNPEN                           (1 << 24)
+
+#define MODULE_SLAVE                            (1 << 22)
+#define MODULE_MASTER                           (1 << 21)
+#define MODULE_BGEN                             (1 << 20)
+#define MODULE_CMPEN                            (1 << 19)
+
+#define MODULE_SWVBUSPUL                        (1 << 15)
+
+#define MODULE_SWAUTORST                        (1 << 12)
+#define MODULE_SWPUDP                           (1 << 11)
+
+#define MODULE_HNPSTATE                         (0x1f << 8)
+#define MODULE_ABBUSREQ                         (1 << 1)
+
+#define OTG_CORE_CPUEPSEL_STAT                  (OTG_CORE_BASE+0x34)
+#define OTG_CORE_INTERRUPT_STEN                 (OTG_CORE_BASE+0x3c)
+
+#define OTG_FUNC_CMD_STAT                       (OTG_FUNC_BASE+0x00)	//  32bit func command status reg
+
+#define COMMAND_SOFTRESET                       (1 << 7)
+#define COMMAND_BADISOAP                        (1 << 3)
+#define COMMAND_SUPDET                          (1 << 2)
+#define COMMAND_RSMINPROG                       (1 << 1)
+#define COMMAND_RESETDET                        (1)
+
+#define OTG_FUNC_DEV_ADDR                       (OTG_FUNC_BASE+0x04)	//  32bit func device address reg
+#define OTG_FUNC_SINT_STAT                      (OTG_FUNC_BASE+0x08)	//  32bit func system int status reg
+
+#define SYSTEM_DONEREGINTDS                     (1 << 5)
+#define SYSTEM_SOFDETINT                        (1 << 4)
+#define SYSTEM_DONEREGINT                       (1 << 3)
+#define SYSTEM_SUSPDETINT                       (1 << 2)
+#define SYSTEM_RSMFININT                        (1 << 1)
+#define SYSTEM_RESETINT                         (1)
+
+#define OTG_FUNC_SINT_STEN                      (OTG_FUNC_BASE+0x0C)	//  32bit func system int enable reg
+#define OTG_FUNC_SINT_STEN_CLR                  (OTG_FUNC_BASE+0x10C)	//  32bit func system int enable clear reg
+
+#define SYSTEM_DONEREGINTDS_EN                  (1 << 5)
+#define SYSTEM_SOFDETINT_EN                     (1 << 4)
+#define SYSTEM_DONEREGINT_EN                    (1 << 3)
+#define SYSTEM_SUSPDETINT_EN                    (1 << 2)
+#define SYSTEM_RSMFININT_EN                     (1 << 1)
+#define SYSTEM_RESETINT_EN                      (1)
+
+#define OTG_FUNC_XINT_STAT                      (OTG_FUNC_BASE+0x10)	//  32bit func X buf int status reg
+#define OTG_FUNC_YINT_STAT                      (OTG_FUNC_BASE+0x14)	//  32bit func Y buf int status reg
+
+#define OTG_FUNC_XYINT_STEN                     (OTG_FUNC_BASE+0x18)	//  32bit func XY buf int enable reg
+#define OTG_FUNC_XYINT_STEN_CLR                 (OTG_FUNC_BASE+0x118)	//  32bit func XY buf int enable clear reg
+
+#define OTG_FUNC_XFILL_STAT                     (OTG_FUNC_BASE+0x1C)	//  32bit func X filled status reg
+#define OTG_FUNC_YFILL_STAT                     (OTG_FUNC_BASE+0x20)	//  32bit func Y filled status reg
+
+#define OTG_FUNC_EP_EN                          (OTG_FUNC_BASE+0x24)	//  32bit func endpoints enable reg
+#define OTG_FUNC_EP_EN_CLR                      (OTG_FUNC_BASE+0x124)	//  32bit func endpoints enable clear reg
+
+#define OTG_FUNC_EP_RDY                         (OTG_FUNC_BASE+0x28)	//  32bit func endpoints ready reg
+#define OTG_FUNC_EP_RDY_CLR                     (OTG_FUNC_BASE+0x3C)	//  32bit func endpoints ready clear reg
+
+#define OTG_FUNC_IINT                           (OTG_FUNC_BASE+0x2C)	//  32bit func immediate interrupt reg
+#define OTG_FUNC_IINT_CLR                       (OTG_FUNC_BASE+0x12C)	//  32bit func immediate interrupt clear reg
+
+#define OTG_FUNC_EP_DSTAT                       (OTG_FUNC_BASE+0x30)	//  32bit func endpoints done status
+
+#define OTG_FUNC_EP_DEN                         (OTG_FUNC_BASE+0x34)	//  32bit func endpoints done enable
+#define OTG_FUNC_EP_DEN_CLR                     (OTG_FUNC_BASE+0x134)	//  32bit func endpoints done clear enable
+
+#define OTG_FUNC_EP_TOGGLE                      (OTG_FUNC_BASE+0x38)	//  32bit func endpoints toggle bits
+#define OTG_FUNC_FRM_NUM                        (OTG_FUNC_BASE+0x3C)	//  32bit func frame number reg
+
+#define EP0_STALL                               (1 << 31)
+#define EP0_SETUP                               (1 << 30)
+#define EP0_OVERRUN                             (1 << 29)
+#define EP0_AUTOISO                             (1 << 27)
+
+#define EP_FORMAT_CONTROL     0x0
+#define EP_FORMAT_ISOC        0x1
+#define EP_FORMAT_BULK        0x2
+#define EP_FORMAT_INTERRUPT   0x3
+
+#define EP_OUT                                  0x1
+#define EP_IN                                   0x2
+#define EP_BOTH                                 0x3
+
+#define NUM_ETDS                16
+#define DATA_BUFF_SIZE          64
+#define DATA_BUFFER_TOTAL       4096
+#define NUM_DATA_BUFFS          (4096/DATA_BUFF_SIZE)
+
+#define ep_num_both(n)                          (EP_BOTH << n)
+#define ep_num_dir(n, dir)                      ((dir ? EP_IN : EP_OUT) << (n*2))
+#define ep_num_out(n)                           ep_num_dir(n, USB_DIR_OUT)
+#define ep_num_in(n)                            ep_num_dir(n, USB_DIR_IN)
+
+/* ep descriptor access
+ */
+static __inline__ u32 ep_word(int n, int dir, int word)
+{
+	u32 offset = n * 2;
+	offset += dir ? 1 : 0;
+	offset *= 16;
+	offset += word * 4;
+	return OTG_EP_BASE + offset;
+}
+
+static volatile __inline__ u16 data_x_buf(int n, int dir)
+{
+	return 0x40 * (n * 4 + 2 * (dir ? 1 : 0));
+}
+static volatile __inline__ u16 data_y_buf(int n, int dir)
+{
+	return 0x40 * (n * 4 + 2 * (dir ? 1 : 0) + 1);
+}
+
+static volatile __inline__ u8 *data_x_address(int n, int dir)
+{
+	return (volatile u8 *)IO_ADDRESS(OTG_DATA_BASE + data_x_buf(n, dir));
+}
+static volatile __inline__ u8 *data_y_address(int n, int dir)
+{
+	return (volatile u8 *)IO_ADDRESS(OTG_DATA_BASE + data_y_buf(n, dir));
+}
+
+#define OTG_DMA_MISC_CTRL     (OTG_DMA_BASE+0x040)	//  32bit dma EP misc control reg
+#define OTG_DMA_MISC_ARBMODE  (1 << 1)
+
+#define OTG_DMA_ETD_CH_CLR    (OTG_DMA_BASE+0x048)	//  32bit dma ETD clear channel reg
+#define OTG_DMA_EP_CH_CLR     (OTG_DMA_BASE+0x04c)	//  32bit dma EP clear channel reg
+
+#define dma_num_dir(n, dir) (n * 2 + (dir ? 1 : 0))
+#define dma_num_out(n) dma_num_dir(n, USB_DIR_OUT)
+#define dma_num_in(n) dma_num_dir(n, USB_DIR_IN)
+
+#define OTG_DMA_ETD_MSA(x)    (OTG_DMA_BASE+0x100+x*4)
+#define OTG_DMA_EPN_MSA(x)    (OTG_DMA_BASE+0x180+x*4)
+#define OTG_DMA_ETDN_BPTR(x)  (OTG_DMA_BASE+0x280+x*4)
+#define OTG_DMA_EPN_BPTR(x)   (OTG_DMA_BASE+0x284+x*4)
+
+typedef struct transfer_descriptor_w1 {
+	u16 x;
+	u16 y;
+} volatile transfer_descriptor_w1;
+
+typedef struct control_bulk_transfer_descriptor_w2 {
+	u8 rtrydelay;
+	u8 reserved;
+	u16 flags;
+} volatile control_bulk_transfer_descriptor_w2;
+
+typedef struct interrupt_transfer_descriptor_w2 {
+	u8 polinterv;
+	u8 relpolpos;
+	u16 flags;
+} volatile interrupt_transfer_descriptor_w2;
+
+typedef struct isoc_transfer_descriptor_w2 {
+	u16 startfrm;
+	u16 flags;
+} volatile isoc_transfer_descriptor_w2;
+
+typedef struct isoc_transfer_descriptor_w3 {
+	u16 pkt0;
+	u16 pkt1;
+} volatile isoc_transfer_descriptor_w3;
+
+typedef struct transfer_descriptor {
+	union {
+		u32 val;
+		transfer_descriptor_w1 bufsrtad;
+	} volatile w1;
+	union {
+		u32 val;
+		control_bulk_transfer_descriptor_w2 cb;
+		interrupt_transfer_descriptor_w2 intr;
+		isoc_transfer_descriptor_w2 isoc;
+	} volatile w2;
+	union {
+		u32 val;
+		isoc_transfer_descriptor_w3 isoc;
+	} volatile w3;
+} __attribute__ ((packed))
+volatile transfer_descriptor;
+
+static u8 __inline__ fs_rb(u32 port)
+{
+	return *(volatile u8 *)(IO_ADDRESS(port));
+}
+
+static u32 __inline__ fs_rl(u32 port)
+{
+	return *(volatile u32 *)(IO_ADDRESS(port));
+}
+
+static void __inline__ fs_wb(u32 port, u8 val)
+{
+	*(volatile u8 *)(IO_ADDRESS(port)) = val;
+}
+
+static void __inline__ fs_orb(u32 port, u8 val)
+{
+	u8 set = fs_rb(port) | val;
+	*(volatile u8 *)(IO_ADDRESS(port)) = set;
+}
+
+static void __inline__ fs_andb(u32 port, u8 val)
+{
+	u8 set = fs_rb(port) & val;
+	*(volatile u8 *)(IO_ADDRESS(port)) = set;
+}
+
+static void __inline__ fs_wl(u32 port, u32 val)
+{
+	*(volatile u32 *)(IO_ADDRESS(port)) = val;
+}
+
+static void __inline__ fs_orl(u32 port, u32 val)
+{
+	u32 set = fs_rl(port);
+	*(volatile u32 *)(IO_ADDRESS(port)) = (set | val);
+}
+
+static void __inline__ fs_andl(u32 port, u32 val)
+{
+	u32 set = fs_rl(port);
+	*(volatile u32 *)(IO_ADDRESS(port)) = (set & val);
+}
+
+static void inline fs_memcpy32(u32 * dp, u32 * sp, volatile int words)
+{
+	while (words--)
+		*dp++ = *sp++;
+}
+
+static void inline fs_memcpy(u8 * dp, u8 * sp, volatile int bytes)
+{
+	while (bytes--)
+		*dp++ = *sp++;
+}
+
+static void inline fs_clear_words(volatile u32 * addr, int words)
+{
+	while (words--)
+		*addr++ = 0;
+}
+
+#define TIMEOUT_VALUE 1000
+
+void mxc_main_clock_on(void)
+{
+	u32 timeout = TIMEOUT_VALUE;
+	fs_orl(OTG_CORE_CLK_CTRL, MODULE_MAIN_CLK);
+	while (!(fs_rl(OTG_CORE_CLK_CTRL) & MODULE_MAIN_CLK)) {
+		timeout--;
+		if (!timeout)
+			break;
+	}
+}
+
+void mxc_main_clock_off(void)
+{
+	u32 timeout = TIMEOUT_VALUE;
+	fs_wl(OTG_CORE_CLK_CTRL, 0);
+	while ((fs_rl(OTG_CORE_CLK_CTRL) & MODULE_MAIN_CLK)) {
+		timeout--;
+		if (!timeout)
+			break;
+	}
+}
+
+void mxc_func_clock_on(void)
+{
+	u32 timeout = TIMEOUT_VALUE;
+	fs_orl(OTG_CORE_CLK_CTRL, MODULE_FUNC_CLK);
+	while (!(fs_rl(OTG_CORE_CLK_CTRL) & MODULE_FUNC_CLK)) {
+		timeout--;
+		if (!timeout)
+			break;
+	}
+}
+
+void mxc_func_clock_off(void)
+{
+	u32 timeout = TIMEOUT_VALUE;
+	fs_andl(OTG_CORE_CLK_CTRL, 0x0);
+	while ((fs_rl(OTG_CORE_CLK_CTRL) & (MODULE_FUNC_CLK | MODULE_MAIN_CLK))) {
+		timeout--;
+		if (!timeout)
+			break;
+	}
+}
diff -urN -x CVS -x doc -x lwip_tcpip -x calmrisc16 -x calmrisc32 ecos_20050912/packages/devs/usb/mxc/current/include/usbp-chap9.h ecos_base/packages/devs/usb/mxc/current/include/usbp-chap9.h
--- ecos_20050912/packages/devs/usb/mxc/current/include/usbp-chap9.h	1969-12-31 18:00:00.000000000 -0600
+++ ecos_base/packages/devs/usb/mxc/current/include/usbp-chap9.h	2006-08-18 10:11:20.000000000 -0500
@@ -0,0 +1,176 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/* Modified from Belcarra Linux USB driver by Yi Li */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#define USB_DIR_OUT                     0
+#define USB_DIR_IN                      0x80
+
+#define USB_DT_DEVICE                   1
+#define USB_DT_CONFIGURATION            2
+#define USB_DT_STRING                   3
+#define USB_DT_INTERFACE                4
+#define USB_DT_ENDPOINT                 5
+
+#define USB_ENDPOINT_NUMBER_MASK        0x0f            
+#define USB_ENDPOINT_DIR_MASK           0x80
+
+#define USB_ENDPOINT_MASK               0x03            
+#define USB_ENDPOINT_CONTROL            0x00
+#define USB_ENDPOINT_ISOCHRONOUS        0x01
+#define USB_ENDPOINT_BULK               0x02
+#define USB_ENDPOINT_INTERRUPT          0x03
+
+#define USB_PID_OUT                     0xe1
+#define USB_PID_ACK                     0xd2
+#define USB_PID_DATA0                   0xc3
+#define USB_PID_SOF                     0xa5
+#define USB_PID_IN                      0x69
+#define USB_PID_NAK                     0x5a
+#define USB_PID_DATA1                   0x4b
+#define USB_PID_ERR                     0x3c            
+#define USB_PID_SETUP                   0x2d
+#define USB_PID_STALL                   0x1e
+
+#define USB_REQ_GET_STATUS              0x00
+#define USB_REQ_CLEAR_FEATURE           0x01
+#define USB_REQ_SET_FEATURE             0x03
+#define USB_REQ_SET_ADDRESS             0x05
+#define USB_REQ_GET_DESCRIPTOR          0x06
+#define USB_REQ_SET_DESCRIPTOR          0x07
+#define USB_REQ_GET_CONFIGURATION       0x08
+#define USB_REQ_SET_CONFIGURATION       0x09
+#define USB_REQ_GET_INTERFACE           0x0A
+#define USB_REQ_SET_INTERFACE           0x0B
+#define USB_REQ_SYNCH_FRAME             0x0C
+
+#define USB_REQ_DIRECTION_MASK          0x80
+#define USB_REQ_TYPE_MASK               0x60
+#define USB_REQ_RECIPIENT_MASK          0x1f
+
+#define USB_REQ_DEVICE2HOST             0x80
+#define USB_REQ_HOST2DEVICE             0x00
+
+#define USB_REQ_TYPE_STANDARD           0x00
+#define USB_REQ_TYPE_CLASS              0x20
+#define USB_REQ_TYPE_VENDOR             0x40
+
+#define USB_REQ_RECIPIENT_DEVICE        0x00
+#define USB_REQ_RECIPIENT_INTERFACE     0x01
+#define USB_REQ_RECIPIENT_ENDPOINT      0x02
+#define USB_REQ_RECIPIENT_OTHER         0x03
+
+#define USB_STATUS_SELFPOWERED          0x01
+#define USB_STATUS_REMOTEWAKEUP         0x02
+
+#define USB_STATUS_HALT                 0x01
+
+#define FEATURE(f)                      (1 << f)
+
+#define USB_ENDPOINT_HALT               0x00
+#define USB_DEVICE_REMOTE_WAKEUP        0x01
+
+struct usbd_device_request {
+    u8 bmRequestType;
+    u8 bRequest;
+    u16 wValue;
+    u16 wIndex;
+    u16 wLength;
+};
+
+struct usbd_endpoint_descriptor {
+    u8 bLength;
+    u8 bDescriptorType;   // 0x5
+    u8 bEndpointAddress;
+    u8 bmAttributes;
+    u16 wMaxPacketSize;
+    u8 bInterval;
+};
+
+struct usbd_interface_descriptor {
+    u8 bLength;
+    u8 bDescriptorType;   // 0x04
+    u8 bInterfaceNumber;
+    u8 bAlternateSetting;
+    u8 bNumEndpoints;
+    u8 bInterfaceClass;
+    u8 bInterfaceSubClass;
+    u8 bInterfaceProtocol;
+    u8 iInterface;
+};
+
+struct usbd_configuration_descriptor {
+    u8 bLength;
+    u8 bDescriptorType;   // 0x2
+    u16 wTotalLength;
+    u8 bNumInterfaces;
+    u8 bConfigurationValue;
+    u8 iConfiguration;
+    u8 bmAttributes;
+    u8 bMaxPower;
+};
+
+struct usbd_device_descriptor {
+    u8 bLength;
+    u8 bDescriptorType;   // 0x01
+    u16 bcdUSB;
+    u8 bDeviceClass;
+    u8 bDeviceSubClass;
+    u8 bDeviceProtocol;
+    u8 bMaxPacketSize0;
+    u16 idVendor;
+    u16 idProduct;
+    u16 bcdDevice;
+    u8 iManufacturer;
+    u8 iProduct;
+    u8 iSerialNumber;
+    u8 bNumConfigurations;
+};
+
+struct usbd_langid_descriptor {
+    u8 bLength;
+    u8 bDescriptorType;   // 0x03
+    u8 bData[2];
+};
+
+typedef enum usbd_urb_status {
+    USBD_URB_OK = 0,
+    USBD_URB_IN_QUEUE,
+    USBD_URB_ACTIVE,
+    USBD_URB_CANCELLED,
+    USBD_URB_ERROR,
+    USBD_URB_STALLED,
+    USBD_URB_RESET,
+    USBD_URB_NOT_READY,
+    USBD_URB_DISABLED,
+} usbd_urb_status_t;
+
+#define USBD_URB_SENDZLP        0x01    /* send a Zero Length Packet when urb is finished */
+
+/* definition of the structure itself */
+struct usbd_urb {
+    struct usbd_endpoint_instance   *endpoint;
+    u8                              *buffer;        // data received (OUT) or being sent (IN)
+    u32                             buffer_length;  // maximum data expected for OUT
+    u32                             actual_length;  // actual data received (OUT or being sent (IN)
+    u32                             flags;
+    usbd_urb_status_t               status;         // what is the current status of the urb
+};
+
+struct usbd_endpoint_instance {
+    u8   bEndpointAddress;    // logical endpoint address 
+    int  bmAttributes;        // endpoint type
+    u16  wMaxPacketSize;      // packet size for requested endpoint
+    struct usbd_urb *urb;     // active urb
+    u32  planed;              // data will be sent in planed packet 
+};
diff -urN -x CVS -x doc -x lwip_tcpip -x calmrisc16 -x calmrisc32 ecos_20050912/packages/devs/usb/mxc/current/src/mxc-pcd.c ecos_base/packages/devs/usb/mxc/current/src/mxc-pcd.c
--- ecos_20050912/packages/devs/usb/mxc/current/src/mxc-pcd.c	1969-12-31 18:00:00.000000000 -0600
+++ ecos_base/packages/devs/usb/mxc/current/src/mxc-pcd.c	2006-09-12 10:04:35.000000000 -0500
@@ -0,0 +1,693 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/* Modified from Belcarra Linux USB driver by Yi Li */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <pkgconf/hal.h>
+#include <cyg/hal/hal_arch.h>
+#include <cyg/hal/hal_cache.h>
+#include <redboot.h>
+#include <stdlib.h>
+#include <cyg/hal/hal_io.h>
+
+#include "../include/mxc-hardware.h"
+#include "../include/usbp-chap9.h"
+
+#define CONFIG_OTG_ZASEVB_DIFFERENTIAL_UNIDIRECTIONAL 1
+#define MXC_CONFIG_MC13783	1
+//#define MXC_USB_DEBUG	1
+#ifdef MXC_USB_DEBUG
+#define dbug_usb diag_printf
+#else 
+#define dbug_usb(fmt, ...) do{}while(0) 
+#endif
+
+extern unsigned int pmic_reg(unsigned int reg, unsigned int val, unsigned int write);
+
+static void do_usb(int argc, char *argv[]);
+RedBoot_cmd("usb",
+            "Load data from usb into RAM", 
+            "XXX",
+            do_usb
+           );
+
+#define CONFIG_REDBOOT_VENDORID 	0x15A2
+#define CONFIG_REDBOOT_PRODUCTID 	0x001F
+#define CONFIG_REDBOOT_BCDDEVICE 	0x0100
+#define CONFIG_REDBOOT_MANUFACTURER 0
+#define CONFIG_REDBOOT_PRODUCT_NAME 0
+
+u8 mxc_new_address, mxc_usb_address;	/* used to save and set USB address */
+struct usbd_endpoint_instance endpoint_zero;
+struct usbd_endpoint_instance endpoint_bulk_in;
+struct usbd_endpoint_instance endpoint_bulk_out;
+
+u8 *ram_buffer = (u8 *)0x100000;
+int ram_transfered = 0;
+int transfer_done = 0;
+
+static void inline mxc_reset_toggles(void)
+{
+	fs_wl(OTG_FUNC_EP_TOGGLE, fs_rl(OTG_FUNC_EP_TOGGLE));
+}
+
+static void inline mxc_reset_toggle_ep(int ep_num)
+{
+	if (fs_rl(OTG_FUNC_EP_TOGGLE) & ep_num)
+		fs_wl(OTG_FUNC_EP_TOGGLE, ep_num);
+}
+
+static void inline mxc_set_toggle_ep(int ep_num)
+{
+	dbug_usb("mxc_set_toggle_ep\n");
+	if ((fs_rl(OTG_FUNC_EP_TOGGLE) & ep_num) == 0)
+	    fs_wl(OTG_FUNC_EP_TOGGLE, ep_num);
+}
+
+static void mxc_reset_ep_rdy(int ep_num)
+{
+	if (fs_rl(OTG_FUNC_EP_RDY) & ep_num) 
+		fs_wl(OTG_FUNC_EP_RDY_CLR, ep_num);
+}
+
+static void mxc_set_ep_rdy(int ep_num)
+{
+	if ((fs_rl(OTG_FUNC_EP_RDY) & ep_num) == 0)
+	    fs_wl(OTG_FUNC_EP_RDY, ep_num);   
+}
+
+static void 
+mxc_ep_config(int epn, int dir, u32 ep_num, int wMaxPacketSize, int buffersize,
+	int format, int ttlbtecnt)
+{
+	u32 ep0 = (wMaxPacketSize << 16) | ((format & 3) << 14);
+	u32 ep1 = ttlbtecnt ? (data_y_buf(epn, dir) << 16) | data_x_buf(epn, dir) : 0;
+	u32 ep3 = ((buffersize - 1) << 21) | (ttlbtecnt & 0x1fffff);
+
+	dbug_usb("mxc_ep_config epn %x dir %x %x %x %x\n", epn, dir, ep0, ep1, ep3);
+	fs_wl(ep_word(epn, dir, 0), ep0);
+	fs_wl(ep_word(epn, dir, 1), ep1);
+	fs_wl(ep_word(epn, dir, 3), ep3);
+
+	fs_orl(OTG_FUNC_EP_EN, ep_num);
+}
+
+static void
+mxc_ep_config_nodma(int epn, int dir, int wMaxPacketSize, int format, int ttlbtecnt)
+{
+	u32 ep_num = ep_num_dir(epn, dir);
+
+	mxc_ep_config(epn, dir, ep_num, wMaxPacketSize, wMaxPacketSize, format, ttlbtecnt);
+
+	mxc_set_ep_rdy(ep_num);
+}
+
+static void 
+mxc_pcd_set_address(u8 address)
+{
+	mxc_usb_address = 0;
+	mxc_new_address = address;	/* this will be used in the interrupt handler */
+    dbug_usb("mxc_pcd_set_address to %d\n", address);
+}
+
+static int 
+usbd_get_descriptor(u8 *buffer, int wLength, int descriptor_type)
+{
+	int actual_length = 0;
+    struct usbd_device_descriptor *device_descriptor;
+    u8 iManufacturer;
+    u8 iProduct;
+    u8 iSerialNumber = 0;
+    struct usbd_configuration_descriptor configuration_descriptor;
+	struct usbd_interface_descriptor interface_descriptor;
+	struct usbd_endpoint_descriptor endpoint_descriptor;
+
+    switch (descriptor_type) {
+    case USB_DT_DEVICE: {
+        dbug_usb("USB_DT_DEVICE\n");
+        iManufacturer = CONFIG_REDBOOT_MANUFACTURER;
+        iProduct = CONFIG_REDBOOT_PRODUCT_NAME;
+
+        device_descriptor = (struct usbd_device_descriptor *) buffer;
+
+        device_descriptor->bLength = 18;
+        device_descriptor->bDescriptorType = USB_DT_DEVICE;
+        device_descriptor->bcdUSB = 0x0110;
+        device_descriptor->bDeviceClass = 0;
+        device_descriptor->bDeviceSubClass = 0;
+        device_descriptor->bDeviceProtocol = 0;
+        device_descriptor->bMaxPacketSize0 = 64;
+
+        if (wLength > 8) {
+            device_descriptor->idVendor = cpu_to_le16(CONFIG_REDBOOT_VENDORID); 
+            device_descriptor->idProduct = cpu_to_le16(CONFIG_REDBOOT_PRODUCTID);
+            device_descriptor->bcdDevice = cpu_to_le16(CONFIG_REDBOOT_BCDDEVICE);
+            device_descriptor->iManufacturer = iManufacturer;
+            device_descriptor->iProduct = iProduct;
+            device_descriptor->iSerialNumber = iSerialNumber;
+            device_descriptor->bNumConfigurations = 1;
+            actual_length += 18;
+        }
+        else
+            actual_length += wLength;
+        break;
+    }
+    case USB_DT_CONFIGURATION: {
+        dbug_usb("USB_DT_CONFIGURATION\n");
+        configuration_descriptor.bLength = 9;
+        configuration_descriptor.bDescriptorType = USB_DT_CONFIGURATION;
+        configuration_descriptor.bNumInterfaces = 1;
+        configuration_descriptor.bConfigurationValue = 1;
+        configuration_descriptor.iConfiguration = '\0';
+        configuration_descriptor.bmAttributes = 0;
+        configuration_descriptor.bMaxPower = 0;
+        actual_length = 9;
+
+        interface_descriptor.bLength = 9;
+        interface_descriptor.bDescriptorType = USB_DT_INTERFACE;
+        interface_descriptor.bInterfaceNumber = 1;
+        interface_descriptor.bAlternateSetting = 0;
+        interface_descriptor.bNumEndpoints = 1;
+        interface_descriptor.bInterfaceClass = 0;
+        interface_descriptor.bInterfaceSubClass = 0;
+        interface_descriptor.bInterfaceProtocol = 0;
+        interface_descriptor.iInterface = '\0';
+        actual_length += 9;
+
+        endpoint_descriptor.bLength = 7;
+        endpoint_descriptor.bDescriptorType = USB_DT_ENDPOINT;
+        endpoint_descriptor.bEndpointAddress = 1;
+        endpoint_descriptor.bmAttributes = USB_ENDPOINT_BULK;
+        endpoint_descriptor.wMaxPacketSize = 64;
+        endpoint_descriptor.bInterval = 0;
+        actual_length += 7;
+
+        configuration_descriptor.wTotalLength = actual_length;
+		memcpy(buffer, &configuration_descriptor, 9); 
+		if (wLength > 9) {
+			memcpy(buffer + 9, &interface_descriptor, 9); 
+			memcpy(buffer + 18, &endpoint_descriptor, 7); 
+		}
+		actual_length = (wLength > actual_length) ? actual_length : wLength; 
+        break;
+    }
+    case USB_DT_STRING: {
+        *buffer = '\0';
+        break;
+    }
+    default:
+        return -1;
+    }
+
+    dbug_usb("usbd_get_descriptor actual_length %d\n", actual_length);
+    return actual_length;
+}
+
+struct usbd_urb *
+usbd_alloc_urb(int length, struct usbd_endpoint_instance *endpoint)
+{
+    struct usbd_urb *urb;
+
+    urb = (struct usbd_urb *) malloc(sizeof(struct usbd_urb));
+    urb->endpoint = endpoint;
+    urb->buffer_length = length;
+
+    if (length) {
+        urb->buffer = (u8 *) malloc(length);
+    }
+	endpoint->urb = urb;
+    return urb;
+}
+
+static void usbd_free_urb(struct usbd_urb *urb)
+{
+	if (urb) {
+		if (urb->endpoint)
+			urb->endpoint->urb = NULL;
+		if (urb->buffer) 
+			free(urb->buffer);
+		free(urb);
+	}
+}
+
+static void 
+mxc_sendzlp(int epn, struct usbd_endpoint_instance *endpoint, int wMaxPacketSize)
+{
+	u32 ep_num_in = ep_num_in(epn);
+
+	if (!(fs_rl(OTG_FUNC_XFILL_STAT) & ep_num_in))
+		fs_wl(OTG_FUNC_XFILL_STAT, ep_num_in);
+	else if (!(fs_rl(OTG_FUNC_YFILL_STAT) & ep_num_in))
+		fs_wl(OTG_FUNC_YFILL_STAT, ep_num_in);
+
+	mxc_ep_config_nodma(epn, USB_DIR_IN, endpoint->wMaxPacketSize,
+	    endpoint->bmAttributes & 0x3, 0);
+}
+
+static void 
+mxc_stop_ep(int epn, int dir)
+{
+	int ep_num = ep_num_dir(epn, dir);
+
+	mxc_reset_ep_rdy(ep_num);
+	fs_wl(OTG_DMA_EP_CH_CLR, ep_num);
+	fs_wl(OTG_FUNC_IINT_CLR, ep_num);
+	fs_wl(OTG_FUNC_XINT_STAT, ep_num);
+	fs_wl(OTG_FUNC_YINT_STAT, ep_num);
+	if (epn == 0)
+		return;
+
+	fs_wl(OTG_FUNC_XFILL_STAT, ep_num);
+	fs_wl(OTG_FUNC_YFILL_STAT, ep_num);
+	fs_wl(OTG_FUNC_XFILL_STAT, ep_num);
+	fs_wl(OTG_FUNC_YFILL_STAT, ep_num);
+}
+
+static void
+mxc_pcd_start_ep_setup(struct usbd_endpoint_instance *endpoint)
+{
+	mxc_ep_config_nodma(0, USB_DIR_OUT, endpoint->wMaxPacketSize,
+	    EP_FORMAT_CONTROL, endpoint->wMaxPacketSize);
+	mxc_ep_config_nodma(0, USB_DIR_IN, endpoint->wMaxPacketSize,
+	    EP_FORMAT_CONTROL, 0);
+}
+
+static void
+mxc_pcd_start_ep_out(struct usbd_endpoint_instance *endpoint)
+{
+	struct usbd_urb *urb;
+	int epn = endpoint->bEndpointAddress & 0x7f;
+	u32 ep_num = ep_num_dir(epn, USB_DIR_OUT);
+
+	urb = endpoint->urb; 
+	endpoint->planed = urb->buffer_length;
+	mxc_ep_config(epn, USB_DIR_OUT, ep_num, endpoint->wMaxPacketSize,
+		endpoint->wMaxPacketSize, endpoint->bmAttributes & 0x3, 
+		endpoint->planed);
+
+	mxc_set_ep_rdy(ep_num);
+}
+
+static void
+mxc_pcd_start_ep_in(struct usbd_endpoint_instance *endpoint)
+{
+	struct usbd_urb *urb;
+	int epn = endpoint->bEndpointAddress & 0x7f;
+	u32 ep_num = ep_num_dir(epn, USB_DIR_IN);
+	int wMaxPacketSize = endpoint->wMaxPacketSize;
+
+	urb = endpoint->urb;
+
+	/* check if xfil/yfil bits are set, clear if necessary */
+	if (epn && fs_rl(OTG_FUNC_XFILL_STAT) & ep_num) {
+		fs_wl(OTG_FUNC_XFILL_STAT, ep_num);
+	}
+	if (epn && fs_rl(OTG_FUNC_YFILL_STAT) & ep_num) {
+		fs_wl(OTG_FUNC_YFILL_STAT, ep_num);
+	}
+
+	endpoint->planed = urb->actual_length;
+
+	mxc_ep_config(epn, USB_DIR_IN, ep_num, wMaxPacketSize, 
+		(endpoint->planed > wMaxPacketSize) ? wMaxPacketSize : endpoint->planed,
+		endpoint->bmAttributes & 0x3, endpoint->planed);
+
+	memcpy((void *)data_x_address(epn, USB_DIR_IN), 
+		urb->buffer, endpoint->planed);
+	fs_wl(OTG_FUNC_XFILL_STAT, ep_num);
+	fs_wl(OTG_FUNC_YFILL_STAT, ep_num);
+
+	mxc_set_ep_rdy(ep_num);
+}
+
+static int do_device_request(struct usbd_device_request *request)
+{
+    struct usbd_urb *urb;
+    u8 bmRequestType = request->bmRequestType;
+    u8 bRequest = request->bRequest;
+    u16 wValue = le16_to_cpu(request->wValue);
+    u16 wLength = le16_to_cpu(request->wLength);
+
+	dbug_usb("do_device_request %x %x %x %x\n", 
+		bmRequestType, bRequest, wValue, wLength);
+    if ((bmRequestType & USB_REQ_DIRECTION_MASK)) {
+        urb = usbd_alloc_urb(64, &endpoint_zero);
+        dbug_usb("allocating urb length: %d at %x\n", wLength, urb);
+
+        switch (bRequest) {
+            case USB_REQ_GET_DESCRIPTOR:
+                dbug_usb("USB_REQ_GET_DESCRIPTOR\n");
+                urb->actual_length = 
+                	usbd_get_descriptor(urb->buffer, wLength, wValue >> 8);
+				dbug_usb("buffer %x %x %x %x %x %x %x %x %x\n", 
+					*(urb->buffer), *(urb->buffer+1), *(urb->buffer+2), 
+					*(urb->buffer+3), *(urb->buffer+4), *(urb->buffer+5), 
+					*(urb->buffer+6), *(urb->buffer+7), *(urb->buffer+8)); 
+                break;
+            case USB_REQ_GET_CONFIGURATION:
+                urb->actual_length = 1;
+                urb->buffer[0] = 1;
+                break;
+            case USB_REQ_GET_INTERFACE:
+                urb->buffer[0] = 0;
+                urb->actual_length = 1;
+                break;
+            default:
+                dbug_usb("bad descriptor type");
+                return -1;
+        }
+
+        mxc_pcd_start_ep_in(urb->endpoint);
+		return 0;
+    }
+    else {
+        switch (bRequest) {
+            case USB_REQ_SET_ADDRESS:
+                mxc_pcd_set_address(wValue);
+                break;
+            case USB_REQ_SET_CONFIGURATION:
+            	urb = usbd_alloc_urb(64 * 2, &endpoint_bulk_out);
+			    urb->actual_length = 0;
+			    mxc_pcd_start_ep_out(urb->endpoint);
+				break;
+            case USB_REQ_SET_INTERFACE:
+            default: 
+                return -1;
+        }
+
+		mxc_sendzlp(0, &endpoint_zero, endpoint_zero.wMaxPacketSize);
+		hal_delay_us(5000);
+		return 0;
+    }
+    return -1;
+}
+
+static void
+mxc_pcd_stop_ep_out(int epn, struct usbd_endpoint_instance *endpoint)
+{
+	u32 transfer;
+	u32 ep_num = ep_num_dir(epn, USB_DIR_OUT);
+    char *endstring = "redboot dummy";
+
+	transfer = endpoint->planed - (fs_rl(ep_word(epn, USB_DIR_OUT, 3)) & 0x1fffff);
+	dbug_usb("mxc_pcd_stop_ep_out received %d\n", transfer);
+	//mxc_stop_ep(epn, USB_DIR_OUT);
+
+	if (epn == 0) {
+#if 0
+		usbd_free_urb(endpoint->urb);
+#endif
+	}
+	else {
+		if (transfer > endpoint->wMaxPacketSize) {
+//diag_printf("transfer  %d\n", transfer);
+			memcpy(ram_buffer + ram_transfered, 
+				(void *)data_x_address(epn, USB_DIR_OUT), endpoint->wMaxPacketSize);
+			memcpy(ram_buffer + ram_transfered + endpoint->wMaxPacketSize, 
+				(void *)data_y_address(epn, USB_DIR_OUT), transfer - endpoint->wMaxPacketSize);
+		}
+		else {
+			memcpy(ram_buffer + ram_transfered, 
+				(void *)data_x_address(epn, USB_DIR_OUT), transfer);
+            if (transfer == sizeof(endstring)) {
+                if (memcmp(endstring, ram_buffer + ram_transfered, sizeof(endstring))
+                    == 0) {
+                    transfer = 0;
+                }
+            }
+		}
+		ram_transfered += transfer;
+		dbug_usb("ram_transfered %d, %x %x %x %x %x %x %x %x %x %x %x %x\n", 
+		ram_transfered, 
+		*(ram_buffer+0), *(ram_buffer+1), *(ram_buffer+2), *(ram_buffer+3),
+		*(ram_buffer+4), *(ram_buffer+5), *(ram_buffer+6), *(ram_buffer+7),
+		*(ram_buffer+8), *(ram_buffer+9), *(ram_buffer+10), *(ram_buffer+11));
+
+		/* check if xfil/yfil bits are set, clear if necessary */
+		if (epn && fs_rl(OTG_FUNC_XFILL_STAT) & ep_num) {
+			fs_wl(OTG_FUNC_XFILL_STAT, ep_num);
+		}
+		if (epn && fs_rl(OTG_FUNC_YFILL_STAT) & ep_num) {
+			fs_wl(OTG_FUNC_YFILL_STAT, ep_num);
+		}
+
+		/* re-arm */
+		mxc_ep_config(epn, USB_DIR_OUT, ep_num, endpoint->wMaxPacketSize,
+			endpoint->wMaxPacketSize, endpoint->bmAttributes & 0x3, 
+			endpoint->planed);
+
+		mxc_set_ep_rdy(ep_num);
+
+		if (transfer < endpoint->planed) {
+			transfer_done = 1;
+			return;
+		}	
+	}
+}
+
+static void
+mxc_pcd_stop_ep_setup(struct usbd_endpoint_instance *endpoint)
+{
+	static struct usbd_device_request request;
+
+	u32 ep0 = fs_rl(ep_word(0, USB_DIR_OUT, 0));
+
+	dbug_usb("mxc_pcd_stop_ep_setup ep0 %x\n", ep0);
+	if ((ep0 & EP0_SETUP) == 0) {
+		dbug_usb("ep0 out received.\n");
+		mxc_pcd_stop_ep_out(0, endpoint);
+		return;
+	}
+
+	dbug_usb("setup received OTG_FUNC_XINT_STAT %x.\n", fs_rl(OTG_FUNC_XINT_STAT));
+	mxc_set_toggle_ep(2);
+
+	dbug_usb("copy x buffer\n");
+	fs_memcpy((u8 *) &request, (u8 *) data_x_address(0, USB_DIR_OUT), 8);
+	fs_wl(OTG_FUNC_XINT_STAT, ep_num_out(0));
+	fs_wl(OTG_FUNC_XFILL_STAT, ep_num_out(0));
+
+	do_device_request(&request);
+
+	if ((request.bmRequestType & USB_REQ_DIRECTION_MASK) ==	USB_REQ_HOST2DEVICE) {
+		if (mxc_new_address != mxc_usb_address) {
+			dbug_usb("Actual set new address to %d\n", mxc_new_address);
+			mxc_usb_address = mxc_new_address;
+			fs_wl(OTG_FUNC_DEV_ADDR, mxc_usb_address);
+		}
+	}
+}
+
+static void
+mxc_pcd_stop_ep_in(int epn, struct usbd_endpoint_instance *endpoint)
+{
+	mxc_stop_ep(epn, USB_DIR_IN);
+	usbd_free_urb(endpoint->urb);
+
+	/* for the ZLP */
+	if (!epn) {
+		mxc_ep_config_nodma(0, USB_DIR_OUT, endpoint->wMaxPacketSize,
+		    EP_FORMAT_CONTROL, endpoint->wMaxPacketSize);
+	}
+}
+
+int mxc_pcd_int_hndlr(long buffer, long length)
+{
+	u32 cmd_stat, sint_stat, ep_dstat, ep_stats;
+	//u8 first_time = 1;
+	int temp;
+	ram_buffer = (u8 *)buffer;
+	
+	dbug_usb("mxc_pcd_int_hndlr +\n");
+	while (1) {
+		if ((sint_stat = fs_rl(OTG_FUNC_SINT_STAT)))
+			fs_wl(OTG_FUNC_SINT_STAT, sint_stat);
+
+		cmd_stat = fs_rl(OTG_FUNC_CMD_STAT);
+
+		if ((cmd_stat & COMMAND_RESETDET) || (sint_stat & SYSTEM_RESETINT)/* || first_time*/) {
+			dbug_usb("reset received.\n");
+			fs_wl(OTG_FUNC_DEV_ADDR, 0);
+			mxc_new_address = mxc_usb_address = 0;
+			fs_wl(OTG_DMA_EP_CH_CLR, 0xffffffff);
+			fs_wl(OTG_FUNC_IINT_CLR, 0xffffffff);
+			fs_wl(OTG_FUNC_EP_DEN_CLR, 0xffffffff);	
+			mxc_reset_toggles();
+			fs_wl(OTG_FUNC_EP_RDY_CLR, fs_rl(OTG_FUNC_EP_RDY));
+			fs_wl(OTG_FUNC_EP_DSTAT, fs_rl(OTG_FUNC_EP_DSTAT));
+			fs_wl(OTG_FUNC_XINT_STAT, fs_rl(OTG_FUNC_XINT_STAT));
+			fs_wl(OTG_FUNC_YINT_STAT, fs_rl(OTG_FUNC_YINT_STAT));
+			//mxc_pcd_start_ep_setup(&endpoint_zero);
+			//first_time = 0;
+		}
+
+		ep_dstat = fs_rl(OTG_FUNC_EP_DSTAT);
+		if (ep_dstat) {
+			ep_stats = ep_dstat | fs_rl(OTG_FUNC_XINT_STAT) | fs_rl(OTG_FUNC_YINT_STAT);
+
+			/* clear the done status flags */
+			fs_wl(OTG_FUNC_EP_DSTAT, ep_dstat);
+
+			if (ep_stats & EP_IN) {
+				dbug_usb("ep0 in received %x\n", ep_stats);
+				mxc_pcd_stop_ep_in(0, &endpoint_zero);
+			}
+
+			if (ep_stats & EP_OUT) {
+				dbug_usb("ep0 out/setup received %x\n", ep_stats);
+				mxc_pcd_stop_ep_setup(&endpoint_zero);
+			}
+
+			if (ep_dstat & EP_OUT << 2) {
+				dbug_usb("bulk out received.\n");
+				mxc_pcd_stop_ep_out(1, &endpoint_bulk_out);
+			}
+			if (ep_dstat & EP_IN << 2) {
+				dbug_usb("bulk in received.\n");
+				mxc_pcd_stop_ep_in(1, &endpoint_bulk_in);
+			}
+		}
+
+		if ((transfer_done == 1) || (ram_transfered == length)) {
+			temp = ram_transfered;
+			ram_transfered = 0;
+			return temp;
+		}			
+	}
+}
+
+static void 
+iomux_config_mux(u32 pin, int out, int in)
+{
+	volatile unsigned int *base =
+	    (volatile unsigned int *)(IO_ADDRESS(IOMUXC_BASE_ADDR) + 0x034);
+	u32 mux_index = PIN_TO_IOMUX_INDEX(pin);
+	u32 mux_field = PIN_TO_IOMUX_FIELD(pin);
+
+	base[mux_index] =
+	    (base[mux_index] & (~(0xFF << (mux_field * MUX_CTL_BIT_LEN)))) |
+	    (((out << 4) | in) << (mux_field * MUX_CTL_BIT_LEN));
+}
+
+static int 
+mxc_iomux_gpio_mc13783_set(int usb_mode)
+{
+	iomux_config_mux(PIN_USB_XRXD, 1, 2);
+	iomux_config_mux(PIN_USB_VMOUT, 1, 2);
+	iomux_config_mux(PIN_USB_VPOUT, 1, 2);
+	iomux_config_mux(PIN_USB_VPIN, 1, 2);
+	iomux_config_mux(PIN_USB_TXENB, 1, 2);
+	iomux_config_mux(PIN_USB_VMIN, 1, 2);
+
+	return 0;
+}
+
+static void 
+mxc_set_transceiver_mode(int mode)
+{
+	fs_andl(OTG_CORE_HWMODE, ~0xf0);
+	fs_orl(OTG_CORE_HWMODE, (mode << 6) | (mode << 4));	// set to software hnp
+}
+
+int mc13783_tcd_mod_init(void)
+{
+#ifdef CONFIG_OTG_ZASEVB_DIFFERENTIAL_BIDIRECTIONAL
+	int hwmode = XCVR_D_D;
+	int newmode = XCVR_D_D;
+#elif CONFIG_OTG_ZASEVB_DIFFERENTIAL_UNIDIRECTIONAL
+	int hwmode = XCVR_D_SE0_NEW;
+	int newmode = XCVR_D_D;
+#elif CONFIG_OTG_ZASEVB_SINGLE_ENDED_UNIDIRECTIONAL
+	int hwmode = XCVR_SE0_D_NEW;
+	int newmode = XCVR_SE0_D_NEW;
+#elif CONFIG_OTG_ZASEVB_SINGLE_ENDED_BIDIRECTIONAL
+	int hwmode = XCVR_SE0_SE0;
+	int newmode = XCVR_SE0_SE0;
+#endif
+
+	mxc_iomux_gpio_mc13783_set(hwmode);
+
+	mxc_set_transceiver_mode(newmode);
+
+#ifdef MXC_CONFIG_MC13783
+	pmic_reg(49, 0x1844, 1);
+	pmic_reg(50, 0xe, 1);
+#endif
+
+	return 0;
+}
+
+void mxc_pcd_exit(void)
+{
+	dbug_usb("mxc_pcd_exit\n");
+	mxc_func_clock_off();
+	mxc_main_clock_off();
+#ifdef MXC_CONFIG_MC13783
+	pmic_reg(49, 0xa0060, 1);
+	pmic_reg(50, 0x6, 1);
+#endif
+	transfer_done = 0;
+	ram_transfered = 0;
+}
+void mxc_pcd_open(void)
+{
+	mxc_main_clock_on();
+
+	mc13783_tcd_mod_init();
+
+	fs_clear_words((volatile u32 *)IO_ADDRESS(OTG_EP_BASE),	(NUM_ETDS * 16 / 4));
+	fs_clear_words((volatile u32 *)IO_ADDRESS(OTG_EP_BASE), 0x200 / 4);
+	fs_clear_words((volatile u32 *)IO_ADDRESS(OTG_DATA_BASE), 0x400 / 4);
+
+	//fs_wl(OTG_DMA_MISC_CTRL, OTG_DMA_MISC_ARBMODE);	/* round-robin mode */
+	fs_andl(OTG_CORE_HWMODE, ~MODULE_CRECFG_HOST);	// set to FUNCTION hnp
+	fs_orl(OTG_CORE_HWMODE, MODULE_CRECFG_FUNC);	// set to software hnp
+
+	mxc_func_clock_on();
+
+	endpoint_zero.wMaxPacketSize = 64;
+	endpoint_zero.bEndpointAddress = 0;
+	endpoint_zero.bmAttributes = USB_ENDPOINT_CONTROL;
+	mxc_pcd_start_ep_setup(&endpoint_zero);
+
+	endpoint_bulk_out.wMaxPacketSize = 64;
+	endpoint_bulk_out.bEndpointAddress = 1;
+	endpoint_bulk_out.bmAttributes = USB_ENDPOINT_BULK;
+
+	endpoint_bulk_in.wMaxPacketSize = 64;
+	endpoint_bulk_in.bEndpointAddress = 1;
+	endpoint_bulk_in.bmAttributes = USB_ENDPOINT_BULK;
+
+	fs_andl(OTG_CORE_HNP_CSTAT, ~(MODULE_MASTER | MODULE_SLAVE |
+	    MODULE_CMPEN | MODULE_BGEN | MODULE_SWAUTORST |	MODULE_ABBUSREQ));
+	fs_orl(OTG_CORE_HNP_CSTAT, MODULE_SLAVE | MODULE_CMPEN | MODULE_BGEN |
+		 MODULE_SWAUTORST | MODULE_ABBUSREQ);
+}
+
+static int mxc_pcd_init(void)
+{
+	dbug_usb("mxc_pcd_init\n");
+    
+    mxc_pcd_open();
+	mxc_pcd_int_hndlr(0x100000, 0x200000);
+
+	mxc_pcd_exit();
+	return 0;
+}
+
+static void
+do_usb(int argc, char *argv[])
+{
+    dbug_usb("do_usb\n");
+	mxc_pcd_init();
+}
diff -urN -x CVS -x doc -x lwip_tcpip -x calmrisc16 -x calmrisc32 ecos_20050912/packages/ecos.db ecos_base/packages/ecos.db
--- ecos_20050912/packages/ecos.db	2005-08-25 08:40:36.000000000 -0500
+++ ecos_base/packages/ecos.db	2008-04-01 13:33:42.000000000 -0500
@@ -47,7 +47,7 @@
 # in the component repository, the target boards supported by those
 # packages, and a set of templates that can be used to instantiate
 # configuration.
-# 
+#
 #####DESCRIPTIONEND####
 #===============================================================================
 
@@ -72,7 +72,7 @@
         description "
 Common types and useful macros.
 Tracing and assertion facilities.
-Package startup options." 
+Package startup options."
 }
 
 package CYGPKG_IO {
@@ -108,7 +108,7 @@
                         devs_can_mcf52xx_flexcan mcf52xx_flexcan_serial_driver }
     hardware
     directory	      devs/can/m68k/mcf52xx
-    script	          can_mcf52xx.cdl	
+    script	          can_mcf52xx.cdl
     description       "Generic CAN device driver for the on-chip
                        FlexCAN modules in MCF52xx ColdFire processors."
 }
@@ -117,7 +117,7 @@
     alias             { "Loop CAN device drivers"
                         devs_can_loop loop_can_driver }
     directory	      devs/can/loop
-    script	      can_loop.cdl	
+    script	      can_loop.cdl
     description       "Loopback CAN device driver."
 }
 
@@ -198,6 +198,36 @@
            flash memory devices."
 }
 
+package CYGPKG_DEVS_FLASH_ONMXC {
+	alias 		{ "Support FLASH memory on Freescale MXC platforms" flash_mxc_flash }
+	directory	devs/flash/arm/mxc
+	script		mxc_flash_select.cdl
+	hardware
+        description "
+           This package contains hardware support for NOR/NAND selections on
+           Freescale MXC-based platforms."
+}
+
+package CYGPKG_DEVS_MXC_I2C {
+	alias 		{ "Support I2C on Freescale MXC platforms" fsl_mxc_i2c }
+	directory	devs/i2c/arm/mxc
+	script		mxc_i2c.cdl
+	hardware
+        description "
+           This package contains hardware support for I2C selections on
+           Freescale MXC-based platforms."
+}
+
+package CYGPKG_DEVS_MXC_SPI {
+	alias 		{ "Support SPI on Freescale MXC platforms" fsl_mxc_spi }
+	directory	devs/spi/arm/mxc
+	script		spi.cdl
+	hardware
+        description "
+           This package contains hardware support for SPI selections on
+           Freescale MXC-based platforms."
+}
+
 package CYGPKG_DEVS_FLASH_ATMEL_AT29CXXXX {
 	alias 		{ "Support for Atmel AT29Cxxxx flash memory" flash_atmel_at29cxxxx }
 	directory	devs/flash/atmel/at29cxxxx
@@ -649,6 +679,96 @@
 	   on the Motorola PowerPC/860 MBX platform."
 }
 
+package CYGPKG_DEVS_FLASH_MX1ADS {
+	alias 		{ "FLASH memory support for Freescale MX1 ADS board" flash_mx1ads }
+	directory	devs/flash/arm/mx1ads
+	script		flash_mx1ads.cdl
+	hardware
+        description "
+           This package contains hardware support for FLASH memory
+	   on the Freescale MX1 ads platform."
+}
+
+package CYGPKG_DEVS_FLASH_ARM_AMD_AM29 {
+	alias 		{ "FLASH memory support for AMD AM29" flash_am29 }
+	directory	devs/flash/arm/am29
+	script		flash_am29.cdl
+	hardware
+        description "
+           This package contains hardware support for AMD Am29 FLASH memory
+	   "
+}
+
+package CYGPKG_DEVS_FLASH_MX31ADS_STRATA {
+	alias 		{ "FLASH memory support for MX31ADS" flash_mx31ads }
+	directory	devs/flash/arm/mx31ads
+	script		flash_board_strata.cdl
+	hardware
+        description "
+           This package contains hardware support for FLASH memory
+	   on the MX31ADS platform."
+}
+
+package CYGPKG_DEVS_FLASH_MX31ADS_SPANSION {
+	alias 		{ "FLASH memory support for MX31ADS" flash_mx31ads }
+	directory	devs/flash/arm/mx31ads
+	script		flash_board_spansion.cdl
+	hardware
+        description "
+           This package contains hardware support for FLASH memory
+	   on the MX31ADS platform."
+}
+
+package CYGPKG_DEVS_FLASH_IMX_3STACK_SPANSION {
+	alias 		{ "FLASH memory support for IMX 3-Stack board" flash_imx_3stack }
+	directory	devs/flash/arm/imx_3stack
+	script		flash_board_spansion.cdl
+	hardware
+        description "
+           This package contains hardware support for FLASH memory
+	   on the i.MX 3-Stack platform."
+}
+
+package CYGPKG_DEVS_FLASH_MX35EVB_SPANSION {
+	alias 		{ "FLASH memory support for MX35EVB" flash_mx35evb }
+	directory	devs/flash/arm/mx35evb
+	script		flash_board_spansion.cdl
+	hardware
+        description "
+           This package contains hardware support for FLASH memory
+	   on the MX35EVB platform."
+}
+
+package CYGPKG_DEVS_FLASH_MX27ADS_SPANSION {
+	alias 		{ "FLASH memory support for MX27ADS" flash_mx27ads }
+	directory	devs/flash/arm/mx27ads
+	script		flash_board_spansion.cdl
+	hardware
+        description "
+           This package contains hardware support for FLASH memory
+	   on the MX27ADS platform."
+}
+
+package CYGPKG_DEVS_FLASH_MXC30030EVB_SPANSION {
+	alias 		{ "FLASH memory support for MXC300-30" flash_mxc30030evb }
+	directory	devs/flash/arm/mxc30030evb
+	script		flash_board_spansion.cdl
+	hardware
+        description "
+           This package contains hardware support for FLASH memory
+	   on the MXC300-30 EVB platform."
+}
+
+ package CYGPKG_DEVS_FLASH_I30030ADS {
+         alias           { "FLASH memory support for i.300-30 ADS" flash_i30030ads}
+         directory       devs/flash/arm/i30030ads
+         script          flash_board_strata.cdl
+         hardware
+         description "
+            This package contains hardware support for FLASH memory
+            on the i.300-30 ADS platform."
+}
+
 package CYGPKG_DEVS_FLASH_TS6 {
 	alias 		{ "FLASH memory support for Delphi Communication Systems, Inc. TigerSHARC6 Board" flash_ts6 }
 	directory	devs/flash/powerpc/ts6
@@ -822,7 +942,7 @@
                         devs_serial_arm_ebsa285 ebsa285_serial_driver }
     hardware
     directory	      devs/serial/arm/ebsa285
-    script	      ser_arm_ebsa285.cdl	
+    script	      ser_arm_ebsa285.cdl
     description       "Intel StrongARM/EBSA285 serial device drivers"
 }
 
@@ -831,7 +951,7 @@
                         devs_serial_arm_iop310 iop310_serial_driver }
     hardware
     directory	      devs/serial/arm/iop310
-    script	      ser_arm_iop310.cdl	
+    script	      ser_arm_iop310.cdl
     description       "Intel XScale IOP310 serial device drivers"
 }
 
@@ -840,7 +960,7 @@
                         devs_serial_arm_iq80321 iq80321_serial_driver }
     hardware
     directory	      devs/serial/arm/iq80321
-    script	      ser_arm_iq80321.cdl	
+    script	      ser_arm_iq80321.cdl
     description       "Intel XScale/IQ80321 serial device drivers"
 }
 
@@ -849,7 +969,7 @@
                         devs_serial_arm_sa11x0 sa11x0_serial_driver }
     hardware
     directory	      devs/serial/arm/sa11x0
-    script	      ser_arm_sa11x0.cdl	
+    script	      ser_arm_sa11x0.cdl
     description       "Intel StrongARM/SA11x0 serial device drivers"
 }
 
@@ -858,7 +978,7 @@
                         devs_serial_arm_pid pid_serial_driver }
     hardware
     directory	      devs/serial/arm/pid
-    script	      ser_arm_pid.cdl	
+    script	      ser_arm_pid.cdl
     description       "ARM PID serial device drivers"
 }
 
@@ -867,7 +987,7 @@
                         devs_serial_arm_cerfpda cerfpda_serial_driver }
     hardware
     directory	      devs/serial/arm/cerfpda
-    script	      ser_arm_cerfpda.cdl	
+    script	      ser_arm_cerfpda.cdl
     description       "Cerfpda serial device drivers"
 }
 
@@ -876,7 +996,7 @@
                         devs_serial_arm_aeb aeb_serial_driver }
     hardware
     directory	      devs/serial/arm/aeb
-    script	      ser_arm_aeb.cdl	
+    script	      ser_arm_aeb.cdl
     description       "ARM AEB-1 serial device drivers"
 }
 
@@ -894,7 +1014,7 @@
                         devs_serial_arm_smdk2410 smdk2410_serial_driver }
     hardware
     directory         devs/serial/arm/smdk2410
-    script            ser_arm_smdk2410.cdl        
+    script            ser_arm_smdk2410.cdl
     description       "Samsung ARM9/SMDK2410 board serial device drivers"
 }
 
@@ -903,7 +1023,7 @@
                         devs_serial_arm_edb7xxx edb7xxx_serial_driver }
     hardware
     directory	      devs/serial/arm/edb7xxx
-    script	      ser_arm_edb7xxx.cdl	
+    script	      ser_arm_edb7xxx.cdl
     description       "Cirrus Logic ARM based development board serial
                        device drivers"
 }
@@ -913,7 +1033,7 @@
                         devs_serial_arm_cma230 cma230_serial_driver }
     hardware
     directory	      devs/serial/arm/cma230
-    script	      ser_arm_cma230.cdl	
+    script	      ser_arm_cma230.cdl
     description       "Cogent ARM/CMA230 serial device drivers"
 }
 
@@ -922,7 +1042,7 @@
                         devs_serial_arm_e7t e7t_serial_driver }
     hardware
     directory         devs/serial/arm/e7t
-    script            ser_arm_e7t.cdl   
+    script            ser_arm_e7t.cdl
     description       "ARM AEB-2 (E7T) serial device drivers"
 }
 
@@ -950,7 +1070,7 @@
                         devs_serial_arm_integrator integrator_serial_driver }
     hardware
     directory         devs/serial/arm/integrator
-    script            ser_arm_integrator.cdl    
+    script            ser_arm_integrator.cdl
     description       "ARM INTEGRATOR serial device drivers"
 }
 
@@ -959,7 +1079,7 @@
                         devs_serial_arm_at91 at91_serial_driver }
     hardware
     directory	      devs/serial/arm/at91
-    script	      ser_arm_at91.cdl	
+    script	      ser_arm_at91.cdl
     description       "Atmel AT91 on-chip serial device driver."
 }
 
@@ -978,7 +1098,7 @@
                         devs_serial_powerpc_cogent cogent_serial_driver }
     hardware
     directory	      devs/serial/powerpc/cogent
-    script	      ser_powerpc_cogent.cdl	
+    script	      ser_powerpc_cogent.cdl
     description       "Cogent PowerPC serial device drivers"
 }
 
@@ -987,7 +1107,7 @@
                         devs_serial_powerpc_ec555 ec555_serial_driver }
     hardware
     directory	      devs/serial/powerpc/ec555
-    script	      ser_powerpc_ec555.cdl	
+    script	      ser_powerpc_ec555.cdl
     description       "ec555 PowerPC serial device drivers"
 }
 
@@ -996,7 +1116,7 @@
                         devs_serial_powerpc_cme555 cme555_serial_driver }
     hardware
     directory	      devs/serial/powerpc/cme555
-    script	      ser_powerpc_cme555.cdl	
+    script	      ser_powerpc_cme555.cdl
     description       "cme555 PowerPC serial device drivers"
 }
 
@@ -1007,7 +1127,7 @@
                         devs_serial_powerpc_quicc quicc_serial_driver }
     hardware
     directory	      devs/serial/powerpc/quicc
-    script	      ser_quicc_smc.cdl	
+    script	      ser_quicc_smc.cdl
     description       "PowerPC QUICC/SMC serial device drivers"
 }
 
@@ -1016,7 +1136,7 @@
                         devs_serial_powerpc_mpc8xxx mpc8xxx_serial_driver }
     hardware
     directory	      devs/serial/powerpc/mpc8xxx
-    script	      ser_mpc8xxx.cdl	
+    script	      ser_mpc8xxx.cdl
     description       "PowerPC MPC8XXX (QUICC-II) serial device drivers"
 }
 
@@ -1027,7 +1147,7 @@
                         devs_serial_powerpc_quicc2 quicc2_serial_driver }
     hardware
     directory	      devs/serial/powerpc/quicc2
-    script	      ser_quicc2_scc.cdl	
+    script	      ser_quicc2_scc.cdl
     description       "PowerPC VADS QUICC2/SCC serial device drivers"
 }
 
@@ -1035,7 +1155,7 @@
     alias             { "PowerPC PPC405GP serial device drivers" devs_serial_ppc405 }
     hardware
     directory	      devs/serial/powerpc/ppc405
-    script	      ser_powerpc_ppc405.cdl	
+    script	      ser_powerpc_ppc405.cdl
     description       "PowerPC PPC405GP serial device drivers"
 }
 
@@ -1044,7 +1164,7 @@
                         devs_serial_sparclite_sleb sleb_serial_driver }
     hardware
     directory	      devs/serial/sparclite/sleb
-    script	      ser_sparclite_sleb.cdl	
+    script	      ser_sparclite_sleb.cdl
     description       "SPARClite SLEB serial device drivers"
 }
 
@@ -1054,7 +1174,7 @@
                         devs_serial_mips_jmr3904 tx3904_serial_driver }
     hardware
     directory	      devs/serial/mips/jmr3904
-    script	      ser_mips_jmr3904.cdl	
+    script	      ser_mips_jmr3904.cdl
     description       "TX39 JMR3904 serial device drivers"
 }
 
@@ -1064,7 +1184,7 @@
                         devs_serial_mips_atlas mips_atlas_serial_driver }
     hardware
     directory	      devs/serial/mips/atlas
-    script	      ser_mips_atlas.cdl	
+    script	      ser_mips_atlas.cdl
     description       "Atlas serial device drivers"
 }
 
@@ -1073,7 +1193,7 @@
                         devs_serial_mips_ref4955 ref4955_serial_driver }
     hardware
     directory	      devs/serial/mips/ref4955
-    script	      ser_mips_ref4955.cdl	
+    script	      ser_mips_ref4955.cdl
     description       "TX49 REF4955 serial device drivers"
 }
 
@@ -1082,7 +1202,7 @@
                         devs_serial_mips_vrc437x vrc437x_serial_driver }
     hardware
     directory	      devs/serial/mips/vrc437x
-    script	      ser_mips_vrc437x.cdl	
+    script	      ser_mips_vrc437x.cdl
     description       "VRC437X serial device drivers"
 }
 
@@ -1092,7 +1212,7 @@
                         devs_serial_mn10300 mn10300_serial_driver }
     hardware
     directory	      devs/serial/mn10300/mn10300
-    script	      ser_mn10300.cdl	
+    script	      ser_mn10300.cdl
     description       "MN10300 serial device drivers"
 }
 
@@ -1101,7 +1221,7 @@
                         devs_serial_i386_pc pc_serial_driver }
     hardware
     directory	      devs/serial/i386/pc
-    script	      ser_i386_pc.cdl	
+    script	      ser_i386_pc.cdl
     description       "PC serial device drivers"
 }
 
@@ -1119,7 +1239,7 @@
                         devs_serial_sh_sci sci_serial_driver }
     hardware
     directory	      devs/serial/sh/sci
-    script	      ser_sh_sci.cdl	
+    script	      ser_sh_sci.cdl
     description       "SH SCI serial device drivers"
 }
 
@@ -1128,10 +1248,19 @@
                         devs_serial_sh_scif scif_serial_driver }
     hardware
     directory	      devs/serial/sh/scif
-    script	      ser_sh_scif.cdl	
+    script	      ser_sh_scif.cdl
     description       "SH SCIF serial device drivers"
 }
 
+package CYGPKG_DEVS_ETH_ARM_I30030ADS {
+    alias           { "Ethernet driver for Freescale i.300-30 ADS board" i30030ads_eth_driver }
+    hardware
+    directory       devs/eth/arm/i30030ads
+    script          board_eth_drivers.cdl
+    description     "Ethernet driver for Freescale i.300-30 ADS
+                    development boards."
+}
+
 package CYGPKG_DEVS_ETH_PHY {
 	alias 		{ "Generic PHY support" eth_phy_support }
 	hardware
@@ -1171,7 +1300,7 @@
                         devs_serial_sh_edk7708 edk7708_serial_driver }
     hardware
     directory	      devs/serial/sh/edk7708
-    script	      ser_sh_edk7708.cdl	
+    script	      ser_sh_edk7708.cdl
     description       "SH3 EDK7708 serial device drivers"
 }
 
@@ -1181,7 +1310,7 @@
                         devs_serial_sh_cq7708 cq7708_serial_driver }
     hardware
     directory	      devs/serial/sh/cq7708
-    script	      ser_sh_cq7708.cdl	
+    script	      ser_sh_cq7708.cdl
     description       "SH3 cq7708 serial device drivers"
 }
 
@@ -1190,7 +1319,7 @@
                         devs_serial_sh3_se77x9 se77x9_serial_driver }
     hardware
     directory	      devs/serial/sh/se77x9
-    script	      ser_sh_se77x9.cdl	
+    script	      ser_sh_se77x9.cdl
     description       "SH3 SE77x9 serial device driver"
 }
 
@@ -1199,7 +1328,7 @@
                         devs_serial_sh3_se77x9 se77x9_serial_driver }
     hardware
     directory	      devs/serial/sh/sh4_202_md
-    script	      ser_sh4_202_md.cdl	
+    script	      ser_sh4_202_md.cdl
     description       "This option enables the serial device drivers for the
         SuperH SH4-202 MicroDev board, based on the generic SH SCIF driver."
 }
@@ -1209,7 +1338,7 @@
                         devs_serial_v85x_v850 v850_serial_driver }
     hardware
     directory	      devs/serial/v85x/v850
-    script	      ser_v85x_v850.cdl	
+    script	      ser_v85x_v850.cdl
     description       "Serial device drivers for systems based on NEC V850
                        SA1 (70F3017) or SB1 (70F3033) processors."
 }
@@ -1219,7 +1348,7 @@
                         devs_serial_mips_upd985xx upd985xx_serial_driver }
     hardware
     directory	      devs/serial/mips/upd985xx
-    script	      ser_mips_upd985xx.cdl	
+    script	      ser_mips_upd985xx.cdl
     description       "NEC MIPS uPD985xx serial device drivers"
 }
 
@@ -1229,7 +1358,7 @@
                         devs_serial_mips_idt79s334 mips_idt79s334a_serial_driver }
     hardware
     directory	      devs/serial/mips/idt79s334a
-    script	      ser_mipsidt_334a.cdl	
+    script	      ser_mipsidt_334a.cdl
     description       "IDT 334a reference platform serial device drivers"
 }
 
@@ -1238,7 +1367,7 @@
                         devs_serial_h8300h_sci sci_serial_driver }
     hardware
     directory       devs/serial/h8300/h8300h
-    script          serial_h8300.cdl  
+    script          serial_h8300.cdl
     description       "H8/300 SCI serial device drivers"
 }
 
@@ -1247,7 +1376,7 @@
                          devs_MCF5272_uart_driver }
     hardware
     directory	      devs/serial/mcf52xx/mcf5272
-    script	      ser_mcf5272_uart.cdl	
+    script	      ser_mcf5272_uart.cdl
     description       "Serial MCF5272 UART Drivers."
 }
 
@@ -1255,7 +1384,7 @@
     alias             { "Loop serial device drivers"
                         devs_serial_loop loop_serial_driver }
     directory	      devs/serial/loop
-    script	      ser_loop.cdl	
+    script	      ser_loop.cdl
     description       "Loopback serial device driver."
 }
 
@@ -1310,7 +1439,7 @@
         description     "Platform independent ethernet support."
 }
 
-package CYGPKG_IO_USB { 
+package CYGPKG_IO_USB {
         alias           { "Generic USB support" usb }
         hardware
         directory       io/usb/common
@@ -1348,6 +1477,14 @@
         script          usbs_upd985xx.cdl
         description     "A device driver for the NEC uPD985xx on-chip USB device"
 }
+
+package CYGPKG_DEVS_USB_MXC {
+        alias           { usb_mxc }
+        hardware
+        directory       devs/usb/mxc
+        script          usbs_mxc.cdl
+        description     "A device driver for the FSL MXC on-chip USB device"
+}
 
 package CYGPKG_NET {
 	alias 		{ "Networking" net }
@@ -1410,9 +1547,9 @@
         directory       net/sntp
         script          sntp.cdl
         description "
-This package provides a SNTP client which can recieve broadcast time 
+This package provides a SNTP client which can recieve broadcast time
 information and set the system clock."
-}  
+}
 
 package CYGPKG_PPP {
 	alias 		{ "PPP support" ppp }
@@ -1426,7 +1563,7 @@
         directory       net/ipsec/libipsec
         script          libipsec.cdl
         description "
-This package provides the libipsec library used by racoon etc for 
+This package provides the libipsec library used by racoon etc for
 configuring IPSEC"
 }
 
@@ -1456,6 +1593,61 @@
         description     "Ethernet driver for Agilent AAED2000
                          development boards."
 }
+
+package CYGPKG_DEVS_ETH_ARM_MX1ADS {
+	alias 		{ "Ethernet driver for Freescale MX1 ADS board" mx1ads_eth_driver }
+	hardware
+	directory	devs/eth/arm/mx1ads
+	script		mx1ads_eth_drivers.cdl
+        description     "Ethernet driver for Freescale MX1 ADS
+                         development boards."
+}
+
+package CYGPKG_DEVS_ETH_ARM_MX21ADS {
+	alias 		{ "Ethernet driver for Freescale MX21 ADS board" mx21ads_eth_driver }
+	hardware
+	directory	devs/eth/arm/mx21ads
+	script		board_eth_drivers.cdl
+        description     "Ethernet driver for Freescale MX21 ADS
+                         development boards."
+}
+
+package CYGPKG_DEVS_ETH_ARM_MX27ADS {
+	alias 		{ "Ethernet driver for Freescale MX27 ADS board" mx27ads_eth_driver }
+	hardware
+	directory	devs/eth/arm/mx27ads
+	script		board_eth_drivers.cdl
+        description     "Ethernet driver for Freescale MX27 ADS
+                         development boards."
+}
+
+package CYGPKG_DEVS_ETH_ARM_IMX_3STACK {
+	alias 		{ "Ethernet driver for Freescale 3-Stack board" imx_3stack_eth_driver }
+	hardware
+	directory	devs/eth/arm/imx_3stack
+	script		board_eth_drivers.cdl
+        description     "Ethernet driver for Freescale 3-Stack
+                         development boards."
+}
+
+package CYGPKG_DEVS_ETH_ARM_MX31ADS {
+	alias 		{ "Ethernet driver for Freescale MX31 ADS board" mx31ads_eth_driver }
+	hardware
+	directory	devs/eth/arm/mx31ads
+	script		board_eth_drivers.cdl
+        description     "Ethernet driver for Freescale MX31 ADS
+                         development boards."
+}
+
+package CYGPKG_DEVS_ETH_ARM_MXC30030EVB {
+	alias 		{ "Ethernet driver for Freescale MXC300-30 EVB board" mxc30030evb_eth_driver}
+	hardware
+	directory	devs/eth/arm/mxc30030evb
+	script		board_eth_drivers.cdl
+        description     "Ethernet driver for Freescale MXC300-30 EVB
+                         development boards."
+}
+
 package CYGPKG_DEVS_ETH_AMD_PCNET {
 	alias 		{ "AMD PCNET ethernet driver" pcnet_eth_driver }
 	hardware
@@ -1796,6 +1988,14 @@
 	script		cl_cs8900a_eth_drivers.cdl
         description     "Ethernet driver for Cirrus Logic CS8900A controller."
 }
+
+package CYGPKG_DEVS_ETH_FEC {
+        alias           { "MXC FEC ethernet driver" mxc_fec_eth_driver }
+        hardware
+        directory       devs/eth/fec
+        script          fec_eth_drivers.cdl
+        description     "Ethernet driver for FEC controller."
+}
 
 package CYGPKG_DEVS_ETH_MIPS_UPD985XX {
 	alias		{ "NEC uPD985xx ethernet driver" uPD985xx_eth_driver }
@@ -1910,7 +2110,7 @@
 	script          wallclock_ds1307.cdl
 	hardware
         description "
-           This package provides a driver implementation for 
+           This package provides a driver implementation for
            the Dallas 1307 wallclock."
 }
 
@@ -1920,7 +2120,7 @@
 	script          wallclock_ds1742.cdl
 	hardware
         description "
-           This package provides a driver implementation for 
+           This package provides a driver implementation for
            the Dallas 1742 wallclock."
 }
 
@@ -1930,7 +2130,7 @@
 	script          wallclock_ds12887.cdl
 	hardware
         description "
-           This package provides a driver implementation for 
+           This package provides a driver implementation for
            the Dallas 12887 wallclock."
 }
 
@@ -2192,19 +2392,19 @@
         directory       services/crc
         script          crc.cdl
         description "
-This package provides support for CRC functions, including the 
+This package provides support for CRC functions, including the
 POSIX 1003 defined CRC algorithm."
-}  
+}
 
 package CYGPKG_CPULOAD {
         alias           { "cpuload support" cpuload }
         directory       services/cpuload
         script          cpuload.cdl
         description "
-This package measures the CPU load over the last 100ms, 1second 
+This package measures the CPU load over the last 100ms, 1second
 and 10 second. All loads are returned as a percentage, ie 0-100.
 This is only a rough measure."
-}     
+}
 
 package CYGPKG_PROFILE_GPROF {
         alias           { "Application profile support" profile_gprof gprof_profile }
@@ -2213,15 +2413,22 @@
         description "
 This package instruments applications to collect profiling data,
 using a methodology compatible with the gprof utility."
-}     
-                  
+}
+
 package CYGPKG_EZXML {
         alias           { "ezXML" XML ezxml }
         directory       services/ezxml
         script          ezxml.cdl
         description     "ezXML, Simple XML Parser"
 }
-                 
+
+package CYGPKG_DIAGNOSIS {
+        alias           { "Diagnosis" DIAGNOSIS diagnosis }
+        directory       services/diagnosis
+        script          diagnosis.cdl
+        description     "Diagnosis"
+}
+
 package CYGPKG_UITRON {
 	alias		{ "uITRON compatibility" uitron }
 	directory	compat/uitron
@@ -2455,7 +2662,7 @@
         script          hal_arm_integrator.cdl
         hardware
         description "
-        The INTEGRATOR HAL package provides the support needed to 
+        The INTEGRATOR HAL package provides the support needed to
         run eCos on a ARM INTEGRATOR eval board."
 }
 
@@ -2474,7 +2681,7 @@
 	script		hal_arm_at91_jtst.cdl
 	hardware
         description "
-	The JTST HAL package provides the support needed to run eCos on 
+	The JTST HAL package provides the support needed to run eCos on
         the Atmel evaluation board AT572D74-DK1."
 }
 
@@ -2515,7 +2722,7 @@
 	script		hal_arm_at91_eb55.cdl
 	hardware
         description "
-	The eb55 HAL package provides the support needed to run eCos on an 
+	The eb55 HAL package provides the support needed to run eCos on an
         Atmel evaluation board (EB55)."
 }
 
@@ -2525,9 +2732,9 @@
 	script		hal_arm_at91_phycore.cdl
 	hardware
         description "
-	The phyCORE HAL package provides the support needed to run eCos on 
+	The phyCORE HAL package provides the support needed to run eCos on
         an PHYTEC evaluation board (phyCORE AT91M55800A based on HD200)."
-} 
+}
 
 package CYGPKG_HAL_ARM_LPC2XXX {
         alias           { "Philips LPC2XXX variant HAL" hal_arm_lpc2xxx arm_lpc2xxx_hal }
@@ -2545,7 +2752,7 @@
         script          hal_arm_lpc2xxx_mcb2100.cdl
         hardware
         description "
-        The mcb2100 HAL package provides the support needed to run eCos on an 
+        The mcb2100 HAL package provides the support needed to run eCos on an
         the MCB2100 evaluation board from Keil."
 }
 
@@ -2565,7 +2772,7 @@
 	script		hal_arm_lpc2xxx_lpcmt.cdl
 	hardware
 	description "
-	The lpcmt HAL package provides the support needed to run eCos on an the 
+	The lpcmt HAL package provides the support needed to run eCos on an the
 	LPC-MT evaluation board from Olimex."
 }
 package CYGPKG_HAL_ARM_EBSA285 {
@@ -2627,7 +2834,7 @@
         description "
         The Innovator HAL package provides the support needed to run
         RedBoot on the ARM processor of the Innovator.
-	
+
 	NOTE: Full support for eCos is not provided yet.  This HAL
 	contains only the minimum amount necessary to run RedBoot
 	on the Innovator.  In particular, interrupts are not yet
@@ -2713,6 +2920,13 @@
         description     "Ethernet driver for SMSC LAN91CXX (LAN9000) controller."
 }
 
+package CYGPKG_DEVS_ETH_SMSC_LAN92XX {
+	alias 		{ "SMSC LAN92XX ethernet driver" lan92xx_eth_driver lan9217_eth_driver }
+	hardware
+	directory	devs/eth/smsc/lan92xx
+	script		smsc_lan92xx_eth_drivers.cdl
+        description     "Ethernet driver for SMSC LAN92XX (LAN9217) controller."
+}
 
 package CYGPKG_HAL_ARM_SA11X0_NANO {
 	alias		{ "Intel SA1110 nanoEngine eval board" hal_arm_sa11x0_nano }
@@ -2769,7 +2983,7 @@
 	script		hal_arm_cma230.cdl
 	hardware
         description "
-The cma230 HAL package provides the support needed to run eCos on a Cogent 
+The cma230 HAL package provides the support needed to run eCos on a Cogent
 CMA230 (ARM7TDMI) or CMA222 (ARM710T) eval board."
 }
 
@@ -2811,7 +3025,7 @@
 	hardware
 	description "
 	The IQ80310 HAL package provides the support needed to run
-	eCos on an Intel Cyclone evaluation board, utilizing an Intel XScale 
+	eCos on an Intel Cyclone evaluation board, utilizing an Intel XScale
         IQ80200/80310 chipset."
 }
 
@@ -2822,7 +3036,7 @@
 	hardware
 	description "
 	The NPWR HAL package provides the support needed to run
-	eCos on a NPWR Linux Engine, utilizing an Intel XScale 
+	eCos on a NPWR Linux Engine, utilizing an Intel XScale
         IQ80200/80310 chipset."
 }
 
@@ -2924,6 +3138,225 @@
         eCos on a MPC 5.0."
 }
 
+package CYGPKG_HAL_ARM_MDBMX1 {
+	alias		{ "Freescale MC9328MX1 Chipset" hal_arm_mdbmx1 }
+	directory	hal/arm/mdbmx1/var
+	script		hal_arm_mdbmx1.cdl
+	hardware
+        description "
+        The MDBMX1 HAL package provides the support needed to run
+        eCos on Freescale MC9328MX1 based systems."
+}
+
+package CYGPKG_HAL_ARM_MDBMX1_ADS {
+	alias		{ "Freescale MC9328MX1 ADS board" hal_arm_mdbmx1_ads }
+	directory	hal/arm/mdbmx1/ads
+	script		hal_arm_mdbmx1_ads.cdl
+	hardware
+        description "
+        The ADS HAL package provides the support needed to run
+        eCos on a Freescale MC9328MX1 ADS board."
+}
+
+package CYGPKG_HAL_ARM_MX21 {
+	alias		{ "Freescale i.MX21 Chipset" hal_arm_mx21 }
+	directory	hal/arm/mx21/var
+	script		hal_arm_soc.cdl
+	hardware
+        description "
+        The MX21 HAL package provides the support needed to run
+        eCos on Freescale i.MX21 based systems."
+}
+
+package CYGPKG_HAL_ARM_MX21ADS {
+	alias		{ "Freescale i.MX21 ADS board" hal_arm_mx21ads }
+	directory	hal/arm/mx21/ads
+	script		hal_arm_board.cdl
+	hardware
+        description "
+        The ADS HAL package provides the support needed to run
+        eCos on a Freescale i.MX21 ADS board."
+}
+
+package CYGPKG_HAL_ARM_MX27 {
+	alias		{ "Freescale i.MX27 Chipset" hal_arm_mx27 }
+	directory	hal/arm/mx27/var
+	script		hal_arm_soc.cdl
+	hardware
+        description "
+        The MX21 HAL package provides the support needed to run
+        eCos on Freescale i.MX27 based systems."
+}
+
+package CYGPKG_HAL_ARM_MX27ADS {
+	alias		{ "Freescale i.MX27 ADS board" hal_arm_mx27ads }
+	directory	hal/arm/mx27/ads
+	script		hal_arm_board.cdl
+	hardware
+        description "
+        The ADS HAL package provides the support needed to run
+        eCos on a Freescale i.MX27 ADS board."
+}
+
+package CYGPKG_HAL_ARM_MX27_3STACK {
+	alias		{ "Freescale i.MX27 3-Stack board" hal_arm_mx27_3stack }
+	directory	hal/arm/mx27/3stack
+	script		hal_arm_board.cdl
+	hardware
+        description "
+        The 3-Stack HAL package provides the support needed to run
+        eCos on a Freescale i.MX27 3-Stack board."
+}
+
+package CYGPKG_HAL_ARM_MX31 {
+	alias		{ "Freescale i.MX31 Chipset" hal_arm_mx31 }
+	directory	hal/arm/mx31/var
+	script		hal_arm_soc.cdl
+	hardware
+        description "
+        The MX31 HAL package provides the support needed to run
+        eCos on Freescale i.MX31 based systems."
+}
+
+package CYGPKG_HAL_ARM_MX35 {
+	alias		{ "Freescale i.MX35 Chipset" hal_arm_mx35 }
+	directory	hal/arm/mx35/var
+	script		hal_arm_soc.cdl
+	hardware
+        description "
+        The MX35 HAL package provides the support needed to run
+        eCos on Freescale i.MX35 based systems."
+}
+
+package CYGPKG_HAL_ARM_MX35EVB {
+	alias		{ "Freescale i.MX35 EVB board" hal_arm_mx35evb }
+	directory	hal/arm/mx35/evb
+	script		hal_arm_board.cdl
+	hardware
+        description "
+        The ADS HAL package provides the support needed to run
+        eCos on a Freescale i.MX35 EVB board."
+}
+
+package CYGPKG_HAL_ARM_MX37 {
+	alias		{ "Freescale i.MX37 Chipset" hal_arm_mx37 }
+	directory	hal/arm/mx37/var
+	script		hal_arm_soc.cdl
+	hardware
+        description "
+        The MX37 HAL package provides the support needed to run
+        eCos on Freescale i.MX37 based systems."
+}
+
+package CYGPKG_HAL_ARM_MX51 {
+	alias		{ "Freescale i.MX51 Chipset" hal_arm_mx51 }
+	directory	hal/arm/mx51/var
+	script		hal_arm_soc.cdl
+	hardware
+        description "
+        The MX51 HAL package provides the support needed to run
+        eCos on Freescale i.MX51 based systems."
+}
+
+package CYGPKG_HAL_ARM_MXC91321 {
+	alias		{ "Freescale MXC91321 Chipset" hal_arm_mxc91321 }
+	directory	hal/arm/mxc91321/var
+	script		hal_arm_soc.cdl
+	hardware
+        description "
+        The MXC91321 HAL package provides the support needed to run
+        eCos on Freescale MXC91321 based systems."
+}
+
+package CYGPKG_HAL_ARM_MXC91321_CHIP_DEF {
+	alias		{ "Freescale MXC91321 Chipset" hal_arm_mxc91321_def }
+	directory	hal/arm/mxc91321/var
+	script		hal_arm_mxc91321_def.cdl
+	hardware
+        description "
+        MXC91321 specific defines."
+}
+
+package CYGPKG_HAL_ARM_MX31ADS {
+	alias		{ "Freescale i.MX31 ADS board" hal_arm_mx31ads }
+	directory	hal/arm/mx31/ads
+	script		hal_arm_board.cdl
+	hardware
+        description "
+        The ADS HAL package provides the support needed to run
+        eCos on a Freescale i.MX31 ADS board."
+}
+
+package CYGPKG_HAL_ARM_MX31_3STACK {
+	alias		{ "Freescale i.MX31 3-Stack board" hal_arm_mx31_3stack }
+	directory	hal/arm/mx31/3stack
+	script		hal_arm_board.cdl
+	hardware
+        description "
+        The 3-Stack HAL package provides the support needed to run
+        eCos on a Freescale i.MX31 3-Stack board."
+}
+
+package CYGPKG_HAL_ARM_MX35_3STACK {
+	alias		{ "Freescale i.MX35 3-Stack board" hal_arm_mx35_3stack }
+	directory	hal/arm/mx35/3stack
+	script		hal_arm_board.cdl
+	hardware
+        description "
+        The 3-Stack HAL package provides the support needed to run
+        eCos on a Freescale i.MX35 3-Stack board."
+}
+
+package CYGPKG_HAL_ARM_MX37_3STACK {
+	alias		{ "Freescale i.MX37 3-Stack board" hal_arm_mx37_3stack }
+	directory	hal/arm/mx37/3stack
+	script		hal_arm_board.cdl
+	hardware
+        description "
+        The 3-Stack HAL package provides the support needed to run
+        eCos on a Freescale i.MX37 3-Stack board."
+}
+
+package CYGPKG_HAL_ARM_MX51_3STACK {
+	alias		{ "Freescale i.MX51 3-Stack board" hal_arm_mx51_3stack }
+	directory	hal/arm/mx51/3stack
+	script		hal_arm_board.cdl
+	hardware
+        description "
+        The 3-Stack HAL package provides the support needed to run
+        eCos on a Freescale i.MX51 3-Stack board."
+}
+
+package CYGPKG_HAL_ARM_MXC30030EVB {
+	alias		{ "Freescale MXC300-30 EVB board" hal_arm_mxc30030evb }
+	directory	hal/arm/mxc91321/evb
+	script		hal_arm_board.cdl
+	hardware
+        description "
+        The ADS HAL package provides the support needed to run
+        eCos on a Freescale MXC300-30 EVB board."
+}
+
+package CYGPKG_HAL_ARM_MXC30030ADS {
+	alias		{ "Freescale MXC300-30 ADS board" hal_arm_mxc30030ads }
+	directory	hal/arm/mxc91321/mxc30030ads
+	script		hal_arm_board.cdl
+	hardware
+        description "
+        The MXC300-30 ADS HAL package provides the support needed to run
+        eCos on a Freescale MXC300-30 ADS board."
+}
+
+package CYGPKG_HAL_ARM_MXC30030TOPAZ {
+	alias		{ "Freescale MXC300-30 TOPAZ board" hal_arm_mxc30030topaz }
+	directory	hal/arm/mxc91321/mxc30030topaz
+	script		hal_arm_board.cdl
+	hardware
+        description "
+        The MXC300-30 TOPAZ HAL package provides the support needed to run
+        eCos on a Freescale MXC300-30 TOPAZ board."
+}
+
 # --------------------------------------------------------------------------
 # SH packages
 package CYGPKG_HAL_SH {
@@ -3092,7 +3525,7 @@
 	hardware
         description "
            The aki3068net HAL package provides the support needed to run
-           eCos on a Akizuki H8/3068 Network micom board." 
+           eCos on a Akizuki H8/3068 Network micom board."
 }
 
 package CYGPKG_HAL_H8300_H8300H_H8MAX {
@@ -3102,7 +3535,7 @@
 	hardware
         description "
            The h8max HAL package provides the support needed to run
-           eCos on a H8MAX board." 
+           eCos on a H8MAX board."
 }
 
 package CYGPKG_HAL_H8300_H8S_SIM {
@@ -3125,7 +3558,7 @@
 	hardware
         description "
            The edosk2674 HAL package provides the support needed to run
-           eCos on a Hitachi Micro System Europe EDOSK-2674 Evalution board." 
+           eCos on a Hitachi Micro System Europe EDOSK-2674 Evalution board."
 }
 
 # ==========================================================================
@@ -3152,7 +3585,7 @@
     	    The i386 generic Target HAL package provides support
             for generic IA32 processors, from the 80386 to the latest
             Pentium/Athlon."
-	    
+
 }
 package CYGPKG_HAL_I386_PCMB {
 	alias		{ "i386 PC Motherboard" hal_i386_pcmb }
@@ -3160,7 +3593,7 @@
 	script		hal_i386_pcmb.cdl
 	hardware
         description "
-    	    The i386 PC Motherboard HAL package provides the 
+    	    The i386 PC Motherboard HAL package provides the
     	    support needed to run eCos binaries on a standard i386
     	    PC motherboard. This is a support package for various
             actual platform specific targets."
@@ -3171,7 +3604,7 @@
 	script		hal_i386_pc.cdl
 	hardware
         description "
-    	    The i386 PC Target HAL package provides the 
+    	    The i386 PC Target HAL package provides the
     	    support needed to run eCos binaries on a standard i386
     	    PC."
 }
@@ -3184,7 +3617,7 @@
 	script		hal_synth.cdl
 	hardware
         description "
-    	    The Linux Synthetic Target HAL package provides the 
+    	    The Linux Synthetic Target HAL package provides the
     	    support needed to run eCos binaries on top of the i386
     	    Linux kernel."
 }
@@ -3284,7 +3717,7 @@
 	script		hal_powerpc_mpc8260.cdl
 	hardware
         description "
-           The PowerPC MPC8260 PowerQUICCII variant HAL package provides 
+           The PowerPC MPC8260 PowerQUICCII variant HAL package provides
            support for this processor variant. It is also necessary to
            select a specific target platform HAL package."
 }
@@ -3295,7 +3728,7 @@
 	script		hal_powerpc_mpc8xxx.cdl
 	hardware
         description "
-           The PowerPC MPC8XXX PowerQUICCII variant HAL package provides 
+           The PowerPC MPC8XXX PowerQUICCII variant HAL package provides
            support for this processor variant. It is also necessary to
            select a specific target platform HAL package."
 }
@@ -3944,7 +4377,7 @@
 	script		hal_frv_mb93091.cdl
 	hardware
         description "
-The FRV Generic HAL package provides the support needed to run eCos on 
+The FRV Generic HAL package provides the support needed to run eCos on
 various FUJITSU FR-V eval boards."
 }
 
@@ -3954,7 +4387,7 @@
 	script		hal_frv_mb93093.cdl
 	hardware
         description "
-The MB93093 HAL package provides the support needed to run eCos on 
+The MB93093 HAL package provides the support needed to run eCos on
 the Fujitsu MB93093-PD00 Portable Development Kit board."
 }
 
@@ -4088,8 +4521,8 @@
 
 target integrator_arm7 {
         alias { "ARM INTEGRATOR development board w/ ARM7TDMI" integrator }
-        packages { CYGPKG_HAL_ARM 
-                   CYGPKG_HAL_ARM_INTEGRATOR 
+        packages { CYGPKG_HAL_ARM
+                   CYGPKG_HAL_ARM_INTEGRATOR
                    CYGPKG_IO_PCI
                    CYGPKG_IO_SERIAL_ARM_INTEGRATOR
 		   CYGPKG_DEVS_FLASH_INTEL_28FXXX
@@ -4098,7 +4531,7 @@
                    CYGPKG_DEVS_ETH_ARM_INTEGRATOR
         }
         description "
-        The INTEGRATOR_ARM7 target provides the packages needed to 
+        The INTEGRATOR_ARM7 target provides the packages needed to
         run eCos on an ARM development board with an ARM7TDMI core
         module installed."
 }
@@ -4107,7 +4540,7 @@
         alias { "ARM INTEGRATOR development board w/ ARM966" }
         packages { CYGPKG_HAL_ARM
 		   CYGPKG_HAL_ARM_ARM9
-                   CYGPKG_HAL_ARM_INTEGRATOR 
+                   CYGPKG_HAL_ARM_INTEGRATOR
                    CYGPKG_IO_PCI
                    CYGPKG_IO_SERIAL_ARM_INTEGRATOR
 		   CYGPKG_DEVS_FLASH_INTEL_28FXXX
@@ -4116,7 +4549,7 @@
                    CYGPKG_DEVS_ETH_ARM_INTEGRATOR
         }
         description "
-        The INTEGRATOR_ARM9 target provides the packages needed to 
+        The INTEGRATOR_ARM9 target provides the packages needed to
         run eCos on an ARM development board with an ARM966 core
         module installed."
 }
@@ -4208,8 +4641,8 @@
                    CYGPKG_DEVICES_WATCHDOG_ARM_AT91
         }
         description "
-	The phyCORE AT91M55800A target provides the packages needed to 
-        run eCos on an PHYTEC evaluation board (phycore AT91M55800A based 
+	The phyCORE AT91M55800A target provides the packages needed to
+        run eCos on an PHYTEC evaluation board (phycore AT91M55800A based
         on HD200)."
 }
 
@@ -4312,7 +4745,7 @@
                    CYGPKG_DEVS_FLASH_AMD_AM29XXXXX
         }
         description "
-        The SMDK2410 target provides the packages needed to run eCos on 
+        The SMDK2410 target provides the packages needed to run eCos on
         Samsung S3c2410x (ARM920T) based development boards (SMDK2410)."
 }
 
@@ -4329,7 +4762,7 @@
         description "
         The Innovator HAL package provides the support needed to run
         RedBoot on the ARM processor of the Innovator.
-	
+
 	NOTE: Full support for eCos is not provided yet.  This HAL
 	contains only the minimum amount necessary to run RedBoot
 	on the Innovator.  In particular, interrupts are not yet
@@ -4628,15 +5061,15 @@
 	                  CYGPKG_IO_SERIAL_ARM_CMA230
         }
         description "
-The cma230 target provides the packages needed to run eCos on a Cogent 
+The cma230 target provides the packages needed to run eCos on a Cogent
 CMA230 (ARM7TDMI) or CMA222 (ARM710T) board."
     }
 
 
 target snds {
       alias { "Samsung SNDS" SNDS snds snds100 }
-      packages { CYGPKG_HAL_ARM 
-                 CYGPKG_HAL_ARM_SNDS 
+      packages { CYGPKG_HAL_ARM
+                 CYGPKG_HAL_ARM_SNDS
                  CYGPKG_DEVS_ETH_ARM_KS32C5000
                }
       enable { CYGHWR_HAL_ARM_BIGENDIAN }
@@ -4648,8 +5081,8 @@
 target aim711 {
       alias { "ARM Industrial Module AIM 711" AIM711 aim711 }
       packages {
-                   CYGPKG_HAL_ARM 
-                   CYGPKG_HAL_ARM_AIM711 
+                   CYGPKG_HAL_ARM
+                   CYGPKG_HAL_ARM_AIM711
                    CYGPKG_DEVS_FLASH_SST_39VFXXX
                    CYGPKG_DEVS_FLASH_ARM_AIM711
                    CYGPKG_DEVS_ETH_ARM_KS32C5000
@@ -4657,7 +5090,7 @@
                    CYGPKG_IO_SERIAL_ARM_S3C4510
                    CYGPKG_IO_SERIAL_GENERIC_16X5X
                    CYGPKG_DEVICES_WALLCLOCK_ARM_AIM711
-                   CYGPKG_DEVICES_WALLCLOCK_DALLAS_DS1307 
+                   CYGPKG_DEVICES_WALLCLOCK_DALLAS_DS1307
                }
       description "
         The aim711 target provides the packages needed to run eCos on a
@@ -4679,6 +5112,159 @@
         MICROPLEX Printer Controller 5.0"
 }
 
+target mx1ads {
+	alias { "Freescale MC9328MX1 ADS board" mx1 mx1ads }
+	packages {  CYGPKG_HAL_ARM
+			CYGPKG_HAL_ARM_MDBMX1
+			CYGPKG_HAL_ARM_MDBMX1_ADS
+			CYGPKG_IO_ETH_DRIVERS
+			CYGPKG_DEVS_ETH_ARM_MX1ADS
+			CYGPKG_DEVS_ETH_CL_CS8900A
+			CYGPKG_COMPRESS_ZLIB
+			CYGPKG_IO_FLASH
+			CYGPKG_DEVS_FLASH_ARM_AMD_AM29
+        }
+        description "
+        The mx1ads target provides the packages needed to run
+        eCos on a Freescale MC9328MX1 ADS board."
+}
+
+target mx21ads {
+	alias { "Freescale i.MX21 ADS board" mx21 mx21ads }
+	packages {  CYGPKG_HAL_ARM
+			CYGPKG_HAL_ARM_MX21
+			CYGPKG_HAL_ARM_MX21ADS
+        }
+        description "
+        The mx21ads target provides the packages needed to run
+        eCos on a Freescale i.MX21 ADS board."
+}
+
+target mx27ads {
+	alias { "Freescale i.MX27 ADS board" mx27 mx27ads }
+	packages {  CYGPKG_HAL_ARM
+			CYGPKG_HAL_ARM_MX27
+			CYGPKG_HAL_ARM_MX27ADS
+        }
+        description "
+        The mx27ads target provides the packages needed to run
+        eCos on a Freescale i.MX27 ADS board."
+}
+
+target mx27_3stack {
+	alias { "Freescale i.MX27 3-Stack board" mx27_3stack }
+	packages {  CYGPKG_HAL_ARM
+			CYGPKG_HAL_ARM_MX27
+			CYGPKG_HAL_ARM_MX27_3STACK
+        }
+        description "
+        The mx27_3stack target provides the packages needed to run
+        eCos on a Freescale i.MX27 3-Stack board."
+}
+
+target mx31ads {
+	alias { "Freescale i.MX31 ADS board" mx31 mx31ads }
+	packages {  CYGPKG_HAL_ARM
+			CYGPKG_HAL_ARM_MX31
+			CYGPKG_HAL_ARM_MX31ADS
+        }
+        description "
+        The mx31ads target provides the packages needed to run
+        eCos on a Freescale i.MX31 ADS board."
+}
+
+target mx31_3stack {
+	alias { "Freescale i.MX31 3-Stack board" mx31 mx31_3stack }
+	packages {  CYGPKG_HAL_ARM
+			CYGPKG_HAL_ARM_MX31
+			CYGPKG_HAL_ARM_MX31_3STACK
+        }
+        description "
+        The mx31_3stack target provides the packages needed to run
+        eCos on a Freescale i.MX31 3-Stack board."
+}
+
+target mx35_3stack {
+	alias { "Freescale i.MX35 3-Stack board" mx35 mx35_3stack }
+	packages {  CYGPKG_HAL_ARM
+			CYGPKG_HAL_ARM_MX35
+			CYGPKG_HAL_ARM_MX35_3STACK
+        }
+        description "
+        The mx35_3stack target provides the packages needed to run
+        eCos on a Freescale i.MX35 3-Stack board."
+}
+
+target mx35evb {
+	alias { "Freescale i.MX35 EVB board" mx35evb }
+	packages {  CYGPKG_HAL_ARM
+			CYGPKG_HAL_ARM_MX35
+			CYGPKG_HAL_ARM_MX35EVB
+        }
+        description "
+        The mx35evb target provides the packages needed to run
+        eCos on a Freescale i.MX35 EVB board."
+}
+
+
+target mx37_3stack {
+	alias { "Freescale i.MX37 3-Stack board" mx37 mx37_3stack }
+	packages {  CYGPKG_HAL_ARM
+			CYGPKG_HAL_ARM_MX37
+			CYGPKG_HAL_ARM_MX37_3STACK
+        }
+        description "
+        The mx37_3stack target provides the packages needed to run
+        eCos on a Freescale i.MX37 3-Stack board."
+}
+
+target mx51_3stack {
+	alias { "Freescale i.MX51 3-Stack board" mx51 mx51_3stack }
+	packages {  CYGPKG_HAL_ARM
+			CYGPKG_HAL_ARM_MX51
+			CYGPKG_HAL_ARM_MX51_3STACK
+        }
+        description "
+        The mx51_3stack target provides the packages needed to run
+        eCos on a Freescale i.MX51 3-Stack board."
+}
+
+target mxc30030evb {
+	alias { "Freescale MXC30030 EVB board" mxc30030evb}
+	packages {  CYGPKG_HAL_ARM
+			CYGPKG_HAL_ARM_MXC91321_CHIP_DEF
+			CYGPKG_HAL_ARM_MXC91321
+			CYGPKG_HAL_ARM_MXC30030EVB
+        }
+        description "
+        The MXC300-30 EVB target provides the packages needed to run
+        eCos on a Freescale MXC300-30 EVB board."
+}
+
+target mxc30030ads {
+	alias { "Freescale MXC300-30 ADS board" mxc30030ads }
+	packages {  CYGPKG_HAL_ARM
+			CYGPKG_HAL_ARM_MXC91321_CHIP_DEF
+			CYGPKG_HAL_ARM_MXC91321
+			CYGPKG_HAL_ARM_MXC30030ADS
+        }
+        description "
+        The MXC300-30 ADS target provides the packages needed to run
+        eCos on a Freescale MXC300-30 ADS board."
+}
+
+target mxc30030topaz {
+	alias { "Freescale MXC300-30 TOPAZ board" mxc30030topaz }
+	packages {  CYGPKG_HAL_ARM
+			CYGPKG_HAL_ARM_MXC91321_CHIP_DEF
+			CYGPKG_HAL_ARM_MXC91321
+			CYGPKG_HAL_ARM_MXC30030TOPAZ
+        }
+        description "
+        The MXC300-30 TOPAZ target provides the packages needed to run
+        eCos on a Freescale MXC300-30 TOPAZ board."
+}
+
 # --------------------------------------------------------------------------
 # SH targets
 
@@ -4687,7 +5273,7 @@
 	packages    { CYGPKG_HAL_SH
                       CYGPKG_HAL_SH_SH3
                       CYGPKG_HAL_SH_EDK7708
-                      CYGPKG_DEVICES_WALLCLOCK_SH3 
+                      CYGPKG_DEVICES_WALLCLOCK_SH3
 	              CYGPKG_IO_SERIAL_SH_SCI
 	              CYGPKG_IO_SERIAL_SH_EDK7708
                       CYGPKG_DEVICES_WATCHDOG_SH_SH3
@@ -4828,7 +5414,7 @@
                           CYGPKG_DEVICES_WALLCLOCK_I386_PC
         }
         description "
-    	    The pc_i82559 target provides the 
+    	    The pc_i82559 target provides the
     	    packages needed to run eCos binaries on a standard i386
     	    PC motherboard with an Intel 82559 based ethernet interface."
 }
@@ -4881,10 +5467,10 @@
                           CYGPKG_DEVS_FLASH_SYNTH
                           CYGPKG_DEVS_ETH_ECOSYNTH
                           CYGPKG_DEVS_WATCHDOG_SYNTH
-                          CYGPKG_DEVS_WALLCLOCK_SYNTH      
+                          CYGPKG_DEVS_WALLCLOCK_SYNTH
         }
         description "
-    	    The linux target provides the 
+    	    The linux target provides the
     	    packages needed to run eCos binaries on top of the i386
     	    Linux kernel."
 }
@@ -4905,7 +5491,7 @@
 
 target sparclite_sim {
 	alias		{ "SPARClite simulator" sl_sim sparcl_sim }
-	packages        { CYGPKG_HAL_SPARCLITE 
+	packages        { CYGPKG_HAL_SPARCLITE
                           CYGPKG_HAL_SPARCLITE_SIM
         }
         description "
@@ -4918,7 +5504,7 @@
 
 target sparc_erc32 {
 	alias		{ "ERC32 processor" erc32 }
-	packages        { CYGPKG_HAL_SPARC 
+	packages        { CYGPKG_HAL_SPARC
                           CYGPKG_HAL_SPARC_ERC32
         }
         description "
@@ -4928,7 +5514,7 @@
 
 target sparc_leon {
 	alias		{ "LEON processor" leon }
-	packages        { CYGPKG_HAL_SPARC 
+	packages        { CYGPKG_HAL_SPARC
                           CYGPKG_HAL_SPARC_LEON
         }
         description "
@@ -4973,7 +5559,7 @@
 target cma28x {
         alias		{ "Cogent CMA286/287 board" cma286 cma287 }
 	packages        { CYGPKG_HAL_POWERPC
-                          CYGPKG_HAL_POWERPC_MPC8xx 
+                          CYGPKG_HAL_POWERPC_MPC8xx
                           CYGPKG_HAL_POWERPC_COGENT
                           CYGPKG_IO_SERIAL_POWERPC_COGENT
         }
@@ -4985,7 +5571,7 @@
 target fads {
         alias		{ "Motorola MPC8xxFADS board" }
 	packages        { CYGPKG_HAL_POWERPC
-                          CYGPKG_HAL_POWERPC_MPC8xx 
+                          CYGPKG_HAL_POWERPC_MPC8xx
                           CYGPKG_HAL_POWERPC_FADS
         }
         description "
@@ -4998,7 +5584,7 @@
 	packages        { CYGPKG_HAL_POWERPC
                           CYGPKG_HAL_POWERPC_MPC8xx
                           CYGPKG_HAL_POWERPC_MBX
-                          CYGPKG_HAL_QUICC 
+                          CYGPKG_HAL_QUICC
                           CYGPKG_IO_SERIAL_POWERPC_QUICC_SMC
                           CYGPKG_DEVS_ETH_POWERPC_QUICC
                           CYGPKG_DEVS_ETH_POWERPC_MBX
@@ -5045,7 +5631,7 @@
 	packages        { CYGPKG_HAL_POWERPC
                           CYGPKG_HAL_POWERPC_MPC8xx
                           CYGPKG_HAL_POWERPC_VIPER
-                          CYGPKG_HAL_QUICC 
+                          CYGPKG_HAL_QUICC
                           CYGPKG_IO_SERIAL_POWERPC_QUICC_SMC
                           CYGPKG_DEVS_ETH_POWERPC_FEC
                           CYGPKG_DEVS_ETH_POWERPC_VIPER
@@ -5314,9 +5900,9 @@
 
 target stdeval1 {
         alias		{ "Matsushita stdeval1 board" }
-	packages        { CYGPKG_HAL_MN10300 
-                          CYGPKG_HAL_MN10300_AM31_STDEVAL1 
-                          CYGPKG_HAL_MN10300_AM31 
+	packages        { CYGPKG_HAL_MN10300
+                          CYGPKG_HAL_MN10300_AM31_STDEVAL1
+                          CYGPKG_HAL_MN10300_AM31
                           CYGPKG_IO_SERIAL_MN10300
                           CYGPKG_DEVICES_WATCHDOG_MN10300_MN10300
         }
@@ -5401,7 +5987,7 @@
                 eCos on the Motorola mcf5272c3 evaluation board."
 
 }
- 
+
 # --------------------------------------------------------------------------
 
 # --------------------------------------------------------------------------
@@ -5538,7 +6124,7 @@
 	packages        { CYGPKG_HAL_POWERPC
                           CYGPKG_HAL_POWERPC_MPC8xx
                           CYGPKG_HAL_POWERPC_TS1000
-                          CYGPKG_HAL_QUICC 
+                          CYGPKG_HAL_QUICC
                           CYGPKG_DEVS_FLASH_POWERPC_TS1000
                           CYGPKG_DEVS_FLASH_AMD_AM29XXXXX
                           CYGPKG_DEVS_ETH_POWERPC_FEC
@@ -5689,7 +6275,7 @@
 	packages        { CYGPKG_HAL_POWERPC
                           CYGPKG_HAL_POWERPC_MPC8xx
                           CYGPKG_HAL_POWERPC_ADDER
-                          CYGPKG_HAL_QUICC 
+                          CYGPKG_HAL_QUICC
                           CYGPKG_DEVS_FLASH_POWERPC_ADDER
                           CYGPKG_DEVS_FLASH_AMD_AM29XXXXX
                           CYGPKG_DEVS_ETH_POWERPC_QUICC
@@ -5707,7 +6293,7 @@
 	packages        { CYGPKG_HAL_POWERPC
                           CYGPKG_HAL_POWERPC_MPC8xx
                           CYGPKG_HAL_POWERPC_ADDER
-                          CYGPKG_HAL_QUICC 
+                          CYGPKG_HAL_QUICC
                           CYGPKG_DEVS_FLASH_POWERPC_ADDER
                           CYGPKG_DEVS_FLASH_AMD_AM29XXXXX
                           CYGPKG_DEVS_ETH_POWERPC_FEC
@@ -5786,7 +6372,7 @@
 	script		flash_moab.cdl
 	hardware
         description "
-           This package contains hardware support for both the boot FLASH 
+           This package contains hardware support for both the boot FLASH
            and NAND (main) memory on the MOAB platform."
 }
 
@@ -5874,7 +6460,7 @@
                           CYGPKG_DEVICES_WALLCLOCK_I386_PC
         }
         description "
-    	    The pc_rltk8139 target provides the packages needed to run eCos binaries 
+    	    The pc_rltk8139 target provides the packages needed to run eCos binaries
             on a standard i386 PC motherboard, using a Realtek 8139 network card."
 }
 
@@ -5905,7 +6491,7 @@
                         devs_serial_arm_gps4020 gps4020_serial_driver }
     hardware
     directory	      devs/serial/arm/gps4020
-    script	      ser_arm_gps4020.cdl	
+    script	      ser_arm_gps4020.cdl
     description       "GPS4020 serial device drivers"
 }
 
@@ -5938,7 +6524,7 @@
     directory       devs/disk/v85x/edb_v850
     script          v85x_edb_v850_disk.cdl
     hardware
-    description     "Disk driver for the Elatec v850 development board." 
+    description     "Disk driver for the Elatec v850 development board."
 }
 
 package CYGPKG_DEVS_DISK_ECOSYNTH {
@@ -5953,7 +6539,7 @@
     alias           { "Generic IDE disk driver" ide_disk }
     directory       devs/disk/ide
     script          ide_disk.cdl
-    description     "Disk driver for generic IDE interface." 
+    description     "Disk driver for generic IDE interface."
 }
 
 package CYGPKG_IO_DISK {
@@ -5991,4 +6577,3 @@
 	description	"Lightweight TCP/IP stack: lwIP"
 }
 
-
diff -urN -x CVS -x doc -x lwip_tcpip -x calmrisc16 -x calmrisc32 ecos_20050912/packages/hal/arm/arch/current/src/redboot_linux_exec.c ecos_base/packages/hal/arm/arch/current/src/redboot_linux_exec.c
--- ecos_20050912/packages/hal/arm/arch/current/src/redboot_linux_exec.c	2005-04-21 13:17:56.000000000 -0500
+++ ecos_base/packages/hal/arm/arch/current/src/redboot_linux_exec.c	2006-05-02 20:28:40.000000000 -0500
@@ -327,8 +327,7 @@
 
     // Check to see if a valid image has been loaded
     if (entry_address == (unsigned long)NO_MEMORY) {
-        diag_printf("Can't execute Linux - invalid entry address\n");
-        return;
+        diag_printf("Warning: invalid entry address but still continue ...\n");
     }
     // Default physical entry point for Linux is kernel base.
     entry = (unsigned long)CYGHWR_REDBOOT_ARM_LINUX_EXEC_ADDRESS;
@@ -364,6 +363,7 @@
     {
         return;
     }
+    diag_printf("entry=0x%x, target=0x%x\n", (unsigned int)entry, (unsigned int)target);
 
     // Set up parameters to pass to kernel
 
@@ -527,4 +527,4 @@
       
 #endif // HAL_PLATFORM_MACHINE_TYPE - otherwise we do not support this stuff...
 
-// EOF redboot_linux_exec.c
+// EOF redboot_linux_exec.c
diff -urN -x CVS -x doc -x lwip_tcpip -x calmrisc16 -x calmrisc32 ecos_20050912/packages/hal/arm/mx51/3stack/current/cdl/hal_arm_board.cdl ecos_base/packages/hal/arm/mx51/3stack/current/cdl/hal_arm_board.cdl
--- ecos_20050912/packages/hal/arm/mx51/3stack/current/cdl/hal_arm_board.cdl	1969-12-31 18:00:00.000000000 -0600
+++ ecos_base/packages/hal/arm/mx51/3stack/current/cdl/hal_arm_board.cdl	2008-04-01 12:14:08.000000000 -0500
@@ -0,0 +1,367 @@
+# ====================================================================
+#
+#      hal_arm_board.cdl
+#
+# ====================================================================
+#####ECOSGPLCOPYRIGHTBEGIN####
+## -------------------------------------------
+## This file is part of eCos, the Embedded Configurable Operating System.
+## Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+##
+## eCos is free software; you can redistribute it and/or modify it under
+## the terms of the GNU General Public License as published by the Free
+## Software Foundation; either version 2 or (at your option) any later version.
+##
+## eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+## WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+## for more details.
+##
+## You should have received a copy of the GNU General Public License along
+## with eCos; if not, write to the Free Software Foundation, Inc.,
+## 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+##
+## As a special exception, if other files instantiate templates or use macros
+## or inline functions from this file, or you compile this file and link it
+## with other works to produce a work based on this file, this file does not
+## by itself cause the resulting work to be covered by the GNU General Public
+## License. However the source code for this file must still be made available
+## in accordance with section (3) of the GNU General Public License.
+##
+## This exception does not invalidate any other reasons why a work based on
+## this file might be covered by the GNU General Public License.
+##
+## Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+## at http://sources.redhat.com/ecos/ecos-license/
+## -------------------------------------------
+#####ECOSGPLCOPYRIGHTEND####
+
+cdl_package CYGPKG_HAL_ARM_MX51_3STACK {
+    display       "Freescale board"
+    parent        CYGPKG_HAL_ARM_MX51
+    hardware
+    include_dir   cyg/hal
+    define_header hal_arm_board.h
+    description   "
+        This HAL platform package provides generic
+        support for the Freescale MX51 3-Stack Board."
+
+    compile       board_misc.c board_diag.c
+    implements    CYGINT_HAL_DEBUG_GDB_STUBS
+    implements    CYGINT_HAL_DEBUG_GDB_STUBS_BREAK
+    implements    CYGINT_HAL_VIRTUAL_VECTOR_SUPPORT
+
+    #implements    CYGHWR_HAL_ARM_DUART_UARTB
+    implements    CYGHWR_HAL_ARM_SOC_UART1
+    #implements    CYGHWR_HAL_ARM_SOC_UART2
+    #implements    CYGHWR_HAL_ARM_SOC_UART3
+
+    define_proc {
+        puts $::cdl_system_header "#define CYGBLD_HAL_TARGET_H   <pkgconf/hal_arm.h>"
+        puts $::cdl_system_header "#define CYGBLD_HAL_VARIANT_H  <pkgconf/hal_arm_soc.h>"
+        puts $::cdl_system_header "#define CYGBLD_HAL_PLATFORM_H <pkgconf/hal_arm_board.h>"
+	puts $::cdl_header "#define HAL_PLATFORM_CPU    \"Freescale i.MX51 based\""
+        puts $::cdl_header "#define HAL_PLATFORM_BOARD  \"MX51 3-Stack\""
+        puts $::cdl_header "#define HAL_PLATFORM_MACHINE_TYPE  1696"
+        puts $::cdl_header "#define HAL_ARCH_PROGRAM_NEW_STACK board_program_new_stack"
+    }
+
+    cdl_component CYG_HAL_STARTUP {
+        display       "Startup type"
+        flavor        data
+        default_value {"ROM"}
+        legal_values  {"RAM" "ROM" "ROMRAM"}
+	no_define
+	define -file system.h CYG_HAL_STARTUP
+        description   "
+           When targetting the eval board it is possible to build
+           the system for either RAM bootstrap or ROM bootstrap(s). Select
+           'ram' when building programs to load into RAM using eCos GDB
+           stubs.  Select 'rom' when building a stand-alone application
+           which will be put into ROM, or for the special case of
+           building the eCos GDB stubs themselves. Using ROMRAM will allow
+           the program to exist in ROM, but be copied to RAM during startup."
+    }
+
+    cdl_interface     CYGHWR_HAL_ARM_DUART_UARTA {
+        display   "ST16552 UARTA available as diagnostic/debug channel"
+        description "
+	  The board has a ST16552 DUART chip. This
+          interface allows a platform to indicate that the specified
+          serial port can be used as a diagnostic and/or debug channel."
+    }
+
+    cdl_interface     CYGHWR_HAL_ARM_DUART_UARTB {
+        display   "ST16552 UARTB available as diagnostic/debug channel"
+        description "
+	  The board has a ST16552 DUART chip. This
+          interface allows a platform to indicate that the specified
+          serial port can be used as a diagnostic and/or debug channel."
+    }
+
+    cdl_option CYGNUM_HAL_VIRTUAL_VECTOR_CONSOLE_CHANNEL_BAUD {
+        display       "Diagnostic serial port baud rate"
+        flavor        data
+        legal_values  9600 19200 38400 57600 115200
+        default_value 115200
+        description   "
+            This option selects the baud rate used for the console port.
+            Note: this should match the value chosen for the GDB port if the
+            console and GDB port are the same."
+    }
+
+    cdl_option CYGNUM_HAL_VIRTUAL_VECTOR_DEBUG_CHANNEL_BAUD {
+        display       "GDB serial port baud rate"
+        flavor        data
+        legal_values  9600 19200 38400 57600 115200
+        default_value 115200
+        description   "
+            This option selects the baud rate used for the GDB port.
+            Note: this should match the value chosen for the console port if the
+            console and GDB port are the same."
+    }
+
+    cdl_option CYGNUM_HAL_VIRTUAL_VECTOR_COMM_CHANNELS {
+        display      "Number of communication channels on the board"
+        flavor       data
+        calculated   6
+    }
+
+    cdl_option CYGNUM_HAL_VIRTUAL_VECTOR_DEBUG_CHANNEL {
+        display          "Debug serial port"
+        active_if        CYGPRI_HAL_VIRTUAL_VECTOR_DEBUG_CHANNEL_CONFIGURABLE
+        flavor data
+        legal_values     0 to CYGNUM_HAL_VIRTUAL_VECTOR_COMM_CHANNELS-1
+        default_value    0
+        description      "
+            The board has three serial ports. This option
+            chooses which port will be used to connect to a host
+            running GDB."
+     }
+
+     cdl_option CYGNUM_HAL_VIRTUAL_VECTOR_CONSOLE_CHANNEL_DEFAULT {
+         display      "Default console channel."
+         flavor       data
+         legal_values     0 to CYGNUM_HAL_VIRTUAL_VECTOR_COMM_CHANNELS-1
+         calculated   0
+     }
+
+     cdl_option CYGNUM_HAL_VIRTUAL_VECTOR_CONSOLE_CHANNEL {
+         display          "Console serial port"
+         active_if        CYGPRI_HAL_VIRTUAL_VECTOR_CONSOLE_CHANNEL_CONFIGURABLE
+         flavor data
+         legal_values     0 to CYGNUM_HAL_VIRTUAL_VECTOR_COMM_CHANNELS-1
+         default_value    CYGNUM_HAL_VIRTUAL_VECTOR_CONSOLE_CHANNEL_DEFAULT
+         description      "
+            The board has only three serial ports.  This option
+            chooses which port will be used for console output."
+     }
+
+    cdl_component CYGBLD_GLOBAL_OPTIONS {
+        display "Global build options"
+        flavor  none
+        no_define
+        description   "
+	    Global build options including control over
+	    compiler flags, linker flags and choice of toolchain."
+
+
+        parent  CYGPKG_NONE
+
+        cdl_option CYGBLD_GLOBAL_COMMAND_PREFIX {
+            display "Global command prefix"
+            flavor  data
+            no_define
+            default_value { "arm-elf" }
+            description "
+                This option specifies the command prefix used when
+                invoking the build tools."
+        }
+
+        cdl_option CYGBLD_GLOBAL_CFLAGS {
+            display "Global compiler flags"
+            flavor  data
+            no_define
+            default_value { "-mcpu=arm9 -Wall -Wpointer-arith -Wstrict-prototypes -Winline -Wundef -Woverloaded-virtual -g -O2 -ffunction-sections -fdata-sections -fno-rtti -fno-exceptions -fvtable-gc -finit-priority" }
+            description   "
+                This option controls the global compiler flags which are used to
+                compile all packages by default. Individual packages may define
+                options which override these global flags."
+        }
+
+        cdl_option CYGBLD_GLOBAL_LDFLAGS {
+            display "Global linker flags"
+            flavor  data
+            no_define
+            default_value { "-Wl,--gc-sections -Wl,-static -g -O2 -nostdlib" }
+            description   "
+                This option controls the global linker flags. Individual
+                packages may define options which override these global flags."
+        }
+
+        cdl_option CYGBLD_BUILD_GDB_STUBS {
+            display "Build GDB stub ROM image"
+            default_value 0
+            requires { CYG_HAL_STARTUP == "ROM" }
+            requires CYGSEM_HAL_ROM_MONITOR
+            requires CYGBLD_BUILD_COMMON_GDB_STUBS
+            requires CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS
+            requires CYGDBG_HAL_DEBUG_GDB_BREAK_SUPPORT
+            requires CYGDBG_HAL_DEBUG_GDB_THREAD_SUPPORT
+            requires ! CYGDBG_HAL_COMMON_INTERRUPTS_SAVE_MINIMUM_CONTEXT
+            requires ! CYGDBG_HAL_COMMON_CONTEXT_SAVE_MINIMUM
+            no_define
+            description "
+                This option enables the building of the GDB stubs for the
+                board. The common HAL controls takes care of most of the
+                build process, but the final conversion from ELF image to
+                binary data is handled by the platform CDL, allowing
+                relocation of the data if necessary."
+
+            make -priority 320 {
+                <PREFIX>/bin/gdb_module.bin : <PREFIX>/bin/gdb_module.img
+                $(OBJCOPY) --remove-section=.fixed_vectors -O binary $< $@
+            }
+        }
+    }
+
+    cdl_component CYGPKG_HAL_ARM_BOARD_OPTIONS {
+        display "Freescale MXC Board build options"
+        flavor  none
+        no_define
+        description   "
+	    Package specific build options including control over
+	    compiler flags used only in building this package,
+	    and details of which tests are built."
+
+        cdl_option CYGPKG_HAL_ARM_BOARD_CFLAGS_ADD {
+            display "Additional compiler flags"
+            flavor  data
+            no_define
+            default_value { "" }
+            description   "
+                This option modifies the set of compiler flags for
+                building the board HAL. These flags are used in addition
+                to the set of global flags."
+        }
+
+        cdl_option CYGPKG_HAL_ARM_BOARD_CFLAGS_REMOVE {
+            display "Suppressed compiler flags"
+            flavor  data
+            no_define
+            default_value { "" }
+            description   "
+                This option modifies the set of compiler flags for
+                building the board HAL. These flags are removed from
+                the set of global flags if present."
+        }
+
+    }
+
+    cdl_component CYGHWR_MEMORY_LAYOUT {
+        display "Memory layout"
+        flavor data
+        no_define
+        calculated { (CYG_HAL_STARTUP == "RAM")    ? "arm_board_ram" :
+                     (CYG_HAL_STARTUP == "ROMRAM") ? "arm_board_romram" :
+	                                             "arm_board_rom" }
+
+        cdl_option CYGHWR_MEMORY_LAYOUT_LDI {
+            display "Memory layout linker script fragment"
+            flavor data
+            no_define
+            define -file system.h CYGHWR_MEMORY_LAYOUT_LDI
+            calculated { (CYG_HAL_STARTUP == "RAM") ?    "<pkgconf/mlt_arm_board_ram.ldi>" :
+                         (CYG_HAL_STARTUP == "ROMRAM") ? "<pkgconf/mlt_arm_board_romram.ldi>" :
+                                                         "<pkgconf/mlt_arm_board_rom.ldi>" }
+        }
+
+        cdl_option CYGHWR_MEMORY_LAYOUT_H {
+            display "Memory layout header file"
+            flavor data
+            no_define
+            define -file system.h CYGHWR_MEMORY_LAYOUT_H
+            calculated { (CYG_HAL_STARTUP == "RAM")    ? "<pkgconf/mlt_arm_board_ram.h>" :
+                         (CYG_HAL_STARTUP == "ROMRAM") ? "<pkgconf/mlt_arm_board_romram.h>" :
+                                                         "<pkgconf/mlt_arm_board_rom.h>" }
+        }
+    }
+
+    cdl_option CYGSEM_HAL_ROM_MONITOR {
+        display       "Behave as a ROM monitor"
+        flavor        bool
+        default_value 0
+        parent        CYGPKG_HAL_ROM_MONITOR
+        requires      { CYG_HAL_STARTUP == "ROM" || CYG_HAL_STARTUP == "ROMRAM" }
+        description   "
+            Enable this option if this program is to be used as a ROM monitor,
+            i.e. applications will be loaded into RAM on the board, and this
+            ROM monitor may process exceptions or interrupts generated from the
+            application. This enables features such as utilizing a separate
+            interrupt stack when exceptions are generated."
+    }
+
+    cdl_option CYGSEM_HAL_USE_ROM_MONITOR {
+         display       "Work with a ROM monitor"
+         flavor        booldata
+         legal_values  { "Generic" "GDB_stubs" }
+         default_value { CYG_HAL_STARTUP == "RAM" ? "GDB_stubs" : 0 }
+         parent        CYGPKG_HAL_ROM_MONITOR
+         requires      { CYG_HAL_STARTUP == "RAM" }
+         description   "
+             Support can be enabled for different varieties of ROM monitor.
+             This support changes various eCos semantics such as the encoding
+             of diagnostic output, or the overriding of hardware interrupt
+             vectors.
+             Firstly there is \"Generic\" support which prevents the HAL
+             from overriding the hardware vectors that it does not use, to
+             instead allow an installed ROM monitor to handle them. This is
+             the most basic support which is likely to be common to most
+             implementations of ROM monitor.
+             \"GDB_stubs\" provides support when GDB stubs are included in
+             the ROM monitor or boot ROM."
+     }
+
+    cdl_component CYGPKG_REDBOOT_HAL_OPTIONS {
+        display       "Redboot HAL options"
+        flavor        none
+        no_define
+        parent        CYGPKG_REDBOOT
+        active_if     CYGPKG_REDBOOT
+        description   "
+            This option lists the target's requirements for a valid Redboot
+            configuration."
+
+            compile -library=libextras.a redboot_cmds.c
+
+        cdl_option CYGBLD_BUILD_REDBOOT_BIN {
+            display       "Build Redboot ROM binary image"
+            active_if     CYGBLD_BUILD_REDBOOT
+            default_value 1
+            no_define
+            description "This option enables the conversion of the Redboot ELF
+                         image to a binary image suitable for ROM programming."
+
+            make -priority 325 {
+                <PREFIX>/bin/redboot.bin : <PREFIX>/bin/redboot.elf
+                $(OBJCOPY) --strip-debug $< $(@:.bin=.img)
+                $(OBJCOPY) -O srec $< $(@:.bin=.srec)
+                $(OBJCOPY) -O binary $< $@
+            }
+        }
+    }
+
+    cdl_component CYGPKG_REDBOOT_HAL_BOARD_OPTIONS {
+        display       "Redboot HAL variant options"
+        flavor        none
+        no_define
+        parent        CYGPKG_REDBOOT
+        active_if     CYGPKG_REDBOOT
+
+        # RedBoot details
+        requires { CYGHWR_REDBOOT_ARM_LINUX_EXEC_ADDRESS_DEFAULT == 0x40008000 }
+        define_proc {
+            puts $::cdl_header "#define CYGHWR_REDBOOT_ARM_TRAMPOLINE_ADDRESS 0x00001f00"
+        }
+    }
+}
diff -urN -x CVS -x doc -x lwip_tcpip -x calmrisc16 -x calmrisc32 ecos_20050912/packages/hal/arm/mx51/3stack/current/include/fsl_board.h ecos_base/packages/hal/arm/mx51/3stack/current/include/fsl_board.h
--- ecos_20050912/packages/hal/arm/mx51/3stack/current/include/fsl_board.h	1969-12-31 18:00:00.000000000 -0600
+++ ecos_base/packages/hal/arm/mx51/3stack/current/include/fsl_board.h	2008-04-01 12:14:09.000000000 -0500
@@ -0,0 +1,94 @@
+#ifndef CYGONCE_FSL_BOARD_H
+#define CYGONCE_FSL_BOARD_H
+
+//=============================================================================
+//
+//      Platform specific support (register layout, etc)
+//
+//=============================================================================
+//####ECOSGPLCOPYRIGHTBEGIN####
+// -------------------------------------------
+// This file is part of eCos, the Embedded Configurable Operating System.
+// Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+//
+// eCos is free software; you can redistribute it and/or modify it under
+// the terms of the GNU General Public License as published by the Free
+// Software Foundation; either version 2 or (at your option) any later version.
+//
+// eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with eCos; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+//
+// As a special exception, if other files instantiate templates or use macros
+// or inline functions from this file, or you compile this file and link it
+// with other works to produce a work based on this file, this file does not
+// by itself cause the resulting work to be covered by the GNU General Public
+// License. However the source code for this file must still be made available
+// in accordance with section (3) of the GNU General Public License.
+//
+// This exception does not invalidate any other reasons why a work based on
+// this file might be covered by the GNU General Public License.
+//
+// Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+// at http://sources.redhat.com/ecos/ecos-license/
+// -------------------------------------------
+//####ECOSGPLCOPYRIGHTEND####
+//===========================================================================
+
+#include <cyg/hal/hal_soc.h>        // Hardware definitions
+
+#define CPLD_SPI_BASE             CSPI2_BASE_ADDR
+#define CPLD_SPI_CHIP_SELECT_NO   SPI_CTRL_CS0
+#define CPLD_SPI_CTRL_MODE_MASTER SPI_CTRL_MODE_MASTER_0
+
+/* CPLD offsets */
+#define PBC_LED_CTRL                0x20000
+#define PBC_SB_STAT                 0x20008
+#define PBC_ID_AAAA                 0x20040
+#define PBC_ID_5555                 0x20048
+#define PBC_VERSION                 0x20050
+#define PBC_ID_CAFE                 0x20058
+#define PBC_INT_STAT                0x20010
+#define PBC_INT_MASK                0x20038
+#define PBC_INT_REST                0x20020
+#define PBC_SW_RESET                0x20060
+#define BOARD_CS_UART_BASE          0x8000
+
+#define REDBOOT_IMAGE_SIZE          0x40000
+
+#define LAN92XX_REG_READ(reg_offset)  \
+    ((cpld_reg_xfer(reg_offset, 0x0, 1)) | ((cpld_reg_xfer(reg_offset + 0x2, 0x0, 1) << 16)))
+
+#define LAN92XX_REG_WRITE(reg_offset, val)  \
+    (cpld_reg_xfer(reg_offset, val, 0)); \
+    (cpld_reg_xfer(reg_offset + 0x2, (val >> 16), 0));
+
+#define EXT_UART_x16
+/* MX31 3-Stack SDRAM is from 0x40000000, 128M */
+#define SDRAM_BASE_ADDR             CSD0_BASE_ADDR
+#define SDRAM_SIZE                  0x08000000
+#define RAM_BANK0_BASE              SDRAM_BASE_ADDR
+
+#define LED_MAX_NUM	8
+#define LED_IS_ON(n)    ((readw(PBC_LED_CTRL) & (1<<(n))) != 0)
+#define TURN_LED_ON(n)  writew((readw(PBC_LED_CTRL)|(1<<(n))), PBC_LED_CTRL)
+#define TURN_LED_OFF(n) writew((readw(PBC_LED_CTRL)&(~(1<<(n)))), PBC_LED_CTRL)
+
+#define BOARD_DEBUG_LED(n)   0
+/*
+#define BOARD_DEBUG_LED(n) 			\
+    CYG_MACRO_START				\
+        if (n >= 0 && n < LED_MAX_NUM) { 	\
+		if (LED_IS_ON(n)) 		\
+			TURN_LED_OFF(n); 	\
+		else 				\
+			TURN_LED_ON(n);		\
+	}					\
+    CYG_MACRO_END
+*/
+#endif /* CYGONCE_FSL_BOARD_H */
diff -urN -x CVS -x doc -x lwip_tcpip -x calmrisc16 -x calmrisc32 ecos_20050912/packages/hal/arm/mx51/3stack/current/include/hal_platform_setup.h ecos_base/packages/hal/arm/mx51/3stack/current/include/hal_platform_setup.h
--- ecos_20050912/packages/hal/arm/mx51/3stack/current/include/hal_platform_setup.h	1969-12-31 18:00:00.000000000 -0600
+++ ecos_base/packages/hal/arm/mx51/3stack/current/include/hal_platform_setup.h	2008-04-01 12:14:09.000000000 -0500
@@ -0,0 +1,762 @@
+#ifndef CYGONCE_HAL_PLATFORM_SETUP_H
+#define CYGONCE_HAL_PLATFORM_SETUP_H
+
+//=============================================================================
+//
+//      hal_platform_setup.h
+//
+//      Platform specific support for HAL (assembly code)
+//
+//=============================================================================
+//####ECOSGPLCOPYRIGHTBEGIN####
+// -------------------------------------------
+// This file is part of eCos, the Embedded Configurable Operating System.
+// Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+//
+// eCos is free software; you can redistribute it and/or modify it under
+// the terms of the GNU General Public License as published by the Free
+// Software Foundation; either version 2 or (at your option) any later version.
+//
+// eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with eCos; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+//
+// As a special exception, if other files instantiate templates or use macros
+// or inline functions from this file, or you compile this file and link it
+// with other works to produce a work based on this file, this file does not
+// by itself cause the resulting work to be covered by the GNU General Public
+// License. However the source code for this file must still be made available
+// in accordance with section (3) of the GNU General Public License.
+//
+// This exception does not invalidate any other reasons why a work based on
+// this file might be covered by the GNU General Public License.
+//
+// Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+// at http://sources.redhat.com/ecos/ecos-license/
+// -------------------------------------------
+//####ECOSGPLCOPYRIGHTEND####
+//===========================================================================
+
+#include <pkgconf/system.h>             // System-wide configuration info
+#include CYGBLD_HAL_VARIANT_H           // Variant specific configuration
+#include CYGBLD_HAL_PLATFORM_H          // Platform specific configuration
+#include <cyg/hal/hal_soc.h>            // Variant specific hardware definitions
+#include <cyg/hal/hal_mmu.h>            // MMU definitions
+#include <cyg/hal/fsl_board.h>          // Platform specific hardware definitions
+
+#if defined(CYG_HAL_STARTUP_ROM) || defined(CYG_HAL_STARTUP_ROMRAM)
+#define PLATFORM_SETUP1 _platform_setup1
+#define CYGHWR_HAL_ARM_HAS_MMU
+
+#ifdef CYG_HAL_STARTUP_ROMRAM
+#define CYGSEM_HAL_ROM_RESET_USES_JUMP
+#endif
+
+//#define NFC_2K_BI_SWAP
+#define SDRAM_FULL_PAGE_BIT     0x100
+#define SDRAM_FULL_PAGE_MODE    0x37
+#define SDRAM_BURST_MODE        0x33
+
+#define CYGHWR_HAL_ROM_VADDR    0x0
+
+#if 0
+#define UNALIGNED_ACCESS_ENABLE
+#define SET_T_BIT_DISABLE
+#define BRANCH_PREDICTION_ENABLE
+#endif
+
+//#define ENABLE_IMPRECISE_ABORT
+
+// This macro represents the initial startup code for the platform
+    .macro  _platform_setup1
+FSL_BOARD_SETUP_START:
+/*
+ *       ARM1136 init
+ *       - invalidate I/D cache/TLB and drain write buffer;
+ *       - invalidate L2 cache
+ *       - unaligned access
+ *       - branch predictions
+ */
+    // mrc p15, 0, r0, c1, c1, 0 // Read Secure Configuration Register data. Why doesn't work???
+    // mcr p15, 0, <Rd>, c1, c1, 0 ; Write Secure Configuration Register data
+#ifdef ENABLE_IMPRECISE_ABORT
+        mrs r1, spsr            // save old spsr
+        mrs r0, cpsr            // read out the cpsr
+        bic r0, r0, #0x100      // clear the A bit
+        msr spsr, r0            // update spsr
+        add lr, pc, #0x8        // update lr
+        movs pc, lr             // update cpsr
+        nop
+        nop
+        nop
+        nop
+        msr spsr, r1            // restore old spsr
+#endif
+
+    mov r0, #0
+    mcr 15, 0, r0, c7, c7, 0        /* invalidate I cache and D cache */
+    mcr 15, 0, r0, c8, c7, 0        /* invalidate TLBs */
+    mcr 15, 0, r0, c7, c10, 4       /* Drain the write buffer */
+
+    /* Also setup the Peripheral Port Remap register inside the core */
+    ldr r0, ARM_PPMRR        /* start from AIPS 2GB region */
+    mcr p15, 0, r0, c15, c2, 4
+
+    /* Reload data from spare area to 0x400 of main area if booting from NAND */
+    ldr r0, NFC_BASE_W
+    cmp pc, r0
+    blo 1f
+    cmp pc, r1
+    bhi 1f
+#ifdef BARKER_CODE_SWAP_LOC
+#if BARKER_CODE_SWAP_LOC != 0x404
+#error FIXME: the following depends on barker code to be 0x404
+#endif
+    // Recover the word at 0x404 offset using the one stored in the spare area 0
+    add r1, r0, #0x400
+    add r1, r1, #0x4
+    mov r3, #0x1000
+    ldr r2, [r0, r3]
+    str r2, [r1]
+#endif
+1:
+#ifdef L2CC_ENABLED
+    /*** L2 Cache setup/invalidation/disable ***/
+    /* Disable L2 cache first */
+    mov r0, #L2CC_BASE_ADDR
+    mov r2, #0
+    str r2, [r0, #L2_CACHE_CTL_REG]
+    /*
+     * Configure L2 Cache:
+     * - 128k size(16k way)
+     * - 8-way associativity
+     * - 0 ws TAG/VALID/DIRTY
+     * - 4 ws DATA R/W
+     */
+    mov r2, #0xFF000000
+    add r2, r2, #0x00F00000
+    ldr r1, [r0, #L2_CACHE_AUX_CTL_REG]
+    and r1, r1, r2
+    ldr r2, L2CACHE_PARAM
+    orr r1, r1, r2
+    str r1, [r0, #L2_CACHE_AUX_CTL_REG]
+
+    /* Invalidate L2 */
+    mov r1, #0xFF
+    str r1, [r0, #L2_CACHE_INV_WAY_REG]
+L2_loop:
+    /* Poll Invalidate By Way register */
+    ldr r2, [r0, #L2_CACHE_INV_WAY_REG]
+    ands r2, r2, #0xFF
+    bne L2_loop
+    /*** End of L2 operations ***/
+#endif
+
+    /* Store the boot type, from NAND or SDRAM */
+    mov r11, #SDRAM_NON_FLASH_BOOT
+/*
+ * End of ARM1136 init
+ */
+init_spba_start:
+    init_spba
+init_aips_start:
+    init_aips
+init_max_start:
+    init_max
+init_m3if_start:
+    init_m3if
+init_iomux_start:
+    init_iomux
+
+    /* If SDRAM has been setup, bypass clock/WEIM setup */
+    cmp pc, #SDRAM_BASE_ADDR
+    blo init_clock_start
+    cmp pc, #(SDRAM_BASE_ADDR + SDRAM_SIZE)
+    blo HWInitialise_skip_SDRAM_setup
+
+init_clock_start:
+    init_clock
+
+    // disable wdog
+    ldr r0, =0x30
+    ldr r1, WDOG1_BASE_W
+    strh r0, [r1]
+
+    /* Based on chip rev, setup params for SDRAM controller */
+    ldr r10, =0
+    mov r4, #SDRAM_BURST_MODE
+
+init_sdram_start:
+
+    /* Assuming DDR memory first */
+    setup_sdram
+
+HWInitialise_skip_SDRAM_setup:
+    ldr r0, NFC_BASE_W
+    add r2, r0, #0x1000      // 4K window
+    cmp pc, r0
+    blo Normal_Boot_Continue
+    cmp pc, r2
+    bhi Normal_Boot_Continue
+
+NAND_Boot_Start:
+    /* Copy image from flash to SDRAM first */
+    ldr r1, MXC_REDBOOT_ROM_START
+1:  ldmia r0!, {r3-r10}
+    stmia r1!, {r3-r10}
+    cmp r0, r2
+    blo 1b
+
+    /* Jump to SDRAM */
+    ldr r1, CONST_0x0FFF
+    and r0, pc, r1     /* offset of pc */
+    ldr r1, MXC_REDBOOT_ROM_START
+    add r1, r1, #0x10
+    add pc, r0, r1
+    nop
+    nop
+    nop
+    nop
+    nop
+
+NAND_Copy_Main:
+    // Check if x16/2kb page
+//    ldr r7, CCM_BASE_ADDR_W
+//    ldr r7, [r7, #0xC]
+//    ands r7, r7, #(1 << 30)
+    ldr r0, NFC_BASE_W   //r0: nfc base. Reloaded after each page copying
+    mov r1, #0x1000       //r1: starting flash addr to be copied. Updated constantly
+                        // ???? should be dynamic based on the page size kevin todo
+    add r2, r0, #0x1000   //r2: end of 3rd RAM buf. Doesn't change ?? dynamic
+
+    ldr r11, NFC_IP_BASE_W  //r11: NFC IP register base. Doesn't change
+    add r12, r0, #0x1E00  //r12: NFC AXI register base. Doesn't change
+    ldr r14, MXC_REDBOOT_ROM_START
+    add r13, r14, #REDBOOT_IMAGE_SIZE //r13: end of SDRAM address for copying. Doesn't change
+    add r14, r14, r1     //r14: starting SDRAM address for copying. Updated constantly
+
+    //unlock internal buffer
+    mov r3, #0xFF000000
+    add r3, r3, #0x00FF0000
+    str r3, [r11, #0x4]
+    str r3, [r11, #0x8]
+    str r3, [r11, #0xC]
+    str r3, [r11, #0x10]
+    mov r3, #0x20000
+    add r3, r3, #0x4
+    str r3, [r11, #0x0]     // kevin - revist for multiple CS ??
+    mov r3, #0
+    str r3, [r11, #0x18]
+
+Nfc_Read_Page:
+//  writew(FLASH_Read_Mode1, NAND_ADD_CMD_REG);
+    mov r3, #0x0;
+    str r3, [r12, #0x0]
+    mov r3, #NAND_LAUNCH_FCMD
+    str r3, [r12, #0xC]
+
+    do_wait_op_done
+//    start_nfc_addr_ops(ADDRESS_INPUT_READ_PAGE, addr, nflash_dev_info->base_mask);
+    mov r4, r1, lsl #1
+    and r3, r4, #0xFF
+    mov r3, r3, lsl #16
+    do_addr_input       //1st addr cycle
+    mov r3, r4, lsr #8
+    and r3, r3, #0x1F
+    mov r3, r3, lsl #16
+    do_addr_input       //2nd addr cycle
+    mov r3, r4, lsr #13
+    and r3, r3, #0xFF
+    mov r3, r3, lsl #16
+    do_addr_input       //3rd addr cycle
+    mov r3, r4, lsr #21
+    and r3, r3, #0xFF
+    mov r3, r3, lsl #16
+    do_addr_input       //4th addr cycle
+    mov r3, r4, lsr #29
+    and r3, r3, #0xF
+    mov r3, r3, lsl #16
+    do_addr_input       //5th addr cycle TODO
+
+//  writew(FLASH_Read_Mode1_2K, NAND_ADD_CMD_REG);
+    mov r3, #0x30;
+    str r3, [r12, #0x0]
+    mov r3, #NAND_LAUNCH_FCMD
+    str r3, [r12, #0xC]
+    do_wait_op_done
+
+// write RBA=0 to NFC_CONFIGURATION1
+    mov r3, #0
+    str r3, [r12, #0x4]
+
+//    writel(mode & 0xFF, NAND_LAUNCH_REG);
+    mov r3, #0x8
+    str r3, [r12, #0xC]
+//        wait_op_done();
+    do_wait_op_done
+
+
+Copy_Good_Blk:
+    //copying page
+1:  ldmia r0!, {r3-r10}
+    stmia r14!, {r3-r10}
+    cmp r0, r2
+    blo 1b
+    cmp r14, r13
+    bge NAND_Copy_Main_done
+    add r1, r1, #0x1000
+    ldr r0, NFC_BASE_W
+    b Nfc_Read_Page
+
+NAND_Copy_Main_done:
+
+    mov r11, #NAND_FLASH_BOOT
+
+Normal_Boot_Continue:
+
+#ifdef CYG_HAL_STARTUP_ROMRAM     /* enable running from RAM */
+    /* Copy image from flash to SDRAM first */
+    ldr r0, =0xFFFFF000
+    and r0, r0, pc
+    ldr r1, MXC_REDBOOT_ROM_START
+    cmp r0, r1
+    beq HWInitialise_skip_SDRAM_copy
+
+    add r2, r0, #REDBOOT_IMAGE_SIZE
+
+1:  ldmia r0!, {r3-r10}
+    stmia r1!, {r3-r10}
+    cmp r0, r2
+    ble 1b
+    /* Jump to SDRAM */
+    ldr r1, =0xFFFF
+    and r0, pc, r1         /* offset of pc */
+    ldr r1, =(SDRAM_BASE_ADDR + SDRAM_SIZE - 0x100000 + 0x8)
+    add pc, r0, r1
+    nop
+    nop
+    nop
+    nop
+#endif /* CYG_HAL_STARTUP_ROMRAM */
+
+HWInitialise_skip_SDRAM_copy:
+
+/*
+ * Note:
+ *     IOMUX/PBC setup is done in C function plf_hardware_init() for simplicity
+ */
+
+STACK_Setup:
+    // Set up a stack [for calling C code]
+    ldr r1, =__startup_stack
+    ldr r2, =RAM_BANK0_BASE
+    orr sp, r1, r2
+
+    // Create MMU tables
+    bl hal_mmu_init
+
+    // Enable MMU
+    ldr r2, =10f
+    mrc MMU_CP, 0, r1, MMU_Control, c0      // get c1 value to r1 first
+    orr r1, r1, #7                          // enable MMU bit
+    mcr MMU_CP, 0, r1, MMU_Control, c0
+    mov pc,r2    /* Change address spaces */
+    nop
+    nop
+    nop
+10:
+
+    // Save shadow copy of BCR, also hardware configuration
+    ldr r1, =_board_BCR
+    str r2, [r1]
+    ldr r1, =_board_CFG
+    str r9, [r1]                // Saved far above...
+    ldr r1, =_mxc_boot
+    str r11, [r1]
+
+    .endm                       // _platform_setup1
+
+#else // defined(CYG_HAL_STARTUP_ROM) || defined(CYG_HAL_STARTUP_ROMRAM)
+#define PLATFORM_SETUP1
+#endif
+
+    /* Do nothing */
+    .macro  init_spba
+    .endm  /* init_spba */
+
+    /* AIPS setup - Only setup MPROTx registers. The PACR default values are good.*/
+    .macro init_aips
+        /*
+         * Set all MPROTx to be non-bufferable, trusted for R/W,
+         * not forced to user-mode.
+         */
+        ldr r0, AIPS1_CTRL_BASE_ADDR_W
+        ldr r1, AIPS1_PARAM_W
+        str r1, [r0, #0x00]
+        str r1, [r0, #0x04]
+        ldr r0, AIPS2_CTRL_BASE_ADDR_W
+        str r1, [r0, #0x00]
+        str r1, [r0, #0x04]
+
+        /*
+         * Clear the on and off peripheral modules Supervisor Protect bit
+         * for SDMA to access them. Did not change the AIPS control registers
+         * (offset 0x20) access type
+         */
+        ldr r0, AIPS1_CTRL_BASE_ADDR_W
+        ldr r1, =0x0
+        str r1, [r0, #0x40]
+        str r1, [r0, #0x44]
+        str r1, [r0, #0x48]
+        str r1, [r0, #0x4C]
+        ldr r1, [r0, #0x50]
+        and r1, r1, #0x00FFFFFF
+        str r1, [r0, #0x50]
+
+        ldr r0, AIPS2_CTRL_BASE_ADDR_W
+        ldr r1, =0x0
+        str r1, [r0, #0x40]
+        str r1, [r0, #0x44]
+        str r1, [r0, #0x48]
+        str r1, [r0, #0x4C]
+        ldr r1, [r0, #0x50]
+        and r1, r1, #0x00FFFFFF
+        str r1, [r0, #0x50]
+    .endm /* init_aips */
+
+    /* MAX (Multi-Layer AHB Crossbar Switch) setup */
+    .macro init_max
+        ldr r0, MAX_BASE_ADDR_W
+#if 0
+        /* MPR - priority is M4 > M2 > M3 > M5 > M0 > M1 */
+        ldr r1, MAX_PARAM1
+        str r1, [r0, #0x000]        /* for S0 */
+        str r1, [r0, #0x100]        /* for S1 */
+        str r1, [r0, #0x200]        /* for S2 */
+        str r1, [r0, #0x300]        /* for S3 */
+        str r1, [r0, #0x400]        /* for S4 */
+        /* SGPCR - always park on last master */
+        ldr r1, =0x10
+        str r1, [r0, #0x010]        /* for S0 */
+        str r1, [r0, #0x110]        /* for S1 */
+        str r1, [r0, #0x210]        /* for S2 */
+        str r1, [r0, #0x310]        /* for S3 */
+        str r1, [r0, #0x410]        /* for S4 */
+        /* MGPCR - restore default values */
+        ldr r1, =0x0
+        str r1, [r0, #0x800]        /* for M0 */
+        str r1, [r0, #0x900]        /* for M1 */
+        str r1, [r0, #0xA00]        /* for M2 */
+        str r1, [r0, #0xB00]        /* for M3 */
+        str r1, [r0, #0xC00]        /* for M4 */
+        str r1, [r0, #0xD00]        /* for M5 */
+#endif
+    .endm /* init_max */
+
+    .macro    init_clock
+        /*
+         * Clock setup
+         * After this step,
+
+           Module           Freq (MHz)
+           ===========================
+           ARM core         532          ap_clk
+           AHB              133          ahb_clk
+           IP               66.5         ipg_clk
+           EMI              133          ddr_clk
+
+         * All other clocks can be figured out based on this.
+         */
+        /*
+        * Step 1: Switch to step clock
+        */
+        ldr r0, CCM_BASE_ADDR_W
+        mov r1, #0x00000104
+        str r1, [r0, #CLKCTL_CCSR]
+
+        /* Step 2: Setup PLL's */
+        /* Set PLL1 to be 532MHz */
+        ldr r0, PLL1_BASE_ADDR_W
+
+        mov r1, #0x1200
+        add r1, r1, #0x22
+        str r1, [r0, #PLL_DP_CTL]     /* Set DPLL ON (set UPEN bit); BRMO=1 */
+        ldr r1, =0x2
+        str r1, [r0, #PLL_DP_CONFIG]  /* Enable auto-restart AREN bit */
+
+        ldr r1, =0x50
+        str r1, [r0, #PLL_DP_OP]
+        ldr r1, =23
+        str r1, [r0, #PLL_DP_MFD]
+        ldr r1, =13
+        str r1, [r0, #PLL_DP_MFN]
+
+        ldr r1, =0x50
+        str r1, [r0, #PLL_DP_HFS_OP]
+        ldr r1, =23
+        str r1, [r0, #PLL_DP_HFS_MFD]
+        ldr r1, =13
+        str r1, [r0, #PLL_DP_HFS_MFN]
+
+        /* Now restart PLL 1 */
+        ldr r1, PLL_VAL_0x1232
+        str r1, [r0, #PLL_DP_CTL]
+wait_pll0_lock:
+        ldr r1, [r0, #PLL_DP_CTL]
+        ands r1, r1, #0x1
+        beq wait_pll0_lock
+
+        /*
+        * Step 2: Setup PLL2 to 665 MHz.
+        */
+        ldr r0, PLL2_BASE_ADDR_W
+
+        ldr r1, =0x1200
+        add r1, r1, #0x22
+        str r1, [r0, #PLL_DP_CTL]     /* Set DPLL ON (set UPEN bit); BRMO=1 */
+        ldr r1, =0x2
+        str r1, [r0, #PLL_DP_CONFIG]  /* Enable auto-restart AREN bit */
+
+        ldr r1, =0x60
+        str r1, [r0, #PLL_DP_OP]
+        ldr r1, =95
+        str r1, [r0, #PLL_DP_MFD]
+        ldr r1, =89
+        str r1, [r0, #PLL_DP_MFN]
+
+        ldr r1, =0x60
+        str r1, [r0, #PLL_DP_HFS_OP]
+        ldr r1, =95
+        str r1, [r0, #PLL_DP_HFS_MFD]
+        ldr r1, =89
+        str r1, [r0, #PLL_DP_HFS_MFN]
+
+        /* Now restart PLL 2 */
+        ldr r1, PLL_VAL_0x1232
+        str r1, [r0, #PLL_DP_CTL]
+wait_pll1_lock:
+        ldr r1, [r0, #PLL_DP_CTL]
+        ands r1, r1, #0x1
+        beq wait_pll1_lock
+
+        /*
+        * Set PLL 3 to 216MHz
+        */
+        ldr r0, PLL3_BASE_ADDR_W
+
+        ldr r1, PLL_VAL_0x222
+        str r1, [r0, #PLL_DP_CTL]     /* Set DPLL ON (set UPEN bit); BRMO=1 */
+        ldr r1, =0x2
+        str r1, [r0, #PLL_DP_CONFIG]  /* Enable auto-restart AREN bit */
+
+        ldr r1, =0x91
+        str r1, [r0, #PLL_DP_OP]
+        ldr r1, =0x0
+        str r1, [r0, #PLL_DP_MFD]
+        ldr r1, =0x0
+        str r1, [r0, #PLL_DP_MFN]
+
+        ldr r1, =0x91
+        str r1, [r0, #PLL_DP_HFS_OP]
+        ldr r1, =0x0
+        str r1, [r0, #PLL_DP_HFS_MFD]
+        ldr r1, =0x0
+        str r1, [r0, #PLL_DP_HFS_MFN]
+
+        /* Now restart PLL 3 */
+        ldr r1, PLL_VAL_0x232
+        str r1, [r0, #PLL_DP_CTL]
+
+wait_pll2_lock:
+        ldr r1, [r0, #PLL_DP_CTL]
+        ands r1, r1, #0x1
+        beq wait_pll2_lock
+        /* End of PLL 3 setup */
+
+        /*
+        * Step 3: switching to PLL 1 and restore default register values.
+        */
+        ldr r0, CCM_BASE_ADDR_W
+        mov r1, #0x00000100
+        str r1, [r0, #CLKCTL_CCSR]
+
+        mov r1, #0x000A0000
+        add r1, r1, #0x00000F0
+        str r1, [r0, #CLKCTL_CCOSR]
+        /* Use 133MHz for DDR clock */
+        mov r1, #0x1C00
+        str r1, [r0, #CLKCTL_CAMR]
+        /* Use PLL 2 for UART's, get 66.5MHz from it */
+        ldr r1, CCM_VAL_0xA5A6A020
+        str r1, [r0, #CLKCTL_CSCMR1]
+        ldr r1, CCM_VAL_0x01450321
+        str r1, [r0, #CLKCTL_CSCDR1]
+
+        mov r1, #0x1C
+        str r1, [r0, #CLKCTL_CBCDR7]
+        mov r1, #1
+        str r1, [r0, #4]
+    .endm /* init_clock */
+
+    /* M3IF setup */
+    .macro init_m3if
+#if 0
+        /* Configure M3IF registers */
+        ldr r1, M3IF_BASE_W
+        /*
+        * M3IF Control Register (M3IFCTL)
+        * MRRP[0] = L2CC0 not on priority list (0 << 0)        = 0x00000000
+        * MRRP[1] = L2CC1 not on priority list (0 << 0)        = 0x00000000
+        * MRRP[2] = MBX not on priority list (0 << 0)        = 0x00000000
+        * MRRP[3] = MAX1 not on priority list (0 << 0)        = 0x00000000
+        * MRRP[4] = SDMA not on priority list (0 << 0)        = 0x00000000
+        * MRRP[5] = MPEG4 not on priority list (0 << 0)       = 0x00000000
+        * MRRP[6] = IPU1 on priority list (1 << 6)             = 0x00000040
+        * MRRP[7] = IPU2 not on priority list (0 << 0)   = 0x00000000
+        *                                                       ------------
+        *                                                       0x00000040
+        */
+        ldr r0, =0x00000040
+        str r0, [r1]  /* M3IF control reg */
+#endif
+    .endm /* init_m3if */
+
+    .macro setup_sdram
+        ldr r0, ESDCTL_BASE_W
+        /* Set CSD0 */
+        ldr r1, =0x80000000
+        str r1, [r0, #ESDCTL_ESDCTL0]
+        /* Precharge command */
+        ldr r1, SDRAM_0x04008008
+        str r1, [r0, #ESDCTL_ESDSCR]
+        /* 2 refresh commands */
+        ldr r1, SDRAM_0x00008010
+        str r1, [r0, #ESDCTL_ESDSCR]
+        str r1, [r0, #ESDCTL_ESDSCR]
+        /* LMR with CAS=3 and BL=3 */
+        ldr r1, SDRAM_0x00338018
+        str r1, [r0, #ESDCTL_ESDSCR]
+        /* 13 ROW, 10 COL, 32Bit, SREF=4 Micron Model */
+        ldr r1, SDRAM_0xB2220000
+        str r1, [r0, #ESDCTL_ESDCTL0]
+        /* Timing parameters */
+        ldr r1, SDRAM_0x899F6BBA
+        str r1, [r0, #ESDCTL_ESDCFG0]
+        /* MDDR enable, RLAT=2 */
+        ldr r1, SDRAM_0x000A0104
+        str r1, [r0, #ESDCTL_ESDMISC]
+        /* Normal mode */
+        ldr r1, =0x00000000
+        str r1, [r0, #ESDCTL_ESDSCR]
+    .endm
+
+    .macro do_wait_op_done
+    1:
+        ldr r3, [r11, #0x18]
+        ands r3, r3, #NFC_IPC_INT
+        beq 1b
+        mov r3, #0x0
+        str r3, [r11, #0x18]
+    .endm   // do_wait_op_done
+
+    .macro do_addr_input
+        str r3, [r12, #0x0]
+        mov r3, #NAND_LAUNCH_FADD
+        str r3, [r12, #0xC]
+        do_wait_op_done
+    .endm   // do_addr_input
+
+    /* To support 133MHz DDR */
+    .macro  init_iomux
+        ldr r0, IOMUXC_BASE_ADDR_W
+        // AP CKO/CKOH selected
+        ldr r8, =0x1
+        str r8, [r0, #0x228]
+
+        // DDR signal setup for D16-D31 and drive strength
+        ldr r8, =0x1
+        add r1, r0, #8
+        add r2, r0, #0x4C
+    1:
+        stmia r1!, {r8}
+        cmp r1, r2
+        bls 1b
+
+        str r8, [r0, #0x5C]
+        str r8, [r0, #0x60]
+
+        ldr r8, =0x80
+        add r1, r0, #230
+        add r2, r0, #0x26C
+    1:
+        stmia r1!, {r8}
+        cmp r1, r2
+        bls 1b
+
+    add r4, r0, #0x400
+      ldr r8, =0x200
+        str r8, [r4, #0xD8]
+        str r8, [r4, #0xE8]
+      ldr r8, =0
+        str r8, [r4, #0xC4]
+      ldr r8, =4
+        str r8, [r4, #0xE4]
+        str r8, [r4, #0xF4]
+
+    add r2, r0, #0x200
+      mov r8, #0x204
+        str r8, [r2, #0xA8]
+        str r8, [r2, #0xAC]
+      mov r8, #0x2C4
+        str r8, [r2, #0xBC]
+        str r8, [r2, #0xC0]
+    .endm /* init_iomux */
+
+#define PLATFORM_VECTORS         _platform_vectors
+    .macro  _platform_vectors
+        .globl  _board_BCR, _board_CFG, _mxc_boot
+_board_BCR:   .long   0       // Board Control register shadow
+_board_CFG:   .long   0       // Board Configuration (read at RESET)
+_mxc_boot:    .long   0       // Used to figure out boot type
+    .endm
+
+ARM_PPMRR:              .word   0x80000016
+L2CACHE_PARAM:          .word   0x0003001B
+WDOG1_BASE_W:           .word   WDOG1_BASE_ADDR
+IIM_SREV_REG_VAL:       .word   IIM_BASE_ADDR + IIM_SREV_OFF
+AIPS1_CTRL_BASE_ADDR_W: .word   AIPS1_CTRL_BASE_ADDR
+AIPS2_CTRL_BASE_ADDR_W: .word   AIPS2_CTRL_BASE_ADDR
+AIPS1_PARAM_W:          .word   0x77777777
+MAX_BASE_ADDR_W:        .word   MAX_BASE_ADDR
+MAX_PARAM1:             .word   0x00302154
+ESDCTL_BASE_W:          .word   ESDCTL_BASE
+M3IF_BASE_W:            .word   M4IF_BASE
+NFC_BASE_W:             .word   NFC_BASE
+NFC_IP_BASE_W:          .word   NFC_IP_BASE
+SDRAM_0x04008008:       .word   0x04008008
+SDRAM_0x00008010:       .word   0x00008010
+SDRAM_0x00338018:       .word   0x00338018
+SDRAM_0xB2220000:       .word   0xB2220000
+SDRAM_0x899F6BBA:       .word   0x899F6BBA
+SDRAM_0x000A0104:       .word   0x000A0104
+IOMUXC_BASE_ADDR_W:     .word   IOMUXC_BASE_ADDR
+MXC_REDBOOT_ROM_START:  .word   SDRAM_BASE_ADDR + SDRAM_SIZE - 0x100000
+CONST_0x0FFF:           .word   0x0FFF
+CCM_BASE_ADDR_W:        .word   CCM_BASE_ADDR
+CCM_VAL_0x01450321:     .word   0x01450321
+CCM_VAL_0xA5A6A020:     .word   0xA5A6A020
+PLL_VAL_0x222:          .word   0x222
+PLL_VAL_0x232:          .word   0x232
+PLL1_BASE_ADDR_W:       .word   PLL1_BASE_ADDR
+PLL2_BASE_ADDR_W:       .word   PLL2_BASE_ADDR
+PLL3_BASE_ADDR_W:       .word   PLL3_BASE_ADDR
+PLL_VAL_0x1232:         .word   0x1232
+
+/*---------------------------------------------------------------------------*/
+/* end of hal_platform_setup.h                                               */
+#endif /* CYGONCE_HAL_PLATFORM_SETUP_H */
diff -urN -x CVS -x doc -x lwip_tcpip -x calmrisc16 -x calmrisc32 ecos_20050912/packages/hal/arm/mx51/3stack/current/include/pkgconf/mlt_arm_board_romram.h ecos_base/packages/hal/arm/mx51/3stack/current/include/pkgconf/mlt_arm_board_romram.h
--- ecos_20050912/packages/hal/arm/mx51/3stack/current/include/pkgconf/mlt_arm_board_romram.h	1969-12-31 18:00:00.000000000 -0600
+++ ecos_base/packages/hal/arm/mx51/3stack/current/include/pkgconf/mlt_arm_board_romram.h	2008-04-01 12:14:09.000000000 -0500
@@ -0,0 +1,20 @@
+// eCos memory layout - Fri Oct 20 05:56:55 2000
+
+// This is a generated file - do not edit
+
+#ifndef __ASSEMBLER__
+#include <cyg/infra/cyg_type.h>
+#include <stddef.h>
+
+#endif
+#define CYGMEM_REGION_ram (0x00000000)
+#define CYGMEM_REGION_ram_SIZE (0x7F00000)
+#define CYGMEM_REGION_ram_ATTR (CYGMEM_REGION_ATTR_R | CYGMEM_REGION_ATTR_W)
+#define CYGMEM_REGION_rom (0x47F00000)
+#define CYGMEM_REGION_rom_SIZE (0x100000)
+#define CYGMEM_REGION_rom_ATTR (CYGMEM_REGION_ATTR_R)
+#ifndef __ASSEMBLER__
+extern char CYG_LABEL_NAME (__heap1) [];
+#endif
+#define CYGMEM_SECTION_heap1 (CYG_LABEL_NAME (__heap1))
+#define CYGMEM_SECTION_heap1_SIZE (CYGMEM_REGION_ram_SIZE - (size_t) CYG_LABEL_NAME (__heap1))
diff -urN -x CVS -x doc -x lwip_tcpip -x calmrisc16 -x calmrisc32 ecos_20050912/packages/hal/arm/mx51/3stack/current/include/pkgconf/mlt_arm_board_romram.ldi ecos_base/packages/hal/arm/mx51/3stack/current/include/pkgconf/mlt_arm_board_romram.ldi
--- ecos_20050912/packages/hal/arm/mx51/3stack/current/include/pkgconf/mlt_arm_board_romram.ldi	1969-12-31 18:00:00.000000000 -0600
+++ ecos_base/packages/hal/arm/mx51/3stack/current/include/pkgconf/mlt_arm_board_romram.ldi	2008-04-01 12:14:09.000000000 -0500
@@ -0,0 +1,28 @@
+// eCos memory layout - Fri Oct 20 05:56:55 2000
+
+// This is a generated file - do not edit
+
+#include <cyg/infra/cyg_type.inc>
+
+MEMORY
+{
+    ram : ORIGIN = 0, LENGTH = 0x7F00000
+    rom : ORIGIN = 0x47F00000, LENGTH = 0x100000
+}
+
+SECTIONS
+{
+    SECTIONS_BEGIN
+    SECTION_rom_vectors (rom, 0x47F00000, LMA_EQ_VMA)
+    SECTION_text (rom, ALIGN (0x4), LMA_EQ_VMA)
+    SECTION_fini (rom, ALIGN (0x4), LMA_EQ_VMA)
+    SECTION_rodata (rom, ALIGN (0x4), LMA_EQ_VMA)
+    SECTION_rodata1 (rom, ALIGN (0x4), LMA_EQ_VMA)
+    SECTION_fixup (rom, ALIGN (0x4), LMA_EQ_VMA)
+    SECTION_gcc_except_table (rom, ALIGN (0x4), LMA_EQ_VMA)
+    SECTION_fixed_vectors (ram, 0x20, LMA_EQ_VMA)
+    SECTION_data (ram, 0x8000, FOLLOWING (.gcc_except_table))
+    SECTION_bss (ram, ALIGN (0x4), LMA_EQ_VMA)
+    CYG_LABEL_DEFN(__heap1) = ALIGN (0x8);
+    SECTIONS_END
+}
diff -urN -x CVS -x doc -x lwip_tcpip -x calmrisc16 -x calmrisc32 ecos_20050912/packages/hal/arm/mx51/3stack/current/include/pkgconf/mlt_arm_board_romram.mlt ecos_base/packages/hal/arm/mx51/3stack/current/include/pkgconf/mlt_arm_board_romram.mlt
--- ecos_20050912/packages/hal/arm/mx51/3stack/current/include/pkgconf/mlt_arm_board_romram.mlt	1969-12-31 18:00:00.000000000 -0600
+++ ecos_base/packages/hal/arm/mx51/3stack/current/include/pkgconf/mlt_arm_board_romram.mlt	2008-04-01 12:14:09.000000000 -0500
@@ -0,0 +1,14 @@
+version 0
+region ram 0 7F00000 0 !
+region rom 47F00000 100000 1 !
+section fixed_vectors 0 1 0 1 1 0 1 0 20 20 !
+section data 0 1 1 1 1 1 0 0 8000 bss !
+section bss 0 4 0 1 0 1 0 1 heap1 heap1 !
+section heap1 0 8 0 0 0 0 0 0 !
+section rom_vectors 0 1 0 1 1 1 1 1 47F00000 47F00000 text text !
+section text 0 4 0 1 0 1 0 1 fini fini !
+section fini 0 4 0 1 0 1 0 1 rodata rodata !
+section rodata 0 4 0 1 0 1 0 1 rodata1 rodata1 !
+section rodata1 0 4 0 1 0 1 0 1 fixup fixup !
+section fixup 0 4 0 1 0 1 0 1 gcc_except_table gcc_except_table !
+section gcc_except_table 0 4 0 1 0 0 0 1 data !
diff -urN -x CVS -x doc -x lwip_tcpip -x calmrisc16 -x calmrisc32 ecos_20050912/packages/hal/arm/mx51/3stack/current/include/plf_io.h ecos_base/packages/hal/arm/mx51/3stack/current/include/plf_io.h
--- ecos_20050912/packages/hal/arm/mx51/3stack/current/include/plf_io.h	1969-12-31 18:00:00.000000000 -0600
+++ ecos_base/packages/hal/arm/mx51/3stack/current/include/plf_io.h	2008-04-01 12:14:09.000000000 -0500
@@ -0,0 +1,69 @@
+#ifndef CYGONCE_HAL_ARM_BOARD_PLF_IO_H
+#define CYGONCE_HAL_ARM_BOARD_PLF_IO_H
+
+//=============================================================================
+//
+//      plf_io.h
+//
+//      Platform specific support (register layout, etc)
+//
+//=============================================================================
+//####ECOSGPLCOPYRIGHTBEGIN####
+// -------------------------------------------
+// This file is part of eCos, the Embedded Configurable Operating System.
+// Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+//
+// eCos is free software; you can redistribute it and/or modify it under
+// the terms of the GNU General Public License as published by the Free
+// Software Foundation; either version 2 or (at your option) any later version.
+//
+// eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with eCos; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+//
+// As a special exception, if other files instantiate templates or use macros
+// or inline functions from this file, or you compile this file and link it
+// with other works to produce a work based on this file, this file does not
+// by itself cause the resulting work to be covered by the GNU General Public
+// License. However the source code for this file must still be made available
+// in accordance with section (3) of the GNU General Public License.
+//
+// This exception does not invalidate any other reasons why a work based on
+// this file might be covered by the GNU General Public License.
+//
+// Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+// at http://sources.redhat.com/ecos/ecos-license/
+// -------------------------------------------
+//####ECOSGPLCOPYRIGHTEND####
+//=============================================================================
+
+#include <cyg/hal/fsl_board.h>
+#include <cyg/hal/hal_soc.h>
+
+#define CYGHWR_REDBOOT_LINUX_ATAG_MEM(_p_)                                                           \
+    CYG_MACRO_START                                                                                  \
+    {                                                                                                \
+      extern unsigned int system_rev;                                                                \
+             /* Next ATAG_MEM. */                                                                    \
+         _p_->hdr.size = (sizeof(struct tag_mem32) + sizeof(struct tag_header))/sizeof(long);        \
+         _p_->hdr.tag = ATAG_MEM;                                                                    \
+         /* Round up so there's only one bit set in the memory size.                                 \
+         * Don't double it if it's already a power of two, though.                                   \
+         */                                                                                          \
+         _p_->u.mem.size  = 1<<hal_msbindex(CYGMEM_REGION_ram_SIZE);                                 \
+         if (_p_->u.mem.size < CYGMEM_REGION_ram_SIZE)                                               \
+                 _p_->u.mem.size <<= 1;                                                              \
+         _p_->u.mem.start = CYGARC_PHYSICAL_ADDRESS(CYGMEM_REGION_ram);                              \
+         _p_ = (struct tag *)((long *)_p_ + _p_->hdr.size);                                          \
+         _p_->hdr.size = ((sizeof(struct tag_revision)) + sizeof(struct tag_header))/sizeof(long);   \
+         _p_->hdr.tag = ATAG_REVISION;                                                               \
+         _p_->u.revision.rev = system_rev;                                                           \
+     }                                                                                               \
+    CYG_MACRO_END
+
+#endif // CYGONCE_HAL_ARM_BOARD_PLF_IO_H
diff -urN -x CVS -x doc -x lwip_tcpip -x calmrisc16 -x calmrisc32 ecos_20050912/packages/hal/arm/mx51/3stack/current/include/plf_mmap.h ecos_base/packages/hal/arm/mx51/3stack/current/include/plf_mmap.h
--- ecos_20050912/packages/hal/arm/mx51/3stack/current/include/plf_mmap.h	1969-12-31 18:00:00.000000000 -0600
+++ ecos_base/packages/hal/arm/mx51/3stack/current/include/plf_mmap.h	2008-04-01 12:14:09.000000000 -0500
@@ -0,0 +1,65 @@
+#ifndef CYGONCE_HAL_BOARD_PLATFORM_PLF_MMAP_H
+#define CYGONCE_HAL_BOARD_PLATFORM_PLF_MMAP_H
+//=============================================================================
+//
+//      plf_mmap.h
+//
+//      Platform specific memory map support
+//
+//=============================================================================
+//####ECOSGPLCOPYRIGHTBEGIN####
+// -------------------------------------------
+// This file is part of eCos, the Embedded Configurable Operating System.
+// Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+//
+// eCos is free software; you can redistribute it and/or modify it under
+// the terms of the GNU General Public License as published by the Free
+// Software Foundation; either version 2 or (at your option) any later version.
+//
+// eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with eCos; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+//
+// As a special exception, if other files instantiate templates or use macros
+// or inline functions from this file, or you compile this file and link it
+// with other works to produce a work based on this file, this file does not
+// by itself cause the resulting work to be covered by the GNU General Public
+// License. However the source code for this file must still be made available
+// in accordance with section (3) of the GNU General Public License.
+//
+// This exception does not invalidate any other reasons why a work based on
+// this file might be covered by the GNU General Public License.
+//
+// Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+// at http://sources.redhat.com/ecos/ecos-license/
+// -------------------------------------------
+//####ECOSGPLCOPYRIGHTEND####
+//===========================================================================
+
+#include <cyg/hal/hal_misc.h>
+
+// Get the pagesize for a particular virtual address:
+
+// This does not depend on the vaddr.
+#define HAL_MM_PAGESIZE(vaddr, pagesize) CYG_MACRO_START        \
+        (pagesize) = SZ_1M;                                         \
+CYG_MACRO_END
+
+// Get the physical address from a virtual address:
+
+#define HAL_VIRT_TO_PHYS_ADDRESS( vaddr, paddr ) CYG_MACRO_START           \
+        cyg_uint32 _v_ = (cyg_uint32)(vaddr);                                  \
+        if ( _v_ < 128 * SZ_1M )          /* SDRAM */                           \
+                _v_ += SDRAM_BASE_ADDR;                                             \
+        else                             /* Rest of it */                      \
+                /* no change */ ;                                                  \
+                (paddr) = _v_;                                                         \
+CYG_MACRO_END
+
+//---------------------------------------------------------------------------
+#endif // CYGONCE_HAL_BOARD_PLATFORM_PLF_MMAP_H
diff -urN -x CVS -x doc -x lwip_tcpip -x calmrisc16 -x calmrisc32 ecos_20050912/packages/hal/arm/mx51/3stack/current/misc/redboot_ROMRAM.ecm ecos_base/packages/hal/arm/mx51/3stack/current/misc/redboot_ROMRAM.ecm
--- ecos_20050912/packages/hal/arm/mx51/3stack/current/misc/redboot_ROMRAM.ecm	1969-12-31 18:00:00.000000000 -0600
+++ ecos_base/packages/hal/arm/mx51/3stack/current/misc/redboot_ROMRAM.ecm	2008-04-01 12:14:10.000000000 -0500
@@ -0,0 +1,124 @@
+cdl_savefile_version 1;
+cdl_savefile_command cdl_savefile_version {};
+cdl_savefile_command cdl_savefile_command {};
+cdl_savefile_command cdl_configuration { description hardware template package };
+cdl_savefile_command cdl_package { value_source user_value wizard_value inferred_value };
+cdl_savefile_command cdl_component { value_source user_value wizard_value inferred_value };
+cdl_savefile_command cdl_option { value_source user_value wizard_value inferred_value };
+cdl_savefile_command cdl_interface { value_source user_value wizard_value inferred_value };
+
+cdl_configuration eCos {
+    description "" ;
+    hardware    mx51_3stack ;
+    template    redboot ;
+    package -hardware CYGPKG_HAL_ARM current ;
+    package -hardware CYGPKG_HAL_ARM_MX51 current ;
+    package -hardware CYGPKG_HAL_ARM_MX51_3STACK current ;
+    package -hardware CYGPKG_IO_ETH_DRIVERS current ;
+    package -hardware CYGPKG_DEVS_ETH_ARM_IMX_3STACK current ;
+    package -hardware CYGPKG_DEVS_ETH_SMSC_LAN92XX current ;
+    package -hardware CYGPKG_COMPRESS_ZLIB current ;
+    package -hardware CYGPKG_IO_FLASH current ;
+    package -hardware CYGPKG_DEVS_FLASH_ONMXC current ;
+    package -hardware CYGPKG_DEVS_MXC_SPI current ;
+    #package -hardware CYGPKG_DEVS_MXC_I2C current ;
+    package -template CYGPKG_HAL current ;
+    package -template CYGPKG_INFRA current ;
+    package -template CYGPKG_REDBOOT current ;
+    package -template CYGPKG_ISOINFRA current ;
+    package -template CYGPKG_LIBC_STRING current ;
+    package -template CYGPKG_CRC current ;
+    package CYGPKG_MEMALLOC current ;
+};
+
+cdl_option CYGFUN_LIBC_STRING_BSD_FUNCS {
+    inferred_value 0
+};
+
+cdl_option CYGHWR_DEVS_FLASH_MXC_NOR {
+    inferred_value 0
+};
+
+cdl_option CYGHWR_DEVS_FSL_SPI_VER_2_3 {
+    inferred_value 1
+};
+
+cdl_option CYGHWR_DEVS_FLASH_MXC_NAND {
+    inferred_value 1
+};
+
+cdl_option CYGIMP_HAL_COMMON_INTERRUPTS_USE_INTERRUPT_STACK {
+    inferred_value 0
+};
+
+cdl_option CYGNUM_HAL_COMMON_INTERRUPTS_STACK_SIZE {
+    user_value 4096
+};
+
+cdl_option CYGDBG_HAL_COMMON_INTERRUPTS_SAVE_MINIMUM_CONTEXT {
+    user_value 0
+};
+
+cdl_option CYGDBG_REDBOOT_TICK_GRANULARITY {
+    user_value 50
+};
+
+cdl_option CYGDBG_HAL_COMMON_CONTEXT_SAVE_MINIMUM {
+    inferred_value 0
+};
+
+cdl_option CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS {
+    inferred_value 1
+};
+
+cdl_option CYGSEM_HAL_ROM_MONITOR {
+    inferred_value 1
+};
+
+cdl_component CYGBLD_BUILD_REDBOOT {
+    user_value 1
+};
+
+cdl_option CYGBLD_REDBOOT_MIN_IMAGE_SIZE {
+    inferred_value 0x00040000
+};
+
+cdl_option CYGHWR_REDBOOT_ARM_LINUX_EXEC_ADDRESS_DEFAULT {
+    inferred_value 0x40008000
+};
+
+cdl_option CYGBLD_ISO_STRTOK_R_HEADER {
+    inferred_value 1 <cyg/libc/string/string.h>
+};
+
+cdl_option CYGBLD_ISO_STRING_LOCALE_FUNCS_HEADER {
+    inferred_value 1 <cyg/libc/string/string.h>
+};
+
+cdl_option CYGBLD_ISO_STRING_BSD_FUNCS_HEADER {
+    inferred_value 1 <cyg/libc/string/bsdstring.h>
+};
+
+cdl_option CYGBLD_ISO_STRING_MEMFUNCS_HEADER {
+    inferred_value 1 <cyg/libc/string/string.h>
+};
+
+cdl_option CYGBLD_ISO_STRING_STRFUNCS_HEADER {
+    inferred_value 1 <cyg/libc/string/string.h>
+};
+
+cdl_component CYG_HAL_STARTUP {
+    user_value ROMRAM
+};
+
+cdl_component CYGPRI_REDBOOT_ZLIB_FLASH_FORCE {
+    inferred_value 1
+};
+
+cdl_option CYGNUM_REDBOOT_FIS_DIRECTORY_BLOCK {
+    inferred_value 2
+};
+
+cdl_option CYGDAT_REDBOOT_CUSTOM_VERSION {
+    user_value 1 "FSL 200812"
+};
diff -urN -x CVS -x doc -x lwip_tcpip -x calmrisc16 -x calmrisc32 ecos_20050912/packages/hal/arm/mx51/3stack/current/src/board_diag.c ecos_base/packages/hal/arm/mx51/3stack/current/src/board_diag.c
--- ecos_20050912/packages/hal/arm/mx51/3stack/current/src/board_diag.c	1969-12-31 18:00:00.000000000 -0600
+++ ecos_base/packages/hal/arm/mx51/3stack/current/src/board_diag.c	2008-04-01 12:14:10.000000000 -0500
@@ -0,0 +1,647 @@
+/*=============================================================================
+//
+//      board_diag.c
+//
+//      HAL diagnostic output code
+//
+//=============================================================================
+//####ECOSGPLCOPYRIGHTBEGIN####
+// -------------------------------------------
+// This file is part of eCos, the Embedded Configurable Operating System.
+// Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+//
+// eCos is free software; you can redistribute it and/or modify it under
+// the terms of the GNU General Public License as published by the Free
+// Software Foundation; either version 2 or (at your option) any later version.
+//
+// eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with eCos; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+//
+// As a special exception, if other files instantiate templates or use macros
+// or inline functions from this file, or you compile this file and link it
+// with other works to produce a work based on this file, this file does not
+// by itself cause the resulting work to be covered by the GNU General Public
+// License. However the source code for this file must still be made available
+// in accordance with section (3) of the GNU General Public License.
+//
+// This exception does not invalidate any other reasons why a work based on
+// this file might be covered by the GNU General Public License.
+//
+// Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+// at http://sources.redhat.com/ecos/ecos-license/
+// -------------------------------------------
+//####ECOSGPLCOPYRIGHTEND####
+//===========================================================================*/
+
+#include <pkgconf/hal.h>
+
+#include <cyg/infra/cyg_type.h>         // base types
+#include <cyg/infra/cyg_trac.h>         // tracing macros
+#include <cyg/infra/cyg_ass.h>          // assertion macros
+
+#include <cyg/hal/hal_arch.h>           // basic machine info
+#include <cyg/hal/hal_intr.h>           // interrupt macros
+#include <cyg/hal/hal_io.h>             // IO macros
+#include <cyg/hal/hal_diag.h>
+#include <cyg/hal/hal_if.h>             // Calling-if API
+#include <cyg/hal/drv_api.h>            // driver API
+#include <cyg/hal/hal_misc.h>           // Helper functions
+#include <cyg/hal/hal_soc.h>            // Hardware definitions
+#include <cyg/hal/fsl_board.h>          // Platform specifics
+
+static void cyg_hal_plf_duart_init(void);
+extern void cyg_hal_plf_serial_init(void);
+
+#define DUART_WORKAROUND_DELAY(a)    hal_delay_us(a);
+
+
+void cyg_hal_plf_comms_init(void)
+{
+    static int initialized = 0;
+
+    if (initialized)
+        return;
+
+    initialized = 1;
+
+    /* Setup GPIO and enable transceiver for UARTs */
+    cyg_hal_plf_duart_init();
+    cyg_hal_plf_serial_init();
+}
+
+//=============================================================================
+// ST16552 DUART driver
+//=============================================================================
+
+//-----------------------------------------------------------------------------
+// There are two serial ports.
+#define CYG_DEV_SERIAL_BASE_A    (BOARD_CS_UART_BASE + 0x0000) // port A
+#define CYG_DEV_SERIAL_BASE_B    (BOARD_CS_UART_BASE + 0x8000) // port B
+
+//-----------------------------------------------------------------------------
+// Based on 14.7456 MHz xtal
+#if CYGNUM_HAL_VIRTUAL_VECTOR_CONSOLE_CHANNEL_BAUD==9600
+#define CYG_DEV_SERIAL_BAUD_MSB        0x00
+#define CYG_DEV_SERIAL_BAUD_LSB        0x60
+#endif
+#if CYGNUM_HAL_VIRTUAL_VECTOR_CONSOLE_CHANNEL_BAUD==19200
+#define CYG_DEV_SERIAL_BAUD_MSB        0x00
+#define CYG_DEV_SERIAL_BAUD_LSB        0x30
+#endif
+#if CYGNUM_HAL_VIRTUAL_VECTOR_CONSOLE_CHANNEL_BAUD==38400
+#define CYG_DEV_SERIAL_BAUD_MSB        0x00
+#define CYG_DEV_SERIAL_BAUD_LSB        0x18
+#endif
+#if CYGNUM_HAL_VIRTUAL_VECTOR_CONSOLE_CHANNEL_BAUD==57600
+#define CYG_DEV_SERIAL_BAUD_MSB        0x00
+#define CYG_DEV_SERIAL_BAUD_LSB        0x10
+#endif
+#if CYGNUM_HAL_VIRTUAL_VECTOR_CONSOLE_CHANNEL_BAUD==115200
+#define CYG_DEV_SERIAL_BAUD_MSB        0x00
+#define CYG_DEV_SERIAL_BAUD_LSB        0x08
+#endif
+
+#ifndef CYG_DEV_SERIAL_BAUD_MSB
+#error Missing/incorrect serial baud rate defined - CDL error?
+#endif
+
+//-----------------------------------------------------------------------------
+// Define the serial registers. The board is equipped with a 16552
+// serial chip.
+
+#ifdef EXT_UART_x16
+#define HAL_WRITE_UINT_UART HAL_WRITE_UINT16
+#define HAL_READ_UINT_UART HAL_READ_UINT16
+typedef cyg_uint16 uart_width;
+#else  //_x8
+typedef cyg_uint8 uart_width;
+#define HAL_WRITE_UINT_UART HAL_WRITE_UINT8
+#define HAL_READ_UINT_UART HAL_READ_UINT8
+#endif
+
+#define CYG_DEV_SERIAL_RHR   0x00 // receiver buffer register, read, dlab = 0
+#define CYG_DEV_SERIAL_THR   0x00 // transmitter holding register, write, dlab = 0
+#define CYG_DEV_SERIAL_DLL   0x00 // divisor latch (LS), read/write, dlab = 1
+#define CYG_DEV_SERIAL_IER   0x01 // interrupt enable register, read/write, dlab = 0
+#define CYG_DEV_SERIAL_DLM   0x01 // divisor latch (MS), read/write, dlab = 1
+#define CYG_DEV_SERIAL_IIR   0x02 // interrupt identification register, read, dlab = 0
+#define CYG_DEV_SERIAL_FCR   0x02 // fifo control register, write, dlab = 0
+#define CYG_DEV_SERIAL_AFR   0x02 // alternate function register, read/write, dlab = 1
+#define CYG_DEV_SERIAL_LCR   0x03 // line control register, read/write
+#define CYG_DEV_SERIAL_MCR   0x04
+#define CYG_DEV_SERIAL_MCR_A 0x04
+#define CYG_DEV_SERIAL_MCR_B 0x04
+#define CYG_DEV_SERIAL_LSR   0x05 // line status register, read
+#define CYG_DEV_SERIAL_MSR   0x06 // modem status register, read
+#define CYG_DEV_SERIAL_SCR   0x07 // scratch pad register
+
+// The interrupt enable register bits.
+#define SIO_IER_ERDAI   0x01            // enable received data available irq
+#define SIO_IER_ETHREI  0x02            // enable THR empty interrupt
+#define SIO_IER_ELSI    0x04            // enable receiver line status irq
+#define SIO_IER_EMSI    0x08            // enable modem status interrupt
+
+// The interrupt identification register bits.
+#define SIO_IIR_IP      0x01            // 0 if interrupt pending
+#define SIO_IIR_ID_MASK 0x0e            // mask for interrupt ID bits
+#define ISR_Tx          0x02
+#define ISR_Rx          0x04
+
+// The line status register bits.
+#define SIO_LSR_DR      0x01            // data ready
+#define SIO_LSR_OE      0x02            // overrun error
+#define SIO_LSR_PE      0x04            // parity error
+#define SIO_LSR_FE      0x08            // framing error
+#define SIO_LSR_BI      0x10            // break interrupt
+#define SIO_LSR_THRE    0x20            // transmitter holding register empty
+#define SIO_LSR_TEMT    0x40            // transmitter register empty
+#define SIO_LSR_ERR     0x80            // any error condition
+
+// The modem status register bits.
+#define SIO_MSR_DCTS    0x01            // delta clear to send
+#define SIO_MSR_DDSR    0x02            // delta data set ready
+#define SIO_MSR_TERI    0x04            // trailing edge ring indicator
+#define SIO_MSR_DDCD    0x08            // delta data carrier detect
+#define SIO_MSR_CTS     0x10            // clear to send
+#define SIO_MSR_DSR     0x20            // data set ready
+#define SIO_MSR_RI      0x40            // ring indicator
+#define SIO_MSR_DCD     0x80            // data carrier detect
+
+// The line control register bits.
+#define SIO_LCR_WLS0   0x01             // word length select bit 0
+#define SIO_LCR_WLS1   0x02             // word length select bit 1
+#define SIO_LCR_STB    0x04             // number of stop bits
+#define SIO_LCR_PEN    0x08             // parity enable
+#define SIO_LCR_EPS    0x10             // even parity select
+#define SIO_LCR_SP     0x20             // stick parity
+#define SIO_LCR_SB     0x40             // set break
+#define SIO_LCR_DLAB   0x80             // divisor latch access bit
+
+// The FIFO control register
+#define SIO_FCR_FCR0   0x01             // enable xmit and rcvr fifos
+#define SIO_FCR_FCR1   0x02             // clear RCVR FIFO
+#define SIO_FCR_FCR2   0x04             // clear XMIT FIFO
+
+//-----------------------------------------------------------------------------
+
+typedef struct {
+    uart_width* base;
+    cyg_int32 msec_timeout;
+    int isr_vector;
+} channel_data_t;
+
+static channel_data_t channels[] = {
+#if CYGHWR_HAL_ARM_DUART_UARTA != 0
+    {(uart_width*)CYG_DEV_SERIAL_BASE_A, 1000, 0},
+#endif
+#if CYGHWR_HAL_ARM_DUART_UARTB != 0
+    {(uart_width*)CYG_DEV_SERIAL_BASE_B, 1000, 0}
+#endif
+};
+
+//-----------------------------------------------------------------------------
+
+static void init_duart_channel(channel_data_t* __ch_data)
+{
+    uart_width* base = __ch_data->base;
+    uart_width lcr;
+
+    // 8-1-no parity.
+    HAL_WRITE_UINT_UART(base+CYG_DEV_SERIAL_LCR,
+                        SIO_LCR_WLS0 | SIO_LCR_WLS1);
+    DUART_WORKAROUND_DELAY(50);
+    HAL_READ_UINT_UART(base+CYG_DEV_SERIAL_LCR, lcr);
+    lcr |= SIO_LCR_DLAB;
+    DUART_WORKAROUND_DELAY(50);
+    HAL_WRITE_UINT_UART(base+CYG_DEV_SERIAL_LCR, lcr);
+    DUART_WORKAROUND_DELAY(50);
+    HAL_WRITE_UINT_UART(base+CYG_DEV_SERIAL_DLL, CYG_DEV_SERIAL_BAUD_LSB);
+    DUART_WORKAROUND_DELAY(50);
+    HAL_WRITE_UINT_UART(base+CYG_DEV_SERIAL_DLM, CYG_DEV_SERIAL_BAUD_MSB);
+    lcr &= ~SIO_LCR_DLAB;
+    DUART_WORKAROUND_DELAY(50);
+    HAL_WRITE_UINT_UART(base+CYG_DEV_SERIAL_LCR, lcr);
+    DUART_WORKAROUND_DELAY(50);
+    HAL_WRITE_UINT_UART(base+CYG_DEV_SERIAL_FCR, 0x07);  // Enable & clear FIFO
+}
+
+//#define x_debug_uart_log_buf
+#ifdef x_debug_uart_log_buf
+#define x_DIAG_BUFSIZE 2048
+static char __x_log_buf[x_DIAG_BUFSIZE];
+static int x_diag_bp = 0;
+#endif
+
+void cyg_hal_plf_duart_putc(void* __ch_data, cyg_uint8 c)
+{
+    uart_width* base = ((channel_data_t*)__ch_data)->base;
+    uart_width lsr;
+
+#ifdef x_debug_uart_log_buf
+    __x_log_buf[x_diag_bp++] = c;
+#endif
+    CYGARC_HAL_SAVE_GP();
+
+    do {
+        HAL_READ_UINT_UART(base+CYG_DEV_SERIAL_LSR, lsr);
+    } while ((lsr & SIO_LSR_THRE) == 0);
+
+    DUART_WORKAROUND_DELAY(50);
+    HAL_WRITE_UINT_UART(base+CYG_DEV_SERIAL_THR, c);
+
+    // Hang around until the character has been safely sent.
+    do {
+        HAL_READ_UINT_UART(base+CYG_DEV_SERIAL_LSR, lsr);
+    } while ((lsr & SIO_LSR_THRE) == 0);
+
+    CYGARC_HAL_RESTORE_GP();
+}
+
+static cyg_bool cyg_hal_plf_duart_getc_nonblock(void* __ch_data, cyg_uint8* ch)
+{
+    uart_width* base = ((channel_data_t*)__ch_data)->base;
+    uart_width lsr, ch16;
+
+    HAL_READ_UINT_UART(base+CYG_DEV_SERIAL_LSR, lsr);
+    if ((lsr & SIO_LSR_DR) == 0)
+        return false;
+
+    HAL_READ_UINT_UART(base+CYG_DEV_SERIAL_RHR, ch16);
+
+    *ch = (cyg_uint8) (ch16 & 0x00FF);
+
+    return true;
+}
+
+cyg_uint8 cyg_hal_plf_duart_getc(void* __ch_data)
+{
+    cyg_uint8 ch;
+
+    CYGARC_HAL_SAVE_GP();
+
+    while (!cyg_hal_plf_duart_getc_nonblock(__ch_data, &ch));
+
+    CYGARC_HAL_RESTORE_GP();
+    return ch;
+}
+
+static void cyg_hal_plf_duart_write(void* __ch_data, const cyg_uint8* __buf,
+                                    cyg_uint32 __len)
+{
+    CYGARC_HAL_SAVE_GP();
+
+    while (__len-- > 0)
+        cyg_hal_plf_duart_putc(__ch_data, *__buf++);
+
+    CYGARC_HAL_RESTORE_GP();
+}
+
+static void cyg_hal_plf_duart_read(void* __ch_data, cyg_uint8* __buf,
+                                   cyg_uint32 __len)
+{
+    CYGARC_HAL_SAVE_GP();
+
+    while (__len-- > 0)
+        *__buf++ = cyg_hal_plf_duart_getc(__ch_data);
+
+    CYGARC_HAL_RESTORE_GP();
+}
+
+cyg_bool cyg_hal_plf_duart_getc_timeout(void* __ch_data, cyg_uint8* ch)
+{
+    int delay_count;
+    channel_data_t* chan = (channel_data_t*)__ch_data;
+    cyg_bool res;
+
+    CYGARC_HAL_SAVE_GP();
+
+    delay_count = chan->msec_timeout * 10; // delay in .1 ms steps
+    for (;;) {
+        res = cyg_hal_plf_duart_getc_nonblock(__ch_data, ch);
+        if (res || 0 == delay_count--)
+            break;
+
+        CYGACC_CALL_IF_DELAY_US(100);
+    }
+
+    CYGARC_HAL_RESTORE_GP();
+    return res;
+}
+
+static int cyg_hal_plf_duart_control(void *__ch_data,
+                                     __comm_control_cmd_t __func, ...)
+{
+    static int irq_state = 0;
+    channel_data_t* chan = (channel_data_t*)__ch_data;
+    uart_width ier;
+    int ret = 0;
+
+    CYGARC_HAL_SAVE_GP();
+
+    switch (__func) {
+    case __COMMCTL_IRQ_ENABLE:
+        HAL_INTERRUPT_UNMASK(chan->isr_vector);
+        HAL_INTERRUPT_SET_LEVEL(chan->isr_vector, 1);
+        HAL_READ_UINT_UART(chan->base+CYG_DEV_SERIAL_IER, ier);
+        ier |= SIO_IER_ERDAI;
+        HAL_WRITE_UINT_UART(chan->base+CYG_DEV_SERIAL_IER, ier);
+        irq_state = 1;
+        break;
+    case __COMMCTL_IRQ_DISABLE:
+        ret = irq_state;
+        irq_state = 0;
+        HAL_INTERRUPT_MASK(chan->isr_vector);
+        HAL_READ_UINT_UART(chan->base+CYG_DEV_SERIAL_IER, ier);
+        ier &= ~SIO_IER_ERDAI;
+        HAL_WRITE_UINT_UART(chan->base+CYG_DEV_SERIAL_IER, ier);
+        break;
+    case __COMMCTL_DBG_ISR_VECTOR:
+        ret = chan->isr_vector;
+        break;
+    case __COMMCTL_SET_TIMEOUT:
+        {
+            va_list ap;
+
+            va_start(ap, __func);
+
+            ret = chan->msec_timeout;
+            chan->msec_timeout = va_arg(ap, cyg_uint32);
+
+            va_end(ap);
+        }
+        break;
+    default:
+        break;
+    }
+    CYGARC_HAL_RESTORE_GP();
+    return ret;
+}
+
+static int cyg_hal_plf_duart_isr(void *__ch_data, int* __ctrlc,
+                                 CYG_ADDRWORD __vector, CYG_ADDRWORD __data)
+{
+    channel_data_t* chan = (channel_data_t*)__ch_data;
+    uart_width _iir;
+    int res = 0;
+    CYGARC_HAL_SAVE_GP();
+
+    HAL_READ_UINT_UART(chan->base+CYG_DEV_SERIAL_IIR, _iir);
+    _iir &= SIO_IIR_ID_MASK;
+
+    *__ctrlc = 0;
+    if ( ISR_Rx == _iir ) {
+        uart_width c, lsr;
+        cyg_uint8 c8;
+        HAL_READ_UINT_UART(chan->base+CYG_DEV_SERIAL_LSR, lsr);
+        if (lsr & SIO_LSR_DR) {
+
+            HAL_READ_UINT_UART(chan->base+CYG_DEV_SERIAL_RHR, c);
+
+            c8 = (cyg_uint8) (c & 0x00FF);
+
+            if (cyg_hal_is_break( &c8 , 1 ))
+                *__ctrlc = 1;
+        }
+
+        // Acknowledge the interrupt
+        HAL_INTERRUPT_ACKNOWLEDGE(chan->isr_vector);
+        res = CYG_ISR_HANDLED;
+    }
+
+    CYGARC_HAL_RESTORE_GP();
+    return res;
+}
+
+static void cyg_hal_plf_duart_init(void)
+{
+    hal_virtual_comm_table_t* comm;
+    int cur = CYGACC_CALL_IF_SET_CONSOLE_COMM(CYGNUM_CALL_IF_SET_COMM_ID_QUERY_CURRENT);
+    int i;
+
+    // Init channels
+#define NUMOF(x) (sizeof(x)/sizeof(x[0]))
+    for (i = 0;  i < NUMOF(channels);  i++) {
+        HAL_INTERRUPT_MASK(channels[i].isr_vector);
+        init_duart_channel(&channels[i]);
+        CYGACC_CALL_IF_SET_CONSOLE_COMM(i);
+        comm = CYGACC_CALL_IF_CONSOLE_PROCS();
+        CYGACC_COMM_IF_CH_DATA_SET(*comm, &channels[i]);
+        CYGACC_COMM_IF_WRITE_SET(*comm, cyg_hal_plf_duart_write);
+        CYGACC_COMM_IF_READ_SET(*comm, cyg_hal_plf_duart_read);
+        CYGACC_COMM_IF_PUTC_SET(*comm, cyg_hal_plf_duart_putc);
+        CYGACC_COMM_IF_GETC_SET(*comm, cyg_hal_plf_duart_getc);
+        CYGACC_COMM_IF_CONTROL_SET(*comm, cyg_hal_plf_duart_control);
+        CYGACC_COMM_IF_DBG_ISR_SET(*comm, cyg_hal_plf_duart_isr);
+        CYGACC_COMM_IF_GETC_TIMEOUT_SET(*comm, cyg_hal_plf_duart_getc_timeout);
+    }
+
+    // Restore original console
+    CYGACC_CALL_IF_SET_CONSOLE_COMM(cur);
+}
+
+//=============================================================================
+// Compatibility with older stubs
+//=============================================================================
+
+//=============================================================================
+// Compatibility with older stubs
+//=============================================================================
+
+#ifndef CYGSEM_HAL_VIRTUAL_VECTOR_DIAG
+
+#include <cyg/hal/hal_stub.h>           // cyg_hal_gdb_interrupt
+
+#if (CYGNUM_HAL_VIRTUAL_VECTOR_CONSOLE_CHANNEL == 0)
+#define __BASE   CMA101_DUARTA
+#define _INT     CYGNUM_HAL_INTERRUPT_SERIAL_A
+#elif (CYGNUM_HAL_VIRTUAL_VECTOR_CONSOLE_CHANNEL == 1)
+#define __BASE   CMA101_DUARTB
+#define _INT     CYGNUM_HAL_INTERRUPT_SERIAL_B
+#endif
+
+#ifdef __BASE
+
+#ifdef CYGSEM_HAL_ROM_MONITOR
+#define CYG_HAL_STARTUP_ROM
+#define CYG_HAL_STARTUP_ROMRAM
+#undef CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS
+#endif
+
+#if (defined(CYG_HAL_STARTUP_ROM) || defined(CYG_HAL_STARTUP_ROMRAM)) && !defined(CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS)
+#define HAL_DIAG_USES_HARDWARE
+#elif !defined(CYGDBG_HAL_DIAG_TO_DEBUG_CHAN)
+#define HAL_DIAG_USES_HARDWARE
+#elif CYGNUM_HAL_VIRTUAL_VECTOR_CONSOLE_CHANNEL != CYGNUM_HAL_VIRTUAL_VECTOR_DEBUG_CHANNEL
+#define HAL_DIAG_USES_HARDWARE
+#endif
+
+static channel_data_t channel = {
+    (uart_width*) _BASE, 0, 0
+};
+
+#ifdef HAL_DIAG_USES_HARDWARE
+
+void hal_diag_init(void)
+{
+    static int init = 0;
+    char *msg = "\n\rARM eCos\n\r";
+    uart_width lcr;
+
+    if (init++) return;
+
+    init_duart_channel(&channel);
+
+    while (*msg) hal_diag_write_char(*msg++);
+}
+
+#ifdef DEBUG_DIAG
+#if defined(CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS)
+#define DIAG_BUFSIZE 32
+#else
+#define DIAG_BUFSIZE 2048
+#endif
+static char diag_buffer[DIAG_BUFSIZE];
+static int diag_bp = 0;
+#endif
+
+void hal_diag_write_char(char c)
+{
+    uart_width lsr;
+
+    hal_diag_init();
+
+    cyg_hal_plf_duart_putc(&channel, c)
+
+#ifdef DEBUG_DIAG
+    diag_buffer[diag_bp++] = c;
+    if (diag_bp == DIAG_BUFSIZE) {
+        while (1) ;
+        diag_bp = 0;
+    }
+#endif
+}
+
+void hal_diag_read_char(char *c)
+{
+    *c = cyg_hal_plf_duart_getc(&channel);
+}
+
+#else // HAL_DIAG relies on GDB
+
+// Initialize diag port - assume GDB channel is already set up
+void hal_diag_init(void)
+{
+    if (0) init_duart_channel(&channel); // avoid warning
+}
+
+// Actually send character down the wire
+static void hal_diag_write_char_serial(char c)
+{
+    cyg_hal_plf_duart_putc(&channel, c);
+}
+
+static bool hal_diag_read_serial(char *c)
+{
+    long timeout = 1000000000;  // A long time...
+
+    while (!cyg_hal_plf_duart_getc_nonblock(&channel, c))
+        if (0 == --timeout) return false;
+
+    return true;
+}
+
+void hal_diag_read_char(char *c)
+{
+    while (!hal_diag_read_serial(c)) ;
+}
+
+void hal_diag_write_char(char c)
+{
+    static char line[100];
+    static int pos = 0;
+
+    // No need to send CRs
+    if (c == '\r') return;
+
+    line[pos++] = c;
+
+    if (c == '\n' || pos == sizeof(line)) {
+        CYG_INTERRUPT_STATE old;
+
+        // Disable interrupts. This prevents GDB trying to interrupt us
+        // while we are in the middle of sending a packet. The serial
+        // receive interrupt will be seen when we re-enable interrupts
+        // later.
+
+#ifdef CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS
+        CYG_HAL_GDB_ENTER_CRITICAL_IO_REGION(old);
+#else
+        HAL_DISABLE_INTERRUPTS(old);
+#endif
+
+        while (1) {
+            static char hex[] = "0123456789ABCDEF";
+            cyg_uint8 csum = 0;
+            int i;
+            char c1;
+
+            hal_diag_write_char_serial('$');
+            hal_diag_write_char_serial('O');
+            csum += 'O';
+            for (i = 0; i < pos; i++) {
+                char ch = line[i];
+                char h = hex[(ch>>4)&0xF];
+                char l = hex[ch&0xF];
+                hal_diag_write_char_serial(h);
+                hal_diag_write_char_serial(l);
+                csum += h;
+                csum += l;
+            }
+            hal_diag_write_char_serial('#');
+            hal_diag_write_char_serial(hex[(csum>>4)&0xF]);
+            hal_diag_write_char_serial(hex[csum&0xF]);
+
+            // Wait for the ACK character '+' from GDB here and handle
+            // receiving a ^C instead.  This is the reason for this clause
+            // being a loop.
+            if (!hal_diag_read_serial(&c1))
+                continue;   // No response - try sending packet again
+
+            if ( c1 == '+' )
+                break;          // a good acknowledge
+
+#ifdef CYGDBG_HAL_DEBUG_GDB_BREAK_SUPPORT
+            cyg_drv_interrupt_acknowledge(CYG_DEV_SERIAL_INT);
+            if ( c1 == 3 ) {
+                // Ctrl-C: breakpoint.
+                cyg_hal_gdb_interrupt (__builtin_return_address(0));
+                break;
+            }
+#endif
+            // otherwise, loop round again
+        }
+
+        pos = 0;
+
+        // And re-enable interrupts
+#ifdef CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS
+        CYG_HAL_GDB_LEAVE_CRITICAL_IO_REGION(old);
+#else
+        HAL_RESTORE_INTERRUPTS(old);
+#endif
+
+    }
+}
+#endif
+
+#endif // __BASE
+
+#endif // CYGSEM_HAL_VIRTUAL_VECTOR_DIAG
+
+/*---------------------------------------------------------------------------*/
diff -urN -x CVS -x doc -x lwip_tcpip -x calmrisc16 -x calmrisc32 ecos_20050912/packages/hal/arm/mx51/3stack/current/src/board_misc.c ecos_base/packages/hal/arm/mx51/3stack/current/src/board_misc.c
--- ecos_20050912/packages/hal/arm/mx51/3stack/current/src/board_misc.c	1969-12-31 18:00:00.000000000 -0600
+++ ecos_base/packages/hal/arm/mx51/3stack/current/src/board_misc.c	2008-04-01 12:14:10.000000000 -0500
@@ -0,0 +1,183 @@
+//==========================================================================
+//
+//      board_misc.c
+//
+//      HAL misc board support code for the board
+//
+//==========================================================================
+//####ECOSGPLCOPYRIGHTBEGIN####
+// -------------------------------------------
+// This file is part of eCos, the Embedded Configurable Operating System.
+// Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+//
+// eCos is free software; you can redistribute it and/or modify it under
+// the terms of the GNU General Public License as published by the Free
+// Software Foundation; either version 2 or (at your option) any later version.
+//
+// eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with eCos; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+//
+// As a special exception, if other files instantiate templates or use macros
+// or inline functions from this file, or you compile this file and link it
+// with other works to produce a work based on this file, this file does not
+// by itself cause the resulting work to be covered by the GNU General Public
+// License. However the source code for this file must still be made available
+// in accordance with section (3) of the GNU General Public License.
+//
+// This exception does not invalidate any other reasons why a work based on
+// this file might be covered by the GNU General Public License.
+//
+// Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+// at http://sources.redhat.com/ecos/ecos-license/
+// -------------------------------------------
+//####ECOSGPLCOPYRIGHTEND####
+//========================================================================*/
+
+#include <pkgconf/hal.h>
+#include <pkgconf/system.h>
+#include <redboot.h>
+#include CYGBLD_HAL_PLATFORM_H
+
+#include <cyg/infra/cyg_type.h>         // base types
+#include <cyg/infra/cyg_trac.h>         // tracing macros
+#include <cyg/infra/cyg_ass.h>          // assertion macros
+
+#include <cyg/hal/hal_io.h>             // IO macros
+#include <cyg/hal/hal_arch.h>           // Register state info
+#include <cyg/hal/hal_diag.h>
+#include <cyg/hal/hal_intr.h>           // Interrupt names
+#include <cyg/hal/hal_cache.h>
+#include <cyg/hal/hal_soc.h>         // Hardware definitions
+#include <cyg/hal/fsl_board.h>             // Platform specifics
+
+#include <cyg/infra/diag.h>             // diag_printf
+
+// All the MM table layout is here:
+#include <cyg/hal/hal_mm.h>
+
+externC void* memset(void *, int, size_t);
+
+void hal_mmu_init(void)
+{
+    unsigned long ttb_base = RAM_BANK0_BASE + 0x4000;
+    unsigned long i;
+
+    /*
+     * Set the TTB register
+     */
+    asm volatile ("mcr  p15,0,%0,c2,c0,0" : : "r"(ttb_base) /*:*/);
+
+    /*
+     * Set the Domain Access Control Register
+     */
+    i = ARM_ACCESS_DACR_DEFAULT;
+    asm volatile ("mcr  p15,0,%0,c3,c0,0" : : "r"(i) /*:*/);
+
+    /*
+     * First clear all TT entries - ie Set them to Faulting
+     */
+    memset((void *)ttb_base, 0, ARM_FIRST_LEVEL_PAGE_TABLE_SIZE);
+
+    /*              Actual   Virtual  Size   Attributes                                                    Function  */
+    /*              Base     Base     MB     cached?           buffered?        access permissions                 */
+    /*              xxx00000 xxx00000                                                                                */
+    X_ARM_MMU_SECTION(0x000, 0x200,   0x200, ARM_UNCACHEABLE, ARM_UNBUFFERABLE, ARM_ACCESS_PERM_RW_RW); /* ROM */
+    X_ARM_MMU_SECTION(0x100, 0x100,   0x001, ARM_UNCACHEABLE, ARM_UNBUFFERABLE, ARM_ACCESS_PERM_RW_RW); /* IRAM */
+    X_ARM_MMU_SECTION(0x400, 0x000,   0x080, ARM_CACHEABLE,   ARM_BUFFERABLE,   ARM_ACCESS_PERM_RW_RW); /* SDRAM */
+    X_ARM_MMU_SECTION(0x400, 0x400,   0x080, ARM_CACHEABLE,   ARM_BUFFERABLE,   ARM_ACCESS_PERM_RW_RW); /* SDRAM */
+    X_ARM_MMU_SECTION(0x7ff, 0x7ff,   0x001, ARM_UNCACHEABLE, ARM_UNBUFFERABLE, ARM_ACCESS_PERM_RW_RW); /* NAND Flash buffer */
+    X_ARM_MMU_SECTION(0x800, 0x800,   0x020, ARM_UNCACHEABLE, ARM_UNBUFFERABLE, ARM_ACCESS_PERM_RW_RW); /* IPUv3D */
+    X_ARM_MMU_SECTION(0xB00, 0xB00,   0x400, ARM_UNCACHEABLE, ARM_UNBUFFERABLE, ARM_ACCESS_PERM_RW_RW); /* periperals */
+}
+
+//
+// Platform specific initialization
+//
+
+void plf_hardware_init(void)
+{
+    unsigned int v;
+
+    v = 0x0040174A; // modified
+    writel(v, NFC_FLASH_CONFIG2_REG);
+
+    writel(0xFFFF0000, UNLOCK_BLK_ADD0_REG);
+    writel(0xFFFF0000, UNLOCK_BLK_ADD1_REG);
+    writel(0xFFFF0000, UNLOCK_BLK_ADD2_REG);
+    writel(0xFFFF0000, UNLOCK_BLK_ADD3_REG);
+    
+    v = NFC_WR_PROT_CS0 | NFC_WR_PROT_BLS_UNLOCK | NFC_WR_PROT_WPC;
+    writel(v, NFC_WR_PROT_REG);
+
+    writel(0, NFC_IPC_REG);
+
+#if 0
+    /* PBC setup */
+    //Enable UART transceivers also reset the Ethernet/external UART
+    temp = readw(PBC_BASE + PBC_BCTRL1);
+
+    writew(0x8023, PBC_BASE + PBC_BCTRL1);
+
+    for (i = 0; i < 100000; i++) {
+    }
+
+    // clear the reset, toggle the LEDs
+    writew(0xDF, PBC_BASE + PBC_BCTRL1_CLR);
+
+    for (i = 0; i < 100000; i++) {
+    }
+
+    dummy = readb(0xB4000008);
+    dummy = readb(0xB4000007);
+    dummy = readb(0xB4000008);
+    dummy = readb(0xB4000007);
+#endif
+
+#if 0
+    /* Reset interrupt status reg */
+    writew(0x1F, PBC_INT_REST);
+    writew(0x00, PBC_INT_REST);
+    writew(0xFFFF, PBC_INT_MASK);
+#endif
+    // UART1
+    //RXD
+    writel(0x0, IOMUXC_BASE_ADDR + 0x15C);
+    writel(0x4, IOMUXC_BASE_ADDR + 0x604);
+    writel(0x1C5, IOMUXC_BASE_ADDR + 0x3BC);
+
+    //TXD
+    writel(0x0, IOMUXC_BASE_ADDR + 0x160);
+    writel(0x1C5, IOMUXC_BASE_ADDR + 0x3C0);
+
+    //RTS
+    writel(0x0, IOMUXC_BASE_ADDR + 0x164);
+    writel(0x4, IOMUXC_BASE_ADDR + 0x600);
+    writel(0x1C4, IOMUXC_BASE_ADDR + 0x3C4);
+
+    //CTS
+    writel(0x0, IOMUXC_BASE_ADDR + 0x168);
+    writel(0x1C4, IOMUXC_BASE_ADDR + 0x3C8);
+}
+
+#include CYGHWR_MEMORY_LAYOUT_H
+
+typedef void code_fun(void);
+
+void board_program_new_stack(void *func)
+{
+    register CYG_ADDRESS stack_ptr asm("sp");
+    register CYG_ADDRESS old_stack asm("r4");
+    register code_fun *new_func asm("r0");
+    old_stack = stack_ptr;
+    stack_ptr = CYGMEM_REGION_ram + CYGMEM_REGION_ram_SIZE - sizeof(CYG_ADDRESS);
+    new_func = (code_fun*)func;
+    new_func();
+    stack_ptr = old_stack;
+}
+
diff -urN -x CVS -x doc -x lwip_tcpip -x calmrisc16 -x calmrisc32 ecos_20050912/packages/hal/arm/mx51/3stack/current/src/redboot_cmds.c ecos_base/packages/hal/arm/mx51/3stack/current/src/redboot_cmds.c
--- ecos_20050912/packages/hal/arm/mx51/3stack/current/src/redboot_cmds.c	1969-12-31 18:00:00.000000000 -0600
+++ ecos_base/packages/hal/arm/mx51/3stack/current/src/redboot_cmds.c	2008-04-01 12:14:10.000000000 -0500
@@ -0,0 +1,187 @@
+//==========================================================================
+//
+//      redboot_cmds.c
+//
+//      Board [platform] specific RedBoot commands
+//
+//==========================================================================
+//####ECOSGPLCOPYRIGHTBEGIN####
+// -------------------------------------------
+// This file is part of eCos, the Embedded Configurable Operating System.
+// Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+//
+// eCos is free software; you can redistribute it and/or modify it under
+// the terms of the GNU General Public License as published by the Free
+// Software Foundation; either version 2 or (at your option) any later version.
+//
+// eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with eCos; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+//
+// As a special exception, if other files instantiate templates or use macros
+// or inline functions from this file, or you compile this file and link it
+// with other works to produce a work based on this file, this file does not
+// by itself cause the resulting work to be covered by the GNU General Public
+// License. However the source code for this file must still be made available
+// in accordance with section (3) of the GNU General Public License.
+//
+// This exception does not invalidate any other reasons why a work based on
+// this file might be covered by the GNU General Public License.
+//
+// Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+// at http://sources.redhat.com/ecos/ecos-license/
+// -------------------------------------------
+//####ECOSGPLCOPYRIGHTEND####
+//==========================================================================
+#include <redboot.h>
+#include <cyg/hal/hal_intr.h>
+#include <cyg/hal/hal_cache.h>
+#include <cyg/hal/plf_mmap.h>
+#include <cyg/hal/fsl_board.h>          // Platform specific hardware definitions
+
+#ifdef CYGSEM_REDBOOT_FLASH_CONFIG
+#include <flash_config.h>
+
+#if (REDBOOT_IMAGE_SIZE != CYGBLD_REDBOOT_MIN_IMAGE_SIZE)
+#error REDBOOT_IMAGE_SIZE != CYGBLD_REDBOOT_MIN_IMAGE_SIZE
+#endif
+
+RedBoot_config_option("Board specifics",
+                      brd_specs,
+                      ALWAYS_ENABLED,
+                      true,
+                      CONFIG_INT,
+                      0
+                     );
+#endif  //CYGSEM_REDBOOT_FLASH_CONFIG
+
+char HAL_PLATFORM_EXTRA[20] = "PASS x.x [x32 DDR]";
+
+static void runImg(int argc, char *argv[]);
+
+RedBoot_cmd("run",
+            "Run an image at a location with MMU off",
+            "[<virtual addr>]",
+            runImg
+           );
+
+void launchRunImg(unsigned long addr)
+{
+    asm volatile ("mov r12, r0;");
+    HAL_CLEAN_INVALIDATE_L2();
+    HAL_DISABLE_L2();
+    HAL_MMU_OFF();
+    asm volatile (
+                 "mov r0, #0;"
+                 "mov r1, r12;"
+                 "mov r11, #0;"
+                 "mov r12, #0;"
+                 "mrs r10, cpsr;"
+                 "bic r10, r10, #0xF0000000;"
+                 "msr cpsr_f, r10;"
+                 "mov pc, r1"
+                 );
+}
+
+extern unsigned long entry_address;
+
+static void runImg(int argc,char *argv[])
+{
+    unsigned int virt_addr, phys_addr;
+
+    // Default physical entry point for Symbian
+    if (entry_address == 0xFFFFFFFF)
+        virt_addr = 0x800000;
+    else
+    virt_addr = entry_address;
+
+    if (!scan_opts(argc,argv,1,0,0,(void*)&virt_addr,
+                   OPTION_ARG_TYPE_NUM, "virtual address"))
+        return;
+
+    if (entry_address != 0xFFFFFFFF)
+        diag_printf("load entry_address=0x%lx\n", entry_address);
+    HAL_VIRT_TO_PHYS_ADDRESS(virt_addr, phys_addr);
+
+    diag_printf("virt_addr=0x%x\n",virt_addr);
+    diag_printf("phys_addr=0x%x\n",phys_addr);
+
+    launchRunImg(phys_addr);
+}
+
+#if defined(CYGSEM_REDBOOT_FLASH_CONFIG) && defined(CYG_HAL_STARTUP_ROMRAM)
+
+RedBoot_cmd("romupdate",
+            "Update Redboot with currently running image",
+            "",
+            romupdate
+           );
+
+extern int flash_program(void *_addr, void *_data, int len, void **err_addr);
+extern int flash_erase(void *addr, int len, void **err_addr);
+extern char *flash_errmsg(int err);
+extern unsigned char *ram_end; //ram end is where the redboot starts FIXME: use PC value
+
+#ifdef CYGPKG_IO_FLASH
+void romupdate(int argc, char *argv[])
+{
+    void *err_addr, *base_addr;
+    int stat;
+
+    base_addr = (void*)0;
+    diag_printf("Updating ROM in NAND flash\n");
+
+    // Erase area to be programmed
+    if ((stat = flash_erase((void *)base_addr,
+                            CYGBLD_REDBOOT_MIN_IMAGE_SIZE,
+                            (void **)&err_addr)) != 0) {
+        diag_printf("Can't erase region at %p: %s\n",
+                    err_addr, flash_errmsg(stat));
+        return;
+    }
+    // Now program it
+    if ((stat = flash_program((void *)base_addr, (void *)ram_end,
+                              CYGBLD_REDBOOT_MIN_IMAGE_SIZE,
+                              (void **)&err_addr)) != 0) {
+        diag_printf("Can't program region at %p: %s\n",
+                    err_addr, flash_errmsg(stat));
+    }
+}
+RedBoot_cmd("factive",
+            "Enable one flash media for Redboot",
+            "[NOR | NAND]",
+            factive
+           );
+
+void factive(int argc, char *argv[])
+{
+    unsigned long phys_addr;
+
+    if (argc != 2) {
+        diag_printf("Invalid factive cmd\n");
+        return;
+    }
+
+    if (strcasecmp(argv[1], "NOR") == 0) {
+        diag_printf("Not supported\n");
+        return;
+    } else if (strcasecmp(argv[1], "NAND") == 0) {
+#ifndef MXCFLASH_SELECT_NAND
+        diag_printf("Not supported\n");
+        return;
+#endif
+    } else {
+        diag_printf("Invalid command: %s\n", argv[1]);
+        return;
+    }
+    HAL_VIRT_TO_PHYS_ADDRESS(ram_end, phys_addr);
+
+    launchRunImg(phys_addr);
+}
+#endif //CYGPKG_IO_FLASH
+#endif /* CYG_HAL_STARTUP_ROMRAM */
diff -urN -x CVS -x doc -x lwip_tcpip -x calmrisc16 -x calmrisc32 ecos_20050912/packages/hal/arm/mx51/var/current/cdl/hal_arm_soc.cdl ecos_base/packages/hal/arm/mx51/var/current/cdl/hal_arm_soc.cdl
--- ecos_20050912/packages/hal/arm/mx51/var/current/cdl/hal_arm_soc.cdl	1969-12-31 18:00:00.000000000 -0600
+++ ecos_base/packages/hal/arm/mx51/var/current/cdl/hal_arm_soc.cdl	2008-03-31 18:32:55.000000000 -0500
@@ -0,0 +1,162 @@
+# ====================================================================
+#####ECOSGPLCOPYRIGHTBEGIN####
+## -------------------------------------------
+## This file is part of eCos, the Embedded Configurable Operating System.
+## Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+##
+## eCos is free software; you can redistribute it and/or modify it under
+## the terms of the GNU General Public License as published by the Free
+## Software Foundation; either version 2 or (at your option) any later version.
+##
+## eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+## WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+## for more details.
+##
+## You should have received a copy of the GNU General Public License along
+## with eCos; if not, write to the Free Software Foundation, Inc.,
+## 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+##
+## As a special exception, if other files instantiate templates or use macros
+## or inline functions from this file, or you compile this file and link it
+## with other works to produce a work based on this file, this file does not
+## by itself cause the resulting work to be covered by the GNU General Public
+## License. However the source code for this file must still be made available
+## in accordance with section (3) of the GNU General Public License.
+##
+## This exception does not invalidate any other reasons why a work based on
+## this file might be covered by the GNU General Public License.
+##
+## Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+## at http://sources.redhat.com/ecos/ecos-license/
+## -------------------------------------------
+#####ECOSGPLCOPYRIGHTEND####
+# ====================================================================
+######DESCRIPTIONBEGIN####
+#
+# Author(s):      gthomas
+# Original data:  gthomas
+# Contributors:
+# Date:           2000-05-08
+#
+#####DESCRIPTIONEND####
+#
+# ====================================================================
+cdl_package CYGPKG_HAL_ARM_MX51 {
+    display       "Freescale SoC architecture"
+    parent        CYGPKG_HAL_ARM
+    hardware
+    include_dir   cyg/hal
+    define_header hal_arm_soc.h
+    description   "
+        This HAL variant package provides generic
+        support for the Freescale SoC. It is also
+        necessary to select a specific target platform HAL
+        package."
+
+    implements    CYGINT_HAL_ARM_ARCH_ARM9
+    implements    CYGINT_HAL_VIRTUAL_VECTOR_COMM_BAUD_SUPPORT
+
+    # Let the architectural HAL see this variant's interrupts file -
+    # the SoC has no variation between targets here.
+    define_proc {
+        puts $::cdl_header "#define CYGBLD_HAL_VAR_INTS_H <cyg/hal/hal_var_ints.h>"
+        puts $::cdl_system_header "#define CYGBLD_HAL_ARM_VAR_IO_H"
+
+        puts $::cdl_header "#define CYGPRI_KERNEL_TESTS_DHRYSTONE_PASSES 1000000"
+    }
+
+    compile       soc_diag.c soc_misc.c
+    compile -library=libextras.a cmds.c
+
+    cdl_option CYGHWR_HAL_ARM_SOC_PROCESSOR_CLOCK {
+        display       "Processor clock rate"
+        active_if     { CYG_HAL_STARTUP == "ROM" }
+        flavor        data
+        legal_values  150000 200000
+        default_value { CYGHWR_HAL_ARM_SOC_PROCESSOR_CLOCK_OVERRIDE_DEFAULT ?
+                        CYGHWR_HAL_ARM_SOC_PROCESSOR_CLOCK_OVERRIDE_DEFAULT : 150000}
+        description   "
+           The processor can run at various frequencies.
+           These values are expressed in KHz.  Note that there are
+           several steppings of the rated to run at different
+           maximum frequencies.  Check the specs to make sure that your
+           particular processor can run at the rate you select here."
+    }
+
+    # Real-time clock/counter specifics
+    cdl_component CYGNUM_HAL_RTC_CONSTANTS {
+        display       "Real-time clock constants"
+        flavor        none
+        no_define
+
+        cdl_option CYGNUM_HAL_RTC_NUMERATOR {
+            display       "Real-time clock numerator"
+            flavor        data
+            calculated    1000000000
+        }
+        cdl_option CYGNUM_HAL_RTC_DENOMINATOR {
+            display       "Real-time clock denominator"
+            flavor        data
+            default_value 100
+            description   "
+              This option selects the heartbeat rate for the real-time clock.
+              The rate is specified in ticks per second.  Change this value
+              with caution - too high and your system will become saturated
+              just handling clock interrupts, too low and some operations
+              such as thread scheduling may become sluggish."
+        }
+        cdl_option CYGNUM_HAL_RTC_PERIOD {
+            display       "Real-time clock period"
+            flavor        data
+            calculated    (3686400/CYGNUM_HAL_RTC_DENOMINATOR)        ;# Clock for OS Timer is 3.6864MHz
+        }
+    }
+
+    # Control over hardware layout.
+    cdl_interface     CYGHWR_HAL_ARM_SOC_UART1 {
+        display   "UART1 available as diagnostic/debug channel"
+        description "
+	  The chip has multiple serial channels which may be
+          used for different things on different platforms.  This
+          interface allows a platform to indicate that the specified
+          serial port can be used as a diagnostic and/or debug channel."
+    }
+
+    cdl_interface     CYGHWR_HAL_ARM_SOC_UART2 {
+        display   "UART2 available as diagnostic/debug channel"
+        description "
+	  The chip has multiple serial channels which may be
+          used for different things on different platforms.  This
+          interface allows a platform to indicate that the specified
+          serial port can be used as a diagnostic and/or debug channel."
+    }
+
+    cdl_interface     CYGHWR_HAL_ARM_SOC_UART3 {
+        display   "UART3 available as diagnostic/debug channel"
+        description "
+	  The chip has multiple serial channels which may be
+          used for different things on different platforms.  This
+          interface allows a platform to indicate that the specified
+          serial port can be used as a diagnostic and/or debug channel."
+    }
+
+    cdl_interface     CYGHWR_HAL_ARM_SOC_UART4 {
+        display   "UART4 available as diagnostic/debug channel"
+        description "
+	  The chip has multiple serial channels which may be
+          used for different things on different platforms.  This
+          interface allows a platform to indicate that the specified
+          serial port can be used as a diagnostic and/or debug channel."
+    }
+
+    cdl_interface     CYGHWR_HAL_ARM_SOC_UART5 {
+        display   "UART5 available as diagnostic/debug channel"
+        description "
+	  The chip has multiple serial channels which may be
+          used for different things on different platforms.  This
+          interface allows a platform to indicate that the specified
+          serial port can be used as a diagnostic and/or debug channel."
+    }
+
+}
diff -urN -x CVS -x doc -x lwip_tcpip -x calmrisc16 -x calmrisc32 ecos_20050912/packages/hal/arm/mx51/var/current/include/hal_cache.h ecos_base/packages/hal/arm/mx51/var/current/include/hal_cache.h
--- ecos_20050912/packages/hal/arm/mx51/var/current/include/hal_cache.h	1969-12-31 18:00:00.000000000 -0600
+++ ecos_base/packages/hal/arm/mx51/var/current/include/hal_cache.h	2008-03-31 18:32:55.000000000 -0500
@@ -0,0 +1,322 @@
+#ifndef CYGONCE_HAL_CACHE_H
+#define CYGONCE_HAL_CACHE_H
+
+//=============================================================================
+//
+//      hal_cache.h
+//
+//      HAL cache control API
+//
+//=============================================================================
+//####ECOSGPLCOPYRIGHTBEGIN####
+// -------------------------------------------
+// This file is part of eCos, the Embedded Configurable Operating System.
+// Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+//
+// eCos is free software; you can redistribute it and/or modify it under
+// the terms of the GNU General Public License as published by the Free
+// Software Foundation; either version 2 or (at your option) any later version.
+//
+// eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with eCos; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+//
+// As a special exception, if other files instantiate templates or use macros
+// or inline functions from this file, or you compile this file and link it
+// with other works to produce a work based on this file, this file does not
+// by itself cause the resulting work to be covered by the GNU General Public
+// License. However the source code for this file must still be made available
+// in accordance with section (3) of the GNU General Public License.
+//
+// This exception does not invalidate any other reasons why a work based on
+// this file might be covered by the GNU General Public License.
+//
+// Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+// at http://sources.redhat.com/ecos/ecos-license/
+// -------------------------------------------
+//####ECOSGPLCOPYRIGHTEND####
+//=============================================================================
+
+#include <cyg/infra/cyg_type.h>
+#include <cyg/hal/hal_soc.h>         // Variant specific hardware definitions
+
+//-----------------------------------------------------------------------------
+// Cache dimensions
+
+// Data cache
+#define HAL_DCACHE_SIZE                 0x4000    // 16KB Size of data cache in bytes
+#define HAL_DCACHE_LINE_SIZE            32    // Size of a data cache line
+#define HAL_DCACHE_WAYS                 64    // Associativity of the cache
+
+// Instruction cache
+#define HAL_ICACHE_SIZE                 0x4000    // Size of cache in bytes
+#define HAL_ICACHE_LINE_SIZE            32    // Size of a cache line
+#define HAL_ICACHE_WAYS                 64    // Associativity of the cache
+
+#define HAL_DCACHE_SETS (HAL_DCACHE_SIZE / (HAL_DCACHE_LINE_SIZE*HAL_DCACHE_WAYS))
+#define HAL_ICACHE_SETS (HAL_ICACHE_SIZE / (HAL_ICACHE_LINE_SIZE*HAL_ICACHE_WAYS))
+
+#define CYGHWR_HAL_ARM_ARM9_CLEAN_DCACHE_INDEX
+#define CYGHWR_HAL_ARM_ARM9_CLEAN_DCACHE_INDEX_STEP  0x20
+#define CYGHWR_HAL_ARM_ARM9_CLEAN_DCACHE_INDEX_LIMIT 0x100
+//-----------------------------------------------------------------------------
+// Global control of data cache
+
+// Enable the data cache
+#define HAL_DCACHE_ENABLE_L1()                                          \
+CYG_MACRO_START                                                         \
+    asm volatile (                                                      \
+        "mrc p15, 0, r1, c1, c0, 0;"                                    \
+        "orr r1, r1, #0x0007;" /* enable DCache (also ensures */        \
+                               /* the MMU, alignment faults, and */       \
+        "mcr p15, 0, r1, c1, c0, 0"                                     \
+        :                                                               \
+        :                                                               \
+        : "r1" /* Clobber list */                                       \
+        );                                                              \
+CYG_MACRO_END
+
+// Disable the data cache
+#define HAL_DCACHE_DISABLE_L1()                                         \
+CYG_MACRO_START                                                         \
+    asm volatile (                                                      \
+        "mov r1, #0;"                                                   \
+        "mcr p15, 0, r1, c7, c6, 0;" /* clear data cache */             \
+        "mrc p15, 0, r1, c1, c0, 0;"                                    \
+        "bic r1, r1, #0x0004;" /* disable DCache  */                    \
+                             /* but not MMU and alignment faults */     \
+        "mcr p15, 0, r1, c1, c0, 0"                                     \
+        :                                                               \
+        :                                                               \
+        : "r1" /* Clobber list */                                       \
+    );                                                                  \
+CYG_MACRO_END
+
+// Invalidate the entire cache
+#define HAL_DCACHE_INVALIDATE_ALL_L1()                                  \
+CYG_MACRO_START  /* this macro can discard dirty cache lines. */        \
+    asm volatile (                                                      \
+        "mov r0, #0;"                                                   \
+        "mcr p15, 0, r0, c7, c6, 0;" /* flush d-cache */                \
+        "mcr p15, 0, r0, c8, c7, 0;" /* flush i+d-TLBs */               \
+        :                                                               \
+        :                                                               \
+        : "r0","memory" /* clobber list */                              \
+    );                                                                  \
+CYG_MACRO_END
+
+// Synchronize the contents of the cache with memory.
+// using ARM9's defined(CYGHWR_HAL_ARM_ARM9_CLEAN_DCACHE_INDEX)
+#define HAL_DCACHE_SYNC_L1()                                           \
+CYG_MACRO_START                                                        \
+    asm volatile (                                                     \
+        "nop; "                                                        \
+        "nop; "                                                        \
+        "nop; "                                                        \
+        "nop; "                                                        \
+        "nop; "                                                        \
+        "nop; "                                                        \
+        "mov r0, #0x0;"                                                \
+        "mcr p15, 0, r0, c7, c14, 0;" /* clean, invalidate Dcache*/    \
+        "mcr p15, 0, r0, c7, c10, 4;" /* drain the write buffer */     \
+        "mcr p15, 0, r0, c7, c10, 5;" /* data memory barrier */        \
+        :                                                              \
+        :                                                              \
+        : "r0" /* Clobber list */                                      \
+        );                                                             \
+CYG_MACRO_END
+
+// Query the state of the data cache
+#define HAL_DCACHE_IS_ENABLED(_state_)                                  \
+CYG_MACRO_START                                                         \
+    register int reg;                                                   \
+    asm volatile (                                                      \
+        "nop; "                                                         \
+        "nop; "                                                         \
+        "nop; "                                                         \
+        "nop; "                                                         \
+        "nop; "                                                         \
+        "mrc p15, 0, %0, c1, c0, 0;"                                    \
+                  : "=r"(reg)                                           \
+                  :                                                     \
+        );                                                              \
+    (_state_) = (0 != (4 & reg)); /* Bit 2 is DCache enable */          \
+CYG_MACRO_END
+
+//-----------------------------------------------------------------------------
+// Global control of Instruction cache
+
+// Enable the instruction cache
+#define HAL_ICACHE_ENABLE_L1()                                          \
+CYG_MACRO_START                                                         \
+    asm volatile (                                                      \
+        "mrc p15, 0, r1, c1, c0, 0;"                                    \
+        "orr r1, r1, #0x1000;"                                          \
+        "orr r1, r1, #0x0003;"  /* enable ICache (also ensures   */     \
+                                /* that MMU and alignment faults */     \
+                                /* are enabled)                  */     \
+        "mcr p15, 0, r1, c1, c0, 0"                                     \
+        :                                                               \
+        :                                                               \
+        : "r1" /* Clobber list */                                       \
+        );                                                              \
+CYG_MACRO_END
+
+// Query the state of the instruction cache
+#define HAL_ICACHE_IS_ENABLED(_state_)                                  \
+CYG_MACRO_START                                                         \
+    register cyg_uint32 reg;                                            \
+    asm volatile (                                                      \
+        "mrc p15, 0, %0, c1, c0, 0"                                     \
+        : "=r"(reg)                                                     \
+        :                                                               \
+        );                                                              \
+                                                                        \
+    (_state_) = (0 != (0x1000 & reg)); /* Bit 12 is ICache enable */    \
+CYG_MACRO_END
+
+// Disable the instruction cache
+#define HAL_ICACHE_DISABLE_L1()                                         \
+CYG_MACRO_START                                                         \
+    asm volatile (                                                      \
+        "mrc p15, 0, r1, c1, c0, 0;"                                    \
+        "bic r1, r1, #0x1000;" /* disable ICache (but not MMU, etc) */  \
+        "mcr p15, 0, r1, c1, c0, 0;"                                    \
+        "mov r1, #0;"                                                   \
+        "mcr p15, 0, r1, c7, c5, 0;"  /* flush ICache */                \
+        "mcr p15, 0, r1, c7, c5, 4;"  /* flush prefetch buffer */       \
+        "nop;" /* next few instructions may be via cache    */          \
+        "nop;"                                                          \
+        "nop;"                                                          \
+        "nop;"                                                          \
+        "nop;"                                                          \
+        "nop"                                                           \
+        :                                                               \
+        :                                                               \
+        : "r1" /* Clobber list */                                       \
+        );                                                              \
+CYG_MACRO_END
+
+// Invalidate the entire cache
+#define HAL_ICACHE_INVALIDATE_ALL_L1()                                  \
+CYG_MACRO_START                                                         \
+    /* this macro can discard dirty cache lines (N/A for ICache) */     \
+    asm volatile (                                                      \
+        "mov r1, #0;"                                                   \
+        "mcr p15, 0, r1, c7, c5, 0;"  /* flush ICache */                \
+        "mcr p15, 0, r1, c8, c5, 0;"  /* flush ITLB only */             \
+        "mcr p15, 0, r1, c7, c5, 4;"  /* flush prefetch buffer */       \
+        "nop;" /* next few instructions may be via cache    */          \
+        "nop;"                                                          \
+        "nop;"                                                          \
+        "nop;"                                                          \
+        "nop;"                                                          \
+        "nop;"                                                          \
+        :                                                               \
+        :                                                               \
+        : "r1" /* Clobber list */                                       \
+        );                                                              \
+CYG_MACRO_END
+
+// Synchronize the contents of the cache with memory.
+// (which includes flushing out pending writes)
+#define HAL_ICACHE_SYNC()                                       \
+CYG_MACRO_START                                                 \
+    HAL_DCACHE_SYNC(); /* ensure data gets to RAM */            \
+    HAL_ICACHE_INVALIDATE_ALL(); /* forget all we know */       \
+CYG_MACRO_END
+
+// Query the state of the L2 cache
+#define HAL_L2CACHE_IS_ENABLED(_state_)                         \
+    (_state_ = readl(L2CC_BASE_ADDR + L2_CACHE_CTL_REG) & 1)
+
+#ifdef L2CC_ENABLED
+
+#define HAL_ENABLE_L2()                             \
+{                                                   \
+    writel(1, L2CC_BASE_ADDR + L2_CACHE_CTL_REG);   \
+}
+
+#define HAL_DISABLE_L2()                            \
+{                                                   \
+    writel(0, L2CC_BASE_ADDR + L2_CACHE_CTL_REG);   \
+}
+
+#define HAL_SYNC_L2()                                                           \
+{                                                                               \
+    if ((readl(L2CC_BASE_ADDR + L2_CACHE_CTL_REG) & 1) != 0) {                  \
+        writel(0, L2CC_BASE_ADDR + L2_CACHE_SYNC_REG);                          \
+        while ((readl(L2CC_BASE_ADDR + L2_CACHE_SYNC_REG) & 1) == 1);           \
+    }                                                                           \
+}
+
+#define HAL_INVALIDATE_L2()                                                     \
+{                                                                               \
+    if ((readl(L2CC_BASE_ADDR + L2_CACHE_CTL_REG) & 1) != 0) {                  \
+        writel(0xFF, L2CC_BASE_ADDR + L2_CACHE_INV_WAY_REG);                    \
+        while ((readl(L2CC_BASE_ADDR + L2_CACHE_INV_WAY_REG) & 0xFF) != 0);    \
+        HAL_SYNC_L2();                                                          \
+    }                                                                           \
+}
+                                                                                \
+#define HAL_CLEAN_INVALIDATE_L2()                                               \
+{                                                                               \
+    if ((readl(L2CC_BASE_ADDR + L2_CACHE_CTL_REG) & 1) != 0) {                  \
+        writel(0xFF, L2CC_BASE_ADDR + L2_CACHE_CLEAN_INV_WAY_REG);              \
+        while ((readl(L2CC_BASE_ADDR + L2_CACHE_CLEAN_INV_WAY_REG) & 0xFF) != 0);\
+        HAL_SYNC_L2();                                                          \
+    }                                                                           \
+}
+
+#else //L2CC_ENABLED
+
+#define HAL_ENABLE_L2()
+#define HAL_DISABLE_L2()
+#define HAL_INVALIDATE_L2()
+#define HAL_CLEAN_INVALIDATE_L2()
+#define HAL_SYNC_L2()
+#endif //L2CC_ENABLED
+
+/*********************** Exported macros *******************/
+
+#define HAL_DCACHE_ENABLE() {           \
+        HAL_DCACHE_ENABLE_L1();         \
+        HAL_ENABLE_L2();                \
+}
+
+#define HAL_DCACHE_DISABLE() {          \
+        HAL_DCACHE_DISABLE_L1();        \
+        HAL_DISABLE_L2();               \
+}
+
+#define HAL_DCACHE_INVALIDATE_ALL() {   \
+        HAL_DCACHE_INVALIDATE_ALL_L1(); \
+        HAL_CLEAN_INVALIDATE_L2();      \
+}
+
+#define HAL_DCACHE_SYNC() {             \
+        HAL_DCACHE_SYNC_L1();           \
+        /* don't just call HAL_SYNC_L2() */ \
+        HAL_CLEAN_INVALIDATE_L2();      \
+}
+
+#define HAL_ICACHE_INVALIDATE_ALL() {   \
+        HAL_ICACHE_INVALIDATE_ALL_L1(); \
+        HAL_CLEAN_INVALIDATE_L2();      \
+}
+
+#define HAL_ICACHE_DISABLE() {          \
+        HAL_ICACHE_DISABLE_L1();        \
+}                                       
+
+#define HAL_ICACHE_ENABLE() {           \
+        HAL_ICACHE_ENABLE_L1();         \
+}
+
+#endif // ifndef CYGONCE_HAL_CACHE_H
+// End of hal_cache.h
diff -urN -x CVS -x doc -x lwip_tcpip -x calmrisc16 -x calmrisc32 ecos_20050912/packages/hal/arm/mx51/var/current/include/hal_diag.h ecos_base/packages/hal/arm/mx51/var/current/include/hal_diag.h
--- ecos_20050912/packages/hal/arm/mx51/var/current/include/hal_diag.h	1969-12-31 18:00:00.000000000 -0600
+++ ecos_base/packages/hal/arm/mx51/var/current/include/hal_diag.h	2008-03-31 18:32:55.000000000 -0500
@@ -0,0 +1,83 @@
+#ifndef CYGONCE_HAL_DIAG_H
+#define CYGONCE_HAL_DIAG_H
+
+/*=============================================================================
+//
+//      hal_diag.h
+//
+//      HAL Support for Kernel Diagnostic Routines
+//
+//=============================================================================
+//####ECOSGPLCOPYRIGHTBEGIN####
+// -------------------------------------------
+// This file is part of eCos, the Embedded Configurable Operating System.
+// Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+//
+// eCos is free software; you can redistribute it and/or modify it under
+// the terms of the GNU General Public License as published by the Free
+// Software Foundation; either version 2 or (at your option) any later version.
+//
+// eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with eCos; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+//
+// As a special exception, if other files instantiate templates or use macros
+// or inline functions from this file, or you compile this file and link it
+// with other works to produce a work based on this file, this file does not
+// by itself cause the resulting work to be covered by the GNU General Public
+// License. However the source code for this file must still be made available
+// in accordance with section (3) of the GNU General Public License.
+//
+// This exception does not invalidate any other reasons why a work based on
+// this file might be covered by the GNU General Public License.
+//
+// Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+// at http://sources.redhat.com/ecos/ecos-license/
+// -------------------------------------------
+//####ECOSGPLCOPYRIGHTEND####
+//===========================================================================*/
+
+#include <pkgconf/hal.h>
+
+#include <cyg/infra/cyg_type.h>
+
+#if defined(CYGSEM_HAL_VIRTUAL_VECTOR_DIAG)
+
+#include <cyg/hal/hal_if.h>
+
+#define HAL_DIAG_INIT() hal_if_diag_init()
+#define HAL_DIAG_WRITE_CHAR(_c_) hal_if_diag_write_char(_c_)
+#define HAL_DIAG_READ_CHAR(_c_) hal_if_diag_read_char(&_c_)
+
+#else // everything by steam
+
+/*---------------------------------------------------------------------------*/
+/* functions implemented in hal_diag.c                                       */
+
+externC void hal_diag_init(void);
+externC void hal_diag_write_char(char c);
+externC void hal_diag_read_char(char *c);
+
+/*---------------------------------------------------------------------------*/
+
+#define HAL_DIAG_INIT() hal_diag_init()
+
+#define HAL_DIAG_WRITE_CHAR(_c_) hal_diag_write_char(_c_)
+
+#define HAL_DIAG_READ_CHAR(_c_) hal_diag_read_char(&_c_)
+
+#endif // CYGSEM_HAL_VIRTUAL_VECTOR_DIAG
+
+/*---------------------------------------------------------------------------*/
+// LED
+
+externC void hal_diag_led(int n);
+
+/*---------------------------------------------------------------------------*/
+/* end of hal_diag.h                                                         */
+#endif /* CYGONCE_HAL_DIAG_H */
diff -urN -x CVS -x doc -x lwip_tcpip -x calmrisc16 -x calmrisc32 ecos_20050912/packages/hal/arm/mx51/var/current/include/hal_mm.h ecos_base/packages/hal/arm/mx51/var/current/include/hal_mm.h
--- ecos_20050912/packages/hal/arm/mx51/var/current/include/hal_mm.h	1969-12-31 18:00:00.000000000 -0600
+++ ecos_base/packages/hal/arm/mx51/var/current/include/hal_mm.h	2008-03-31 18:32:55.000000000 -0500
@@ -0,0 +1,176 @@
+#ifndef CYGONCE_HAL_MM_H
+#define CYGONCE_HAL_MM_H
+
+//=============================================================================
+//
+//      hal_mm.h
+//
+//=============================================================================
+//####ECOSGPLCOPYRIGHTBEGIN####
+// -------------------------------------------
+// This file is part of eCos, the Embedded Configurable Operating System.
+// Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+//
+// eCos is free software; you can redistribute it and/or modify it under
+// the terms of the GNU General Public License as published by the Free
+// Software Foundation; either version 2 or (at your option) any later version.
+//
+// eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with eCos; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+//
+// As a special exception, if other files instantiate templates or use macros
+// or inline functions from this file, or you compile this file and link it
+// with other works to produce a work based on this file, this file does not
+// by itself cause the resulting work to be covered by the GNU General Public
+// License. However the source code for this file must still be made available
+// in accordance with section (3) of the GNU General Public License.
+//
+// This exception does not invalidate any other reasons why a work based on
+// this file might be covered by the GNU General Public License.
+//
+// Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+// at http://sources.redhat.com/ecos/ecos-license/
+// -------------------------------------------
+//####ECOSGPLCOPYRIGHTEND####
+//=============================================================================
+// -------------------------------------------------------------------------
+// MMU initialization:
+//
+// These structures are laid down in memory to define the translation
+// table.
+//
+
+/*
+ * Translation Table Base Bit Masks
+ */
+#define ARM_TRANSLATION_TABLE_MASK               0xFFFFC000
+
+/*
+ * Domain Access Control Bit Masks
+ */
+#define ARM_ACCESS_TYPE_NO_ACCESS(domain_num)    (0x0 << (domain_num)*2)
+#define ARM_ACCESS_TYPE_CLIENT(domain_num)       (0x1 << (domain_num)*2)
+#define ARM_ACCESS_TYPE_MANAGER(domain_num)      (0x3 << (domain_num)*2)
+
+struct ARM_MMU_FIRST_LEVEL_FAULT {
+        unsigned int id : 2;
+        unsigned int sbz : 30;
+};
+
+#define ARM_MMU_FIRST_LEVEL_FAULT_ID 0x0
+
+struct ARM_MMU_FIRST_LEVEL_PAGE_TABLE {
+        unsigned int id : 2;
+        unsigned int imp : 2;
+        unsigned int domain : 4;
+        unsigned int sbz : 1;
+        unsigned int base_address : 23;
+};
+
+#define ARM_MMU_FIRST_LEVEL_PAGE_TABLE_ID 0x1
+
+struct ARM_MMU_FIRST_LEVEL_SECTION {
+        unsigned int id : 2;
+        unsigned int b : 1;
+        unsigned int c : 1;
+        unsigned int imp : 1;
+        unsigned int domain : 4;
+        unsigned int sbz0 : 1;
+        unsigned int ap : 2;
+        unsigned int sbz1 : 8;
+        unsigned int base_address : 12;
+};
+
+#define ARM_MMU_FIRST_LEVEL_SECTION_ID 0x2
+
+struct ARM_MMU_FIRST_LEVEL_RESERVED {
+        unsigned int id : 2;
+        unsigned int sbz : 30;
+};
+
+#define ARM_MMU_FIRST_LEVEL_RESERVED_ID 0x3
+
+#define ARM_MMU_FIRST_LEVEL_DESCRIPTOR_ADDRESS(ttb_base, table_index) \
+        (unsigned long *)((unsigned long)(ttb_base) + ((table_index) << 2))
+
+#define ARM_FIRST_LEVEL_PAGE_TABLE_SIZE 0x4000
+
+#define ARM_MMU_SECTION(ttb_base, actual_base, virtual_base,              \
+                        cacheable, bufferable, perm)                      \
+    CYG_MACRO_START                                                       \
+        register union ARM_MMU_FIRST_LEVEL_DESCRIPTOR desc;               \
+                                                                          \
+        desc.word = 0;                                                    \
+        desc.section.id = ARM_MMU_FIRST_LEVEL_SECTION_ID;                 \
+        desc.section.domain = 0;                                          \
+        desc.section.c = (cacheable);                                     \
+        desc.section.b = (bufferable);                                    \
+        desc.section.ap = (perm);                                         \
+        desc.section.base_address = (actual_base);                        \
+        *ARM_MMU_FIRST_LEVEL_DESCRIPTOR_ADDRESS(ttb_base, (virtual_base)) \
+                            = desc.word;                                  \
+    CYG_MACRO_END
+
+#define X_ARM_MMU_SECTION(abase,vbase,size,cache,buff,access)                 \
+      {                                                            \
+        int i; int j = abase; int k = vbase;                              \
+        for (i = size; i > 0 ; i--,j++,k++) {                             \
+        ARM_MMU_SECTION(ttb_base, j, k, cache, buff, access);      \
+      }                                                            \
+    }
+
+union ARM_MMU_FIRST_LEVEL_DESCRIPTOR {
+        unsigned long word;
+        struct ARM_MMU_FIRST_LEVEL_FAULT fault;
+        struct ARM_MMU_FIRST_LEVEL_PAGE_TABLE page_table;
+        struct ARM_MMU_FIRST_LEVEL_SECTION section;
+        struct ARM_MMU_FIRST_LEVEL_RESERVED reserved;
+};
+
+#define ARM_UNCACHEABLE                         0
+#define ARM_CACHEABLE                           1
+#define ARM_UNBUFFERABLE                        0
+#define ARM_BUFFERABLE                          1
+
+#define ARM_ACCESS_PERM_NONE_NONE               0
+#define ARM_ACCESS_PERM_RO_NONE                 0
+#define ARM_ACCESS_PERM_RO_RO                   0
+#define ARM_ACCESS_PERM_RW_NONE                 1
+#define ARM_ACCESS_PERM_RW_RO                   2
+#define ARM_ACCESS_PERM_RW_RW                   3
+
+/*
+ * Initialization for the Domain Access Control Register
+ */
+#define ARM_ACCESS_DACR_DEFAULT      (          \
+        ARM_ACCESS_TYPE_MANAGER(0)    |         \
+        ARM_ACCESS_TYPE_NO_ACCESS(1)  |         \
+        ARM_ACCESS_TYPE_NO_ACCESS(2)  |         \
+        ARM_ACCESS_TYPE_NO_ACCESS(3)  |         \
+        ARM_ACCESS_TYPE_NO_ACCESS(4)  |         \
+        ARM_ACCESS_TYPE_NO_ACCESS(5)  |         \
+        ARM_ACCESS_TYPE_NO_ACCESS(6)  |         \
+        ARM_ACCESS_TYPE_NO_ACCESS(7)  |         \
+        ARM_ACCESS_TYPE_NO_ACCESS(8)  |         \
+        ARM_ACCESS_TYPE_NO_ACCESS(9)  |         \
+        ARM_ACCESS_TYPE_NO_ACCESS(10) |         \
+        ARM_ACCESS_TYPE_NO_ACCESS(11) |         \
+        ARM_ACCESS_TYPE_NO_ACCESS(12) |         \
+        ARM_ACCESS_TYPE_NO_ACCESS(13) |         \
+        ARM_ACCESS_TYPE_NO_ACCESS(14) |         \
+        ARM_ACCESS_TYPE_NO_ACCESS(15) )
+
+// ------------------------------------------------------------------------
+#endif // ifndef CYGONCE_HAL_MM_H
+// End of hal_mm.h
+
+
+
+
+
diff -urN -x CVS -x doc -x lwip_tcpip -x calmrisc16 -x calmrisc32 ecos_20050912/packages/hal/arm/mx51/var/current/include/hal_soc.h ecos_base/packages/hal/arm/mx51/var/current/include/hal_soc.h
--- ecos_20050912/packages/hal/arm/mx51/var/current/include/hal_soc.h	1969-12-31 18:00:00.000000000 -0600
+++ ecos_base/packages/hal/arm/mx51/var/current/include/hal_soc.h	2008-03-31 18:32:55.000000000 -0500
@@ -0,0 +1,496 @@
+//==========================================================================
+//
+//      hal_soc.h
+//
+//      SoC chip definitions
+//
+//==========================================================================
+//####ECOSGPLCOPYRIGHTBEGIN####
+// -------------------------------------------
+// This file is part of eCos, the Embedded Configurable Operating System.
+// Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+// Copyright (C) 2002 Gary Thomas
+//
+// eCos is free software; you can redistribute it and/or modify it under
+// the terms of the GNU General Public License as published by the Free
+// Software Foundation; either version 2 or (at your option) any later version.
+//
+// eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with eCos; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+//
+// As a special exception, if other files instantiate templates or use macros
+// or inline functions from this file, or you compile this file and link it
+// with other works to produce a work based on this file, this file does not
+// by itself cause the resulting work to be covered by the GNU General Public
+// License. However the source code for this file must still be made available
+// in accordance with section (3) of the GNU General Public License.
+//
+// This exception does not invalidate any other reasons why a work based on
+// this file might be covered by the GNU General Public License.
+//
+// Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+// at http://sources.redhat.com/ecos/ecos-license/
+// -------------------------------------------
+//####ECOSGPLCOPYRIGHTEND####
+//========================================================================*/
+
+#ifndef __HAL_SOC_H__
+#define __HAL_SOC_H__
+
+#ifdef __ASSEMBLER__
+
+#define REG8_VAL(a)          (a)
+#define REG16_VAL(a)         (a)
+#define REG32_VAL(a)         (a)
+
+#define REG8_PTR(a)          (a)
+#define REG16_PTR(a)         (a)
+#define REG32_PTR(a)         (a)
+
+#else /* __ASSEMBLER__ */
+
+extern char HAL_PLATFORM_EXTRA[];
+#define REG8_VAL(a)          ((unsigned char)(a))
+#define REG16_VAL(a)         ((unsigned short)(a))
+#define REG32_VAL(a)         ((unsigned int)(a))
+
+#define REG8_PTR(a)          ((volatile unsigned char *)(a))
+#define REG16_PTR(a)         ((volatile unsigned short *)(a))
+#define REG32_PTR(a)         ((volatile unsigned int *)(a))
+#define readb(a)             (*(volatile unsigned char *)(a))
+#define readw(a)             (*(volatile unsigned short *)(a))
+#define readl(a)             (*(volatile unsigned int *)(a))
+#define writeb(v,a)          (*(volatile unsigned char *)(a) = (v))
+#define writew(v,a)          (*(volatile unsigned short *)(a) = (v))
+#define writel(v,a)          (*(volatile unsigned int *)(a) = (v))
+
+#endif /* __ASSEMBLER__ */
+
+/*
+ * Default Memory Layout Definitions
+ */
+
+#define L2CC_BASE_ADDR          0xB0000000
+
+/*
+ * AIPS 1
+ */
+#define AIPS1_BASE_ADDR         0xC3F00000
+#define AIPS1_CTRL_BASE_ADDR    AIPS1_BASE_ADDR
+#define MAX_BASE_ADDR           0xC3F80000
+#define GPIO1_BASE_ADDR         0xC3F84000
+#define GPIO2_BASE_ADDR         0xC3F88000
+#define GPIO3_BASE_ADDR         0xC3F8C000
+#define KPP_BASE_ADDR           0xC3F94000
+#define WDOG1_BASE_ADDR         0xC3F98000
+#define WDOG_BASE_ADDR          WDOG1_BASE_ADDR
+#define WDOG2_BASE_ADDR         0xC3F9C000
+#define GPT1_BASE_ADDR          0xC3FA0000
+#define RTC_BASE_ADDR           0xC3FA4000
+#define IOMUXC_BASE_ADDR        0xC3FA8000
+#define IIM_BASE_ADDR           0xC3FAC000
+#define FEC_BASE_ADDR           0xC3FE8000
+
+/*
+ * SPBA
+ */
+#define MMC_SDHC1_BASE_ADDR     0xC0004000
+#define MMC_SDHC2_BASE_ADDR     0xC0008000
+#define UART3_BASE_ADDR         0xC000C000
+#define CSPI2_BASE_ADDR         0xC0010000
+#define SSI2_BASE_ADDR          0xC0014000
+#define ATA_DMA_BASE_ADDR       0xC0034000
+#define SPBA_CTRL_BASE_ADDR     0xC003C000
+
+/*
+ * AIPS 2
+ */
+#define AIPS2_BASE_ADDR         0xE3F00000
+#define AIPS2_CTRL_BASE_ADDR    AIPS2_BASE_ADDR
+#define PLL1_BASE_ADDR          0xE3F80000
+#define PLL2_BASE_ADDR          0xE3F84000
+#define PLL3_BASE_ADDR          0xE3F88000
+#define CCM_BASE_ADDR           0xE3F8C000
+#define SRC_BASE_ADDR           0xE3F94000
+#define EPIT1_BASE_ADDR         0xE3F98000
+#define EPIT2_BASE_ADDR         0xE3F9C000
+#define CSPI3_BASE_ADDR         0xE3FA8000
+#define CSPI1_BASE_ADDR         0xE3FAC000
+#define UART1_BASE_ADDR         0xE3FB0000
+#define UART2_BASE_ADDR         0xE3FBC000
+#define I2C3_BASE_ADDR          0xE3FC0000
+#define I2C2_BASE_ADDR          0xE3FC4000
+#define I2C_BASE_ADDR           0xE3FC8000
+#define SSI1_BASE_ADDR          0xE3FCC000
+#define AUDMUX_BASE             0xE3FD0000
+
+#define GPC_BASE_ADDR           (AIPS2_BASE_ADDR + 0x00090000)
+#define GPC_CNTR_REG            (GPC_BASE_ADDR + 0)
+#define GPC_PGR_REG             (GPC_BASE_ADDR + 4)
+#define GPC_VCR_REG             (GPC_BASE_ADDR + 8)
+
+#define PGC_BASE_VPU            (GPC_BASE_ADDR + 0x0240)
+#define PGC_BASE_IPU            (GPC_BASE_ADDR + 0x0220)
+#define GPC_PGR                 (GPC_BASE_ADDR + 0x000)
+#define SRPGCR_ARM              (GPC_BASE_ADDR + 0x02A0 + 0x0000)
+#define SRPGCR_EMI              (GPC_BASE_ADDR + 0x0280 + 0x0000)
+#define PGC_PGCR_VPU            (PGC_BASE_VPU + 0x0000)
+#define PGC_PGCR_IPU            (PGC_BASE_IPU + 0x0000)
+
+#define PLATFORM_BASE_ADDR      0xB0404000
+#define PLATFORM_LPC_REG        (PLATFORM_BASE_ADDR + 0x14)
+
+/*
+ * Interrupt controller
+ */
+#define INTC_BASE_ADDR          0xB0800000
+
+/*
+ * NAND, SDRAM, WEIM, M3IF, EMI controllers
+ */
+#define NFC_IP_BASE             0xE3FDB000
+#define ESDCTL_BASE             0xE3FD9000
+#define WEIM_BASE_ADDR          0xE3FDA000
+
+#define WEIM_CTRL_CS0           WEIM_BASE_ADDR
+#define WEIM_CTRL_CS1           (WEIM_BASE_ADDR + 0x18)
+#define WEIM_CTRL_CS2           (WEIM_BASE_ADDR + 0x30)
+#define WEIM_CTRL_CS3           (WEIM_BASE_ADDR + 0x48)
+#define WEIM_CTRL_CS4           (WEIM_BASE_ADDR + 0x60)
+#define WEIM_CTRL_CS5           (WEIM_BASE_ADDR + 0x78)
+#define M4IF_BASE               0xE3FD8000
+
+/*
+ * Memory regions and CS
+ */
+#define CSD0_BASE_ADDR          0x40000000
+#define CSD1_BASE_ADDR          0x50000000
+#define CS0_BASE_ADDR           0x60000000
+#define CS1_BASE_ADDR           0x68000000
+#define CS2_BASE_ADDR           0x70000000
+
+/*
+ * IRQ Controller Register Definitions.
+ */
+#define INTC_NIMASK                     REG32_PTR(INTC_BASE_ADDR + (0x04))
+#define INTC_INTTYPEH                   REG32_PTR(INTC_BASE_ADDR + (0x18))
+#define INTC_INTTYPEL                   REG32_PTR(INTC_BASE_ADDR + (0x1C))
+
+/* L210 */
+#define L2_CACHE_LINE_SIZE              32
+#define L2_CACHE_CTL_REG                0x100
+#define L2_CACHE_AUX_CTL_REG            0x104
+#define L2_CACHE_SYNC_REG               0x730
+#define L2_CACHE_INV_LINE_REG           0x770
+#define L2_CACHE_INV_WAY_REG            0x77C
+#define L2_CACHE_CLEAN_LINE_PA_REG      0x7B0
+#define L2_CACHE_CLEAN_LINE_WAY_REG     0x7B8
+#define L2_CACHE_CLEAN_WAY_REG          0x7BC
+#define L2_CACHE_CLEAN_INV_LINE_PA_REG  0x7F0
+#define L2_CACHE_CLEAN_INV_LINE_WAY_REG 0x7F8
+#define L2_CACHE_CLEAN_INV_WAY_REG      0x7FC
+
+/* CCM */
+#define CLKCTL_CCMR                     0x00
+#define CLKCTL_PDR0                     0x04
+#define CLKCTL_PDR1                     0x08
+
+#define CLKCTL_CCSR                     0x0C
+#define CLKCTL_CACRR                    0x10
+#define CLKCTL_CBCDR2                   0x18
+#define CLKCTL_CBCDR3                   0x1C
+#define CLKCTL_CBCDR4                   0x20
+#define CLKCTL_CBCDR5                   0x24
+#define CLKCTL_CBCDR6                   0x28
+#define CLKCTL_CBCDR7                   0x2C
+#define CLKCTL_CAMR                     0x30
+#define CLKCTL_PDR2                     0x64
+#define CLKCTL_RCSR                     0x0C
+#define CLKCTL_MPCTL                    0x10
+#define CLKCTL_UPCTL                    0x14
+#define CLKCTL_SPCTL                    0x18
+#define CLKCTL_COSR                     0x1C
+#define CLKCTL_CSCMR1                   0x34
+#define CLKCTL_CSCDR1                   0x3C
+#define CLKCTL_CS1CDR                   0x40
+#define CLKCTL_CS2CDR                   0x44
+#define CLKCTL_CSCDR2                   0x60
+#define CLKCTL_CDCR                     0x6C
+#define CLKCTL_CCOSR                    0x80
+
+#define FREQ_24MHZ                      24000000
+#define FREQ_32768HZ                    (32768 * 1024)
+#define FREQ_38400HZ                    (38400 * 1024)
+#define FREQ_32000HZ                    (32000 * 1024)
+#define PLL_REF_CLK                     FREQ_24MHZ
+//#define PLL_REF_CLK  FREQ_32768HZ
+//#define PLL_REF_CLK  FREQ_32000HZ
+
+/* WEIM registers */
+#define CSGCR1                          0x00
+#define CSGCR2                          0x04
+#define CSRCR1                          0x08
+#define CSRCR2                          0x0C
+#define CSWCR1                          0x10
+
+/* ESDCTL */
+#define ESDCTL_ESDCTL0                  0x00
+#define ESDCTL_ESDCFG0                  0x04
+#define ESDCTL_ESDCTL1                  0x08
+#define ESDCTL_ESDCFG1                  0x0C
+#define ESDCTL_ESDMISC                  0x10
+#define ESDCTL_ESDSCR                   0x14
+#define ESDCTL_ESDCDLY1                 0x20
+#define ESDCTL_ESDCDLY2                 0x24
+#define ESDCTL_ESDCDLY3                 0x28
+#define ESDCTL_ESDCDLY4                 0x2C
+#define ESDCTL_ESDCDLY5                 0x30
+#define ESDCTL_ESDCDLYGD                0x34
+
+/* DPLL */
+#define PLL_DP_CTL          0x00
+#define PLL_DP_CONFIG       0x04
+#define PLL_DP_OP           0x08
+#define PLL_DP_MFD          0x0C
+#define PLL_DP_MFN          0x10
+#define PLL_DP_MFNMINUS     0x14
+#define PLL_DP_MFNPLUS      0x18
+#define PLL_DP_HFS_OP       0x1C
+#define PLL_DP_HFS_MFD      0x20
+#define PLL_DP_HFS_MFN      0x24
+#define PLL_DP_TOGC         0x28
+#define PLL_DP_DESTAT       0x2C
+
+#define CHIP_REV_1_0            0x0      /* PASS 1.0 */
+#define CHIP_REV_1_1            0x1      /* PASS 1.1 */
+#define CHIP_REV_2_0            0x2      /* PASS 2.0 */
+#define CHIP_LATEST             CHIP_REV_1_1
+
+#define IIM_STAT_OFF            0x00
+#define IIM_STAT_BUSY           (1 << 7)
+#define IIM_STAT_PRGD           (1 << 1)
+#define IIM_STAT_SNSD           (1 << 0)
+#define IIM_STATM_OFF           0x04
+#define IIM_ERR_OFF             0x08
+#define IIM_ERR_PRGE            (1 << 7)
+#define IIM_ERR_WPE         (1 << 6)
+#define IIM_ERR_OPE         (1 << 5)
+#define IIM_ERR_RPE         (1 << 4)
+#define IIM_ERR_WLRE        (1 << 3)
+#define IIM_ERR_SNSE        (1 << 2)
+#define IIM_ERR_PARITYE     (1 << 1)
+#define IIM_EMASK_OFF           0x0C
+#define IIM_FCTL_OFF            0x10
+#define IIM_UA_OFF              0x14
+#define IIM_LA_OFF              0x18
+#define IIM_SDAT_OFF            0x1C
+#define IIM_PREV_OFF            0x20
+#define IIM_SREV_OFF            0x24
+#define IIM_PREG_P_OFF          0x28
+#define IIM_SCS0_OFF            0x2C
+#define IIM_SCS1_P_OFF          0x30
+#define IIM_SCS2_OFF            0x34
+#define IIM_SCS3_P_OFF          0x38
+
+#define EPIT_BASE_ADDR          EPIT1_BASE_ADDR
+#define EPITCR                  0x00
+#define EPITSR                  0x04
+#define EPITLR                  0x08
+#define EPITCMPR                0x0C
+#define EPITCNR                 0x10
+
+#define GPT_BASE_ADDR           GPT1_BASE_ADDR
+#define GPTCR                   0x00
+#define GPTPR                   0x04
+#define GPTSR                   0x08
+#define GPTIR                   0x0C
+#define GPTOCR1                 0x10
+#define GPTOCR2                 0x14
+#define GPTOCR3                 0x18
+#define GPTICR1                 0x1C
+#define GPTICR2                 0x20
+#define GPTCNT                  0x24
+
+/* Assuming 26MHz input clock */
+/*                            PD             MFD              MFI          MFN */
+#define MPCTL_PARAM_208     (((2-1) << 26) + ((1 -1) << 16) + (8  << 10) + (0  << 0))
+#define MPCTL_PARAM_399     (((1-1) << 26) + ((52-1) << 16) + (7  << 10) + (35 << 0))
+#define MPCTL_PARAM_532     (((1-1) << 26) + ((52-1) << 16) + (10 << 10) + (12 << 0))
+#define MPCTL_PARAM_665     (((1-1) << 26) + ((52-1) << 16) + (12 << 10) + (41 << 0))
+#define MPCTL_PARAM_532_27  (((1-1) << 26) + ((15-1) << 16) + (9  << 10) + (13 << 0))
+
+/* UPCTL                      PD             MFD              MFI          MFN */
+#define UPCTL_PARAM_288     (((1-1) << 26) + ((13-1) << 16) + (5  << 10) + (7  << 0))
+#define UPCTL_PARAM_240     (((2-1) << 26) + ((13-1) << 16) + (9  << 10) + (3  << 0))
+#define UPCTL_PARAM_240_27  (((2-1) << 26) + ((9 -1) << 16) + (8  << 10) + (8  << 0))
+
+/* PDR0 */
+#define PDR0_208_104_52     0xFF870D48  /* ARM=208MHz, HCLK=104MHz, IPG=52MHz */
+#define PDR0_399_66_66      0xFF872B28  /* ARM=399MHz, HCLK=IPG=66.5MHz */
+#define PDR0_399_133_66     0xFF871650  /* ARM=399MHz, HCLK=133MHz, IPG=66.5MHz */
+#define PDR0_532_133_66     0xFF871D58  /* ARM=532MHz, HCLK=133MHz, IPG=66MHz */
+#define PDR0_665_83_42      0xFF873B78  /* ARM=665MHz, HCLK=83MHz, IPG=42MHz */
+#define PDR0_665_133_66     0xFF872560  /* ARM=665MHz, HCLK=133MHz, IPG=66MHz */
+
+//#define BARKER_CODE_SWAP_LOC            0x404
+#define BARKER_CODE_VAL                 0xB1
+#define NFC_V2_1
+#define NFC_BASE                        0x7FFF0000
+#define NAND_REG_BASE                   (NFC_BASE + 0x1E00)
+
+#define NAND_ADD_CMD_REG                (NAND_REG_BASE + 0x00)
+
+#define NAND_CONFIGURATION1_REG         (NAND_REG_BASE + 0x04)
+    #define NAND_CONFIGURATION1_NFC_RST     (1 << 2)
+    #define NAND_CONFIGURATION1_NF_CE       (1 << 1)
+    #define NAND_CONFIGURATION1_SP_EN       (1 << 0)
+
+#define NAND_ECC_STATUS_RESULT_REG      (NAND_REG_BASE + 0x08)
+
+#define NAND_LAUNCH_REG                 (NAND_REG_BASE + 0x0C)
+    #define NAND_LAUNCH_FCMD                (1 << 0)
+    #define NAND_LAUNCH_FADD                (1 << 1)
+    #define NAND_LAUNCH_FDI                 (1 << 2)
+
+
+#define NFC_WR_PROT_REG                 (NFC_IP_BASE + 0x00)
+    #define NFC_WR_PROT_CS0              (0 << 20)
+    #define NFC_WR_PROT_BLS_UNLOCK       (2 << 16)
+    #define NFC_WR_PROT_WPC              (4 << 0)
+
+#define UNLOCK_BLK_ADD0_REG             (NFC_IP_BASE + 0x04)
+
+#define UNLOCK_BLK_ADD1_REG             (NFC_IP_BASE + 0x08)
+
+#define UNLOCK_BLK_ADD2_REG             (NFC_IP_BASE + 0x0C)
+
+#define UNLOCK_BLK_ADD3_REG             (NFC_IP_BASE + 0x10)
+
+#define NFC_FLASH_CONFIG2_REG           (NFC_IP_BASE + 0x14)
+    #define NFC_FLASH_CONFIG2_EDC0          (0 << 9)
+    #define NFC_FLASH_CONFIG2_EDC1          (1 << 9)
+    #define NFC_FLASH_CONFIG2_EDC2          (2 << 9)
+    #define NFC_FLASH_CONFIG2_EDC3          (3 << 9)
+    #define NFC_FLASH_CONFIG2_EDC4          (4 << 9)
+    #define NFC_FLASH_CONFIG2_EDC5          (5 << 9)
+    #define NFC_FLASH_CONFIG2_EDC6          (6 << 9)
+    #define NFC_FLASH_CONFIG2_EDC7          (7 << 9)
+    #define NFC_FLASH_CONFIG2_PPB_32        (0 << 7)
+    #define NFC_FLASH_CONFIG2_PPB_64        (1 << 7)
+    #define NFC_FLASH_CONFIG2_PPB_128       (2 << 7)
+    #define NFC_FLASH_CONFIG2_PPB_256       (3 << 7)
+    #define NFC_FLASH_CONFIG2_INT_MSK       (1 << 4)
+    #define NFC_FLASH_CONFIG2_ECC_EN        (1 << 3)
+    #define NFC_FLASH_CONFIG2_SYM           (1 << 2)
+
+#define NFC_IPC_REG                     (NFC_IP_BASE + 0x18)
+    #define NFC_IPC_INT                     (1 << 31)
+    #define NFC_IPC_LPS                     (1 << 30)
+    #define NFC_IPC_RB_B                    (1 << 29)
+    #define NFC_IPC_CACK                    (1 << 1)
+    #define NFC_IPC_CREQ                    (1 << 0)
+#define NFC_AXI_ERR_ADD_REG             (NFC_IP_BASE + 0x1C)
+
+
+#define NAND_FLASH_BOOT                 0x10000000
+#define SDRAM_NON_FLASH_BOOT            0x20000000
+
+#define MXCFIS_NOTHING                  0x00000000
+#define MXCFIS_NAND                     0x10000000
+
+#define IS_BOOTING_FROM_NAND()          (_mxc_boot == NAND_FLASH_BOOT)
+// No NOR flash is supported under MX37 for booting
+#define IS_BOOTING_FROM_NOR()           (0)
+#define IS_BOOTING_FROM_SDRAM()         (_mxc_boot == SDRAM_NON_FLASH_BOOT)
+
+#define IS_FIS_FROM_NAND()              1
+#define IS_FIS_FROM_NOR()               0
+
+/*
+ * This macro is used to get certain bit field from a number
+ */
+#define MXC_GET_FIELD(val, len, sh)          ((val >> sh) & ((1 << len) - 1))
+
+/*
+ * This macro is used to set certain bit field inside a number
+ */
+#define MXC_SET_FIELD(val, len, sh, nval)    ((val & ~(((1 << len) - 1) << sh)) | (nval << sh))
+
+#define L2CC_ENABLED
+#define UART_WIDTH_32         /* internal UART is 32bit access only */
+
+#if !defined(__ASSEMBLER__)
+void cyg_hal_plf_serial_init(void);
+void cyg_hal_plf_serial_stop(void);
+void hal_delay_us(unsigned int usecs);
+#define HAL_DELAY_US(n)     hal_delay_us(n)
+
+enum plls {
+    PLL1,
+    PLL2,
+    PLL3,
+};
+
+enum main_clocks {
+        CPU_CLK,
+        AHB_CLK,
+        IPG_CLK,
+        IPG_PER_CLK,
+        DDR_CLK,
+        NFC_CLK,
+        USB_CLK,
+};
+
+enum peri_clocks {
+        UART1_BAUD,
+        UART2_BAUD,
+        UART3_BAUD,
+        SSI1_BAUD,
+        SSI2_BAUD,
+        CSI_BAUD,
+        MSTICK1_CLK,
+        MSTICK2_CLK,
+        SPI1_CLK = CSPI1_BASE_ADDR,
+        SPI2_CLK = CSPI2_BASE_ADDR,
+};
+
+unsigned int pll_clock(enum plls pll);
+
+unsigned int get_main_clock(enum main_clocks clk);
+
+unsigned int get_peri_clock(enum peri_clocks clk);
+
+enum {
+    MXC_NFC_V1,
+    MXC_NFC_V2,
+};
+
+typedef unsigned int nfc_setup_func_t(unsigned int, unsigned int, unsigned int);
+
+#endif //#if !defined(__ASSEMBLER__)
+
+#define HAL_MMU_OFF() \
+CYG_MACRO_START          \
+    asm volatile (                                                      \
+        "mcr p15, 0, r0, c7, c14, 0;"                                   \
+        "mcr p15, 0, r0, c7, c10, 4;" /* drain the write buffer */      \
+        "mcr p15, 0, r0, c7, c5, 0;" /* invalidate I cache */           \
+        "mrc p15, 0, r0, c1, c0, 0;" /* read c1 */                      \
+        "bic r0, r0, #0x7;" /* disable DCache and MMU */                \
+        "bic r0, r0, #0x1000;" /* disable ICache */                     \
+        "mcr p15, 0, r0, c1, c0, 0;" /*  */                             \
+        "nop;" /* flush i+d-TLBs */                                     \
+        "nop;" /* flush i+d-TLBs */                                     \
+        "nop;" /* flush i+d-TLBs */                                     \
+        :                                                               \
+        :                                                               \
+        : "r0","memory" /* clobber list */);                            \
+CYG_MACRO_END
+
+#endif /* __HAL_SOC_H__ */
diff -urN -x CVS -x doc -x lwip_tcpip -x calmrisc16 -x calmrisc32 ecos_20050912/packages/hal/arm/mx51/var/current/include/hal_var_ints.h ecos_base/packages/hal/arm/mx51/var/current/include/hal_var_ints.h
--- ecos_20050912/packages/hal/arm/mx51/var/current/include/hal_var_ints.h	1969-12-31 18:00:00.000000000 -0600
+++ ecos_base/packages/hal/arm/mx51/var/current/include/hal_var_ints.h	2008-03-31 18:32:55.000000000 -0500
@@ -0,0 +1,127 @@
+#ifndef CYGONCE_HAL_VAR_INTS_H
+#define CYGONCE_HAL_VAR_INTS_H
+//==========================================================================
+//
+//      hal_var_ints.h
+//
+//      HAL Interrupt and clock support
+//
+//==========================================================================
+//####ECOSGPLCOPYRIGHTBEGIN####
+// -------------------------------------------
+// This file is part of eCos, the Embedded Configurable Operating System.
+// Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+//
+// eCos is free software; you can redistribute it and/or modify it under
+// the terms of the GNU General Public License as published by the Free
+// Software Foundation; either version 2 or (at your option) any later version.
+//
+// eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with eCos; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+//
+// As a special exception, if other files instantiate templates or use macros
+// or inline functions from this file, or you compile this file and link it
+// with other works to produce a work based on this file, this file does not
+// by itself cause the resulting work to be covered by the GNU General Public
+// License. However the source code for this file must still be made available
+// in accordance with section (3) of the GNU General Public License.
+//
+// This exception does not invalidate any other reasons why a work based on
+// this file might be covered by the GNU General Public License.
+//
+// Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+// at http://sources.redhat.com/ecos/ecos-license/
+// -------------------------------------------
+//####ECOSGPLCOPYRIGHTEND####
+//==========================================================================
+
+#include <cyg/hal/hal_soc.h>         // registers
+
+#define CYGNUM_HAL_INTERRUPT_GPIO0   0
+#define CYGNUM_HAL_INTERRUPT_GPIO1   1
+#define CYGNUM_HAL_INTERRUPT_GPIO2   2
+#define CYGNUM_HAL_INTERRUPT_GPIO3   3
+#define CYGNUM_HAL_INTERRUPT_GPIO4   4
+#define CYGNUM_HAL_INTERRUPT_GPIO5   5
+#define CYGNUM_HAL_INTERRUPT_GPIO6   6
+#define CYGNUM_HAL_INTERRUPT_GPIO7   7
+#define CYGNUM_HAL_INTERRUPT_GPIO8   8
+#define CYGNUM_HAL_INTERRUPT_GPIO9   9
+#define CYGNUM_HAL_INTERRUPT_GPIO10  10
+#define CYGNUM_HAL_INTERRUPT_GPIO    11  // Don't use directly!
+#define CYGNUM_HAL_INTERRUPT_LCD     12
+#define CYGNUM_HAL_INTERRUPT_UDC     13
+#define CYGNUM_HAL_INTERRUPT_UART1   15
+#define CYGNUM_HAL_INTERRUPT_UART2   16
+#define CYGNUM_HAL_INTERRUPT_UART3   17
+#define CYGNUM_HAL_INTERRUPT_UART4   17
+#define CYGNUM_HAL_INTERRUPT_MCP     18
+#define CYGNUM_HAL_INTERRUPT_SSP     19
+#define CYGNUM_HAL_INTERRUPT_TIMER0  26
+#define CYGNUM_HAL_INTERRUPT_TIMER1  27
+#define CYGNUM_HAL_INTERRUPT_TIMER2  28
+#define CYGNUM_HAL_INTERRUPT_TIMER3  29
+#define CYGNUM_HAL_INTERRUPT_HZ      30
+#define CYGNUM_HAL_INTERRUPT_ALARM   31
+
+// GPIO bits 31..11 can generate interrupts as well, but they all
+// end up clumped into interrupt signal #11.  Using the symbols
+// below allow for detection of these separately.
+
+#define CYGNUM_HAL_INTERRUPT_GPIO11  (32+11)
+#define CYGNUM_HAL_INTERRUPT_GPIO12  (32+12)
+#define CYGNUM_HAL_INTERRUPT_GPIO13  (32+13)
+#define CYGNUM_HAL_INTERRUPT_GPIO14  (32+14)
+#define CYGNUM_HAL_INTERRUPT_GPIO15  (32+15)
+#define CYGNUM_HAL_INTERRUPT_GPIO16  (32+16)
+#define CYGNUM_HAL_INTERRUPT_GPIO17  (32+17)
+#define CYGNUM_HAL_INTERRUPT_GPIO18  (32+18)
+#define CYGNUM_HAL_INTERRUPT_GPIO19  (32+19)
+#define CYGNUM_HAL_INTERRUPT_GPIO20  (32+20)
+#define CYGNUM_HAL_INTERRUPT_GPIO21  (32+21)
+#define CYGNUM_HAL_INTERRUPT_GPIO22  (32+22)
+#define CYGNUM_HAL_INTERRUPT_GPIO23  (32+23)
+#define CYGNUM_HAL_INTERRUPT_GPIO24  (32+24)
+#define CYGNUM_HAL_INTERRUPT_GPIO25  (32+25)
+#define CYGNUM_HAL_INTERRUPT_GPIO26  (32+26)
+#define CYGNUM_HAL_INTERRUPT_GPIO27  (32+27)
+
+#define CYGNUM_HAL_INTERRUPT_NONE    -1
+
+#define CYGNUM_HAL_ISR_MIN            0
+#define CYGNUM_HAL_ISR_MAX           (27+32)
+
+#define CYGNUM_HAL_ISR_COUNT         (CYGNUM_HAL_ISR_MAX+1)
+
+// The vector used by the Real time clock
+#define CYGNUM_HAL_INTERRUPT_RTC     CYGNUM_HAL_INTERRUPT_TIMER0
+
+// The vector used by the Ethernet
+#define CYGNUM_HAL_INTERRUPT_ETH     CYGNUM_HAL_INTERRUPT_GPIO0
+
+// method for reading clock interrupt latency
+#ifdef CYGVAR_KERNEL_COUNTERS_CLOCK_LATENCY
+externC void hal_clock_latency(cyg_uint32 *);
+# define HAL_CLOCK_LATENCY( _pvalue_ ) \
+         hal_clock_latency( (cyg_uint32 *)(_pvalue_) )
+#endif
+
+//----------------------------------------------------------------------------
+// Reset.
+#define HAL_PLATFORM_RESET()                                        \
+        CYG_MACRO_START                                             \
+                *(volatile unsigned short *)WDOG_BASE_ADDR |= 0x4;  \
+                /* hang here forever if reset fails */              \
+                while (1){}                                         \
+        CYG_MACRO_END
+
+// Fallback (never really used)
+#define HAL_PLATFORM_RESET_ENTRY 0x00000000
+
+#endif // CYGONCE_HAL_VAR_INTS_H
diff -urN -x CVS -x doc -x lwip_tcpip -x calmrisc16 -x calmrisc32 ecos_20050912/packages/hal/arm/mx51/var/current/include/plf_stub.h ecos_base/packages/hal/arm/mx51/var/current/include/plf_stub.h
--- ecos_20050912/packages/hal/arm/mx51/var/current/include/plf_stub.h	1969-12-31 18:00:00.000000000 -0600
+++ ecos_base/packages/hal/arm/mx51/var/current/include/plf_stub.h	2008-03-31 18:32:55.000000000 -0500
@@ -0,0 +1,72 @@
+#ifndef CYGONCE_HAL_PLF_STUB_H
+#define CYGONCE_HAL_PLF_STUB_H
+
+//=============================================================================
+//
+//      plf_stub.h
+//
+//      Platform header for GDB stub support.
+//
+//=============================================================================
+//####ECOSGPLCOPYRIGHTBEGIN####
+// -------------------------------------------
+// This file is part of eCos, the Embedded Configurable Operating System.
+// Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+//
+// eCos is free software; you can redistribute it and/or modify it under
+// the terms of the GNU General Public License as published by the Free
+// Software Foundation; either version 2 or (at your option) any later version.
+//
+// eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with eCos; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+//
+// As a special exception, if other files instantiate templates or use macros
+// or inline functions from this file, or you compile this file and link it
+// with other works to produce a work based on this file, this file does not
+// by itself cause the resulting work to be covered by the GNU General Public
+// License. However the source code for this file must still be made available
+// in accordance with section (3) of the GNU General Public License.
+//
+// This exception does not invalidate any other reasons why a work based on
+// this file might be covered by the GNU General Public License.
+//
+// Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+// at http://sources.redhat.com/ecos/ecos-license/
+// -------------------------------------------
+//####ECOSGPLCOPYRIGHTEND####
+//=============================================================================
+
+#include <pkgconf/hal.h>
+#include <cyg/infra/cyg_type.h>         // CYG_UNUSED_PARAM
+
+#include <cyg/hal/hal_soc.h>         // registers
+#include <cyg/hal/hal_io.h>             // IO macros
+#include <cyg/hal/hal_intr.h>           // Interrupt macros
+#include <cyg/hal/arm_stub.h>           // architecture stub support
+
+#ifdef CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS
+//----------------------------------------------------------------------------
+// Define some platform specific communication details. This is mostly
+// handled by hal_if now, but we need to make sure the comms tables are
+// properly initialized.
+
+externC void cyg_hal_plf_comms_init(void);
+
+#define HAL_STUB_PLATFORM_INIT_SERIAL()         cyg_hal_plf_comms_init()
+#define HAL_STUB_PLATFORM_SET_BAUD_RATE(baud)   CYG_UNUSED_PARAM(int, (baud))
+#define HAL_STUB_PLATFORM_INTERRUPTIBLE         0
+
+//----------------------------------------------------------------------------
+// Stub initializer.
+#define HAL_STUB_PLATFORM_INIT()                CYG_EMPTY_STATEMENT
+
+#endif // ifdef CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS
+//-----------------------------------------------------------------------------
+#endif // CYGONCE_HAL_PLF_STUB_H
+// End of plf_stub.h
diff -urN -x CVS -x doc -x lwip_tcpip -x calmrisc16 -x calmrisc32 ecos_20050912/packages/hal/arm/mx51/var/current/include/var_io.h ecos_base/packages/hal/arm/mx51/var/current/include/var_io.h
--- ecos_20050912/packages/hal/arm/mx51/var/current/include/var_io.h	1969-12-31 18:00:00.000000000 -0600
+++ ecos_base/packages/hal/arm/mx51/var/current/include/var_io.h	2008-03-31 18:32:55.000000000 -0500
@@ -0,0 +1,56 @@
+#ifndef CYGONCE_VAR_IO_H
+#define CYGONCE_VAR_IO_H
+
+//=============================================================================
+//
+//      var_io.h
+//
+//      Variant specific IO support
+//
+//=============================================================================
+//####ECOSGPLCOPYRIGHTBEGIN####
+// -------------------------------------------
+// This file is part of eCos, the Embedded Configurable Operating System.
+// Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+//
+// eCos is free software; you can redistribute it and/or modify it under
+// the terms of the GNU General Public License as published by the Free
+// Software Foundation; either version 2 or (at your option) any later version.
+//
+// eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with eCos; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+//
+// As a special exception, if other files instantiate templates or use macros
+// or inline functions from this file, or you compile this file and link it
+// with other works to produce a work based on this file, this file does not
+// by itself cause the resulting work to be covered by the GNU General Public
+// License. However the source code for this file must still be made available
+// in accordance with section (3) of the GNU General Public License.
+//
+// This exception does not invalidate any other reasons why a work based on
+// this file might be covered by the GNU General Public License.
+//
+// Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+// at http://sources.redhat.com/ecos/ecos-license/
+// -------------------------------------------
+//####ECOSGPLCOPYRIGHTEND####
+//=============================================================================
+
+#include <cyg/hal/plf_io.h>             // Platform specifics
+
+//-----------------------------------------------------------------------------
+
+// Memory mapping details
+#ifndef CYGARC_PHYSICAL_ADDRESS
+#define CYGARC_PHYSICAL_ADDRESS(x) (((unsigned long)x & 0x0FFFFFFF) + RAM_BANK0_BASE)
+#endif
+
+//-----------------------------------------------------------------------------
+// end of var_io.h
+#endif // CYGONCE_VAR_IO_H
diff -urN -x CVS -x doc -x lwip_tcpip -x calmrisc16 -x calmrisc32 ecos_20050912/packages/hal/arm/mx51/var/current/src/cmds.c ecos_base/packages/hal/arm/mx51/var/current/src/cmds.c
--- ecos_20050912/packages/hal/arm/mx51/var/current/src/cmds.c	1969-12-31 18:00:00.000000000 -0600
+++ ecos_base/packages/hal/arm/mx51/var/current/src/cmds.c	2008-03-31 18:32:56.000000000 -0500
@@ -0,0 +1,1255 @@
+//==========================================================================
+//
+//      cmds.c
+//
+//      SoC [platform] specific RedBoot commands
+//
+//==========================================================================
+//####ECOSGPLCOPYRIGHTBEGIN####
+// -------------------------------------------
+// This file is part of eCos, the Embedded Configurable Operating System.
+// Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+//
+// eCos is free software; you can redistribute it and/or modify it under
+// the terms of the GNU General Public License as published by the Free
+// Software Foundation; either version 2 or (at your option) any later version.
+//
+// eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with eCos; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+//
+// As a special exception, if other files instantiate templates or use macros
+// or inline functions from this file, or you compile this file and link it
+// with other works to produce a work based on this file, this file does not
+// by itself cause the resulting work to be covered by the GNU General Public
+// License. However the source code for this file must still be made available
+// in accordance with section (3) of the GNU General Public License.
+//
+// This exception does not invalidate any other reasons why a work based on
+// this file might be covered by the GNU General Public License.
+//
+// Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+// at http://sources.redhat.com/ecos/ecos-license/
+// -------------------------------------------
+//####ECOSGPLCOPYRIGHTEND####
+//==========================================================================
+#include <redboot.h>
+#include <cyg/hal/hal_intr.h>
+#include <cyg/hal/plf_mmap.h>
+#include <cyg/hal/hal_soc.h>         // Hardware definitions
+#include <cyg/hal/hal_cache.h>
+
+int gcd(int m, int n);
+
+typedef unsigned long long  u64;
+typedef unsigned int        u32;
+typedef unsigned short      u16;
+typedef unsigned char       u8;
+
+#define SZ_DEC_1M       1000000
+#define PLL_PD_MAX      16      //actual pd+1
+#define PLL_MFI_MAX     15
+#define PLL_MFI_MIN     5
+#define ARM_DIV_MAX     8
+#define IPG_DIV_MAX     4
+#define AHB_DIV_MAX     8
+#define EMI_DIV_MAX     8
+#define NFC_DIV_MAX     8
+
+#define REF_IN_CLK_NUM  4
+struct fixed_pll_mfd {
+    u32 ref_clk_hz;
+    u32 mfd;
+};
+const struct fixed_pll_mfd fixed_mfd[REF_IN_CLK_NUM] = {
+    {0,                   0},      // reserved
+    {0,                   0},      // reserved
+    {FREQ_24MHZ,          24 * 16},    // 384
+    {0,                   0},      // reserved
+};
+
+struct pll_param {
+    u32 pd;
+    u32 mfi;
+    u32 mfn;
+    u32 mfd;
+};
+
+#define PLL_FREQ_MAX(_ref_clk_)    (2 * _ref_clk_ * PLL_MFI_MAX)
+#define PLL_FREQ_MIN(_ref_clk_)    ((2 * _ref_clk_ * (PLL_MFI_MIN - 1)) / PLL_PD_MAX)
+#define AHB_CLK_MAX     133333333
+#define IPG_CLK_MAX     (AHB_CLK_MAX / 2)
+#define NFC_CLK_MAX     25000000
+// IPU-HSP clock is independent of the HCLK and can go up to 177MHz but requires
+// higher voltage support. For simplicity, limit it to 133MHz
+#define HSP_CLK_MAX     133333333
+
+#define ERR_WRONG_CLK   -1
+#define ERR_NO_MFI      -2
+#define ERR_NO_MFN      -3
+#define ERR_NO_PD       -4
+#define ERR_NO_PRESC    -5
+#define ERR_NO_AHB_DIV  -6
+
+u32 pll_clock(enum plls pll);
+u32 get_main_clock(enum main_clocks clk);
+u32 get_peri_clock(enum peri_clocks clk);
+
+static volatile u32 *pll_base[] =
+{
+    REG32_PTR(PLL1_BASE_ADDR),
+    REG32_PTR(PLL2_BASE_ADDR),
+    REG32_PTR(PLL3_BASE_ADDR),
+};
+
+#define NOT_ON_VAL  0xDEADBEEF
+
+static void clock_setup(int argc, char *argv[]);
+static void clko(int argc, char *argv[]);
+
+RedBoot_cmd("clock",
+            "Setup/Display clock (max AHB=133MHz, max IPG=66.5MHz)\nSyntax:",
+            "[<core clock in MHz> [:<AHB-to-core divider>[:<IPG-to-AHB divider>]]] \n\n\
+If a divider is zero or no divider is specified, the optimal divider values \n\
+will be chosen. Examples:\n\
+   [clock]         -> Show various clocks\n\
+   [clock 532]     -> Core=532  AHB=133           IPG=66.5\n\
+   [clock 399]     -> Core=399  AHB=133           IPG=66.5\n\
+   [clock 532:8]   -> Core=532  AHB=66.5(Core/8)  IPG=66.5\n\
+   [clock 532:8:2] -> Core=532  AHB=66.5(Core/8)  IPG=33.25(AHB/2)\n",
+            clock_setup
+           );
+
+/*!
+ * This is to calculate various parameters based on reference clock and
+ * targeted clock based on the equation:
+ *      t_clk = 2*ref_freq*(mfi + mfn/(mfd+1))/(pd+1)
+ * This calculation is based on a fixed MFD value for simplicity.
+ *
+ * @param ref       reference clock freq in Hz
+ * @param target    targeted clock in Hz
+ * @param p_pd      calculated pd value (pd value from register + 1) upon return
+ * @param p_mfi     calculated actual mfi value upon return
+ * @param p_mfn     calculated actual mfn value upon return
+ * @param p_mfd     fixed mfd value (mfd value from register + 1) upon return
+ *
+ * @return          0 if successful; non-zero otherwise.
+ */
+int calc_pll_params(u32 ref, u32 target, struct pll_param *pll)
+{
+    u64 pd, mfi = 1, mfn, mfd, n_target = target, n_ref = ref, i;
+
+    // make sure targeted freq is in the valid range. Otherwise the
+    // following calculation might be wrong!!!
+    if (n_target < PLL_FREQ_MIN(ref) || n_target > PLL_FREQ_MAX(ref))
+        return ERR_WRONG_CLK;
+    for (i = 0; ; i++) {
+        if (i == REF_IN_CLK_NUM)
+            return ERR_WRONG_CLK;
+        if (fixed_mfd[i].ref_clk_hz == ref) {
+            mfd = fixed_mfd[i].mfd;
+            break;
+        }
+    }
+    // Use n_target and n_ref to avoid overflow
+    for (pd = 1; pd <= PLL_PD_MAX; pd++) {
+        mfi = (n_target * pd) / (2 * n_ref);
+        if (mfi > PLL_MFI_MAX) {
+            return ERR_NO_MFI;
+        } else if (mfi < 5) {
+            continue;
+        }
+        break;
+    }
+    // Now got pd and mfi already
+    mfn = (((n_target * pd) / 2 - n_ref * mfi) * mfd) / n_ref;
+#ifdef CMD_CLOCK_DEBUG
+    diag_printf("%d: ref=%d, target=%d, pd=%d, mfi=%d,mfn=%d, mfd=%d\n",
+                __LINE__, ref, (u32)n_target, (u32)pd, (u32)mfi, (u32)mfn, (u32)mfd);
+#endif
+    i = 1;
+    if (mfn != 0)
+        i = gcd(mfd, mfn);
+    pll->pd = (u32)pd;
+    pll->mfi = (u32)mfi;
+    pll->mfn = (u32)(mfn / i);
+    pll->mfd = (u32)(mfd / i);
+    return 0;
+}
+
+/*!
+ * This function assumes the expected core clock has to be changed by
+ * modifying the PLL. This is NOT true always but for most of the times,
+ * it is. So it assumes the PLL output freq is the same as the expected
+ * core clock (presc=1) unless the core clock is less than PLL_FREQ_MIN.
+ * In the latter case, it will try to increase the presc value until
+ * (presc*core_clk) is greater than PLL_FREQ_MIN. It then makes call to
+ * calc_pll_params() and obtains the values of PD, MFI,MFN, MFD based
+ * on the targeted PLL and reference input clock to the PLL. Lastly,
+ * it sets the register based on these values along with the dividers.
+ * Note 1) There is no value checking for the passed-in divider values
+ *         so the caller has to make sure those values are sensible.
+ *      2) Also adjust the NFC divider such that the NFC clock doesn't
+ *         exceed NFC_CLK_MAX.
+ *      3) IPU HSP clock is independent of AHB clock. Even it can go up to
+ *         177MHz for higher voltage, this function fixes the max to 133MHz.
+ *      4) This function should not have allowed diag_printf() calls since
+ *         the serial driver has been stoped. But leave then here to allow
+ *         easy debugging by NOT calling the cyg_hal_plf_serial_stop().
+ *
+ * @param ref       pll input reference clock (32KHz or 26MHz)
+ * @param core_clk  core clock in Hz
+ * @param emi_clk   emi clock in Hz
+ * @param ahb_div   ahb divider to divide the core clock to get ahb clock
+ *                  (ahb_div - 1) needs to be set in the register
+ * @param ipg_div   ipg divider to divide the core clock to get ipg clock
+ *                  (ipg_div - 1) needs to be set in the register
+ # @return          0 if successful; non-zero otherwise
+ */
+int configure_clock(u32 ref, u32 core_clk, u32 emi_clk, u32 ahb_div, u32 ipg_div)
+{
+#if 0
+    u32 pll, arm_div = 1, emi_div = 0, nfc_div, ascsr, acdr, acder2;
+    struct pll_param pll_param;
+    int ret;
+
+    // assume pll default to core clock first
+    pll = core_clk;
+    // when core_clk >= PLL_FREQ_MIN, the presc can be 1.
+    // Otherwise, need to calculate presc value below and adjust the targeted pll
+    if (core_clk < PLL_FREQ_MIN) {
+        for (presc = 1; presc <= PRESC_MAX; presc++) {
+            if ((core_clk * presc) > PLL_FREQ_MIN) {
+                break;
+            }
+        }
+        if (presc == (PRESC_MAX + 1)) {
+            diag_printf("can't make presc=%d\n", presc);
+            return ERR_NO_PRESC;
+        }
+        pll = core_clk * presc;
+    }
+    // get hsp_div
+    for (hsp_div = 1; hsp_div <= HSP_PODF_MAX; hsp_div++) {
+        if ((pll / hsp_div) <= HSP_CLK_MAX) {
+            break;
+        }
+    }
+    if (hsp_div == (HSP_PODF_MAX + 1)) {
+        diag_printf("can't make hsp_div=%d\n", hsp_div);
+        return ERR_NO_PRESC;
+    }
+
+    // get nfc_div - make sure optimal NFC clock but less than NFC_CLK_MAX
+    for (nfc_div = 1; nfc_div <= NFC_PODF_MAX; nfc_div++) {
+        if ((pll / (ahb_div * nfc_div)) <= NFC_CLK_MAX) {
+            break;
+        }
+    }
+
+    // pll is now the targeted pll output. Use it along with ref input clock
+    // to get pd, mfi, mfn, mfd
+    if ((ret = calc_pll_params(ref, pll, &pd, &mfi, &mfn, &mfd)) != 0) {
+        diag_printf("can't find pll parameters: %d\n", ret);
+        return ret;
+    }
+#ifdef CMD_CLOCK_DEBUG
+    diag_printf("ref=%d, pll=%d, pd=%d, mfi=%d,mfn=%d, mfd=%d\n",
+                ref, pll, pd, mfi, mfn, mfd);
+#endif
+
+    // blindly increase divider first to avoid too fast ahbclk and ipgclk
+    // in case the core clock increases too much
+    pdr0 = readl(CCM_BASE_ADDR + CLKCTL_PDR0);
+    pdr0 &= ~0x000000FF;
+    // increase the dividers. should work even when core clock is 832 (26*2*16)MHz
+    // which is unlikely true.
+    pdr0 |= (1 << 6) | (6 << 3) | (0 << 0);
+    writel(pdr0, CCM_BASE_ADDR + CLKCTL_PDR0);
+    // calculate new pdr0
+    pdr0 &= ~0x00003FFF;
+    pdr0 |= ((hsp_div - 1) << 11) | ((nfc_div - 1) << 8) | ((ipg_div - 1) << 6) |
+            ((ahb_div - 1) << 3) | ((presc - 1) << 0);
+
+    // update PLL register
+    if ((mfd >= (10 * mfn)) || ((10 * mfn) >= (9 * mfd)))
+        brmo = 1;
+
+    mpctl0 = readl(CCM_BASE_ADDR + CLKCTL_MPCTL);
+    mpctl0 = (mpctl0 & 0x4000C000)  |
+             (brmo << 31)           |
+             ((pd - 1) << 26)       |
+             ((mfd - 1) << 16)      |
+             (mfi << 10)            |
+             mfn;
+    writel(mpctl0, CCM_BASE_ADDR + CLKCTL_MPCTL);
+    writel(pdr0, CCM_BASE_ADDR + CLKCTL_PDR0);
+    // add some delay for new values to take effect
+    for (i = 0; i < 10000; i++);
+#endif
+    return 0;
+}
+
+static void clock_setup(int argc,char *argv[])
+{
+#if 0
+    u32 i, core_clk, ipg_div, data[3], temp, ahb_div, ahb_clk, ipg_clk;
+    int ret;
+
+    if (argc == 1)
+        goto print_clock;
+
+    for (i = 0;  i < 3;  i++) {
+        if (!parse_num(*(&argv[1]), (unsigned long *)&temp, &argv[1], ":")) {
+            diag_printf("Error: Invalid parameter\n");
+            return;
+        }
+        data[i] = temp;
+    }
+
+    core_clk = data[0] * SZ_DEC_1M;
+    ahb_div = data[1];  // actual register field + 1
+    ipg_div = data[2];  // actual register field + 1
+
+    if (core_clk < (PLL_FREQ_MIN / PRESC_MAX) || core_clk > PLL_FREQ_MAX) {
+        diag_printf("Targeted core clock should be within [%d - %d]\n",
+                    PLL_FREQ_MIN / PRESC_MAX, PLL_FREQ_MAX);
+        return;
+    }
+
+    // find the ahb divider
+    if (ahb_div > AHB_DIV_MAX) {
+        diag_printf("Invalid AHB divider: %d. Maximum value is %d\n",
+                    ahb_div, AHB_DIV_MAX);
+        return;
+    }
+    if (ahb_div == 0) {
+        // no HCLK divider specified
+        for (ahb_div = 1; ; ahb_div++) {
+            if ((core_clk / ahb_div) <= AHB_CLK_MAX) {
+                break;
+            }
+        }
+    }
+    if (ahb_div > AHB_DIV_MAX || (core_clk / ahb_div) > AHB_CLK_MAX) {
+        diag_printf("Can't make AHB=%d since max=%d\n",
+                    core_clk / ahb_div, AHB_CLK_MAX);
+        return;
+    }
+
+    // find the ipg divider
+    ahb_clk = core_clk / ahb_div;
+    if (ipg_div > IPG_DIV_MAX) {
+        diag_printf("Invalid IPG divider: %d. Maximum value is %d\n",
+                    ipg_div, IPG_DIV_MAX);
+        return;
+    }
+    if (ipg_div == 0) {
+        ipg_div++;          // At least =1
+        if (ahb_clk > IPG_CLK_MAX)
+            ipg_div++;      // Make it =2
+    }
+    if (ipg_div > IPG_DIV_MAX || (ahb_clk / ipg_div) > IPG_CLK_MAX) {
+        diag_printf("Can't make IPG=%d since max=%d\n",
+                    (ahb_clk / ipg_div), IPG_CLK_MAX);
+        return;
+    }
+    ipg_clk = ahb_clk / ipg_div;
+
+    diag_printf("Trying to set core=%d ahb=%d ipg=%d...\n",
+                core_clk, ahb_clk, ipg_clk);
+
+    // stop the serial to be ready to adjust the clock
+    hal_delay_us(100000);
+    cyg_hal_plf_serial_stop();
+    // adjust the clock
+    ret = configure_clock(PLL_REF_CLK, core_clk, ahb_div, ipg_div);
+    // restart the serial driver
+    cyg_hal_plf_serial_init();
+    hal_delay_us(100000);
+
+    if (ret != 0) {
+        diag_printf("Failed to setup clock: %d\n", ret);
+        return;
+    }
+    diag_printf("\n<<<New clock setting>>>\n");
+
+    // Now printing clocks
+print_clock:
+#endif
+    diag_printf("\nPLL1\t\tPLL2\t\tPLL3\n");
+    diag_printf("========================================\n");
+    diag_printf("%-16d%-16d%-16d\n\n", pll_clock(PLL1), pll_clock(PLL2),
+                pll_clock(PLL3));
+    diag_printf("CPU\t\tAHB\t\tIPG\t\tEMI_CLK\n");
+    diag_printf("========================================================\n");
+    diag_printf("%-16d%-16d%-16d%-16d\n\n",
+                get_main_clock(CPU_CLK),
+                get_main_clock(AHB_CLK),
+                get_main_clock(IPG_CLK),
+                get_main_clock(DDR_CLK));
+
+    diag_printf("NFC\t\tUSB\n");
+    diag_printf("========================================\n");
+    diag_printf("%-16d%-16d\n\n",
+                get_main_clock(NFC_CLK),
+                get_main_clock(USB_CLK));
+
+    diag_printf("UART1-3\t\tSSI1\t\tSSI2\t\tCSI\n");
+    diag_printf("===========================================");
+    diag_printf("=============\n");
+
+    diag_printf("%-16d%-16d%-16d%-16d\n\n",
+                get_peri_clock(UART1_BAUD),
+                get_peri_clock(SSI1_BAUD),
+                get_peri_clock(SSI2_BAUD),
+                get_peri_clock(CSI_BAUD));
+
+    diag_printf("MSTICK1\t\tMSTICK2\t\tSPI\n");
+    diag_printf("===========================================");
+    diag_printf("=============\n");
+
+    diag_printf("%-16d%-16d%-16d\n\n",
+                get_peri_clock(MSTICK1_CLK),
+                get_peri_clock(MSTICK2_CLK),
+                get_peri_clock(SPI1_CLK));
+#if 0
+    diag_printf("IPG_PERCLK as baud clock for: UART1-5, I2C, OWIRE, SDHC");
+    if (((readl(EPIT1_BASE_ADDR) >> 24) & 0x3) == 0x2) {
+        diag_printf(", EPIT");
+    }
+    if (((readl(GPT1_BASE_ADDR) >> 6) & 0x7) == 0x2) {
+        diag_printf("GPT,");
+    }
+#endif
+    diag_printf("\n");
+
+}
+
+/*!
+ * This function returns the PLL output value in Hz based on pll.
+ */
+u32 pll_clock(enum plls pll)
+{
+    u64 mfi, mfn, mfd, pdf, ref_clk, pll_out, sign;
+    u64 dp_ctrl, dp_op, dp_mfd, dp_mfn, clk_sel;
+    u8 dbl = 0;
+
+    dp_ctrl = pll_base[pll][PLL_DP_CTL >> 2];
+    clk_sel = MXC_GET_FIELD(dp_ctrl, 2, 8);
+    ref_clk = fixed_mfd[clk_sel].ref_clk_hz;
+
+    if ((pll_base[pll][PLL_DP_CTL >> 2] & 0x80) == 0) {
+        dp_op = pll_base[pll][PLL_DP_OP >> 2];
+        dp_mfd = pll_base[pll][PLL_DP_MFD >> 2];
+        dp_mfn = pll_base[pll][PLL_DP_MFN >> 2];
+    } else {
+        dp_op = pll_base[pll][PLL_DP_HFS_OP >> 2];
+        dp_mfd = pll_base[pll][PLL_DP_HFS_MFD >> 2];
+        dp_mfn = pll_base[pll][PLL_DP_HFS_MFN >> 2];
+    }
+    pdf = dp_op & 0xF;
+    mfi = (dp_op >> 4) & 0xF;
+    mfi = (mfi <= 5) ? 5: mfi;
+    mfd = dp_mfd & 0x07FFFFFF;
+    mfn = dp_mfn & 0x07FFFFFF;
+
+    sign = (mfn < 0x4000000) ? 0: 1;
+    mfn = (mfn <= 0x4000000) ? mfn: (0x8000000 - mfn);
+
+    dbl = ((dp_ctrl >> 12) & 0x1) + 1;
+
+    dbl = dbl * 2;
+    if (sign == 0) {
+        pll_out = (dbl * ref_clk * mfi + ((dbl * ref_clk * mfn) / (mfd + 1))) /
+                  (pdf + 1);
+    } else {
+        pll_out = (dbl * ref_clk * mfi - ((dbl * ref_clk * mfn) / (mfd + 1))) /
+                  (pdf + 1);
+    }
+
+    return (u32)pll_out;
+}
+
+// The clocks are on by default. But need to setup the IOMUX
+void clock_spi_enable(unsigned int spi_clk)
+{
+    // Take care of  SPI2
+    writel(0x0, IOMUXC_BASE_ADDR + 0x14C);
+    writel(0x1, IOMUXC_BASE_ADDR + 0x3AC);
+    writel(0x100, IOMUXC_BASE_ADDR + 0x494);
+    writel(0x0, IOMUXC_BASE_ADDR + 0x148);
+    writel(0x1, IOMUXC_BASE_ADDR + 0x3A8);
+    writel(0x3, IOMUXC_BASE_ADDR + 0x168);
+    writel(0x180, IOMUXC_BASE_ADDR + 0x3C8);
+    writel(0x0, IOMUXC_BASE_ADDR + 0x158);
+    writel(0x101, IOMUXC_BASE_ADDR + 0x3B8);
+    writel(0x0, IOMUXC_BASE_ADDR + 0x150);
+    writel(0x1, IOMUXC_BASE_ADDR + 0x3B0);
+    writel(0x100, IOMUXC_BASE_ADDR + 0x490);
+}
+
+/*!
+ * This function returns the low power audio clock.
+ */
+u32 get_lp_apm(void)
+{
+    u32 ret_val = 0;
+    u32 ccsr = readl(CCM_BASE_ADDR + CLKCTL_CCSR);
+
+    if (((ccsr >> 9) & 1) == 0) {
+        ret_val = FREQ_24MHZ;
+    } else {
+        ret_val = FREQ_32000HZ;
+    }
+    return ret_val;
+}
+
+/*!
+ * This function returns the periph_clk.
+ */
+u32 get_periph_clk(void)
+{
+    u32 cbcdr6 = readl(CCM_BASE_ADDR + CLKCTL_CBCDR6);
+    u32 camr = readl(CCM_BASE_ADDR + CLKCTL_CAMR);
+    u32 ret_val = 0, clk_sel;
+
+    if (((cbcdr6 >> 4) & 1) == 0) {
+        ret_val = pll_clock(PLL2);
+    } else {
+        clk_sel = (camr >> 12) & 3;
+        if (clk_sel == 0) {
+            ret_val = pll_clock(PLL1);
+        } else if (clk_sel == 1) {
+            ret_val = pll_clock(PLL3);
+        } else if (clk_sel == 2) {
+            ret_val = get_lp_apm();
+        }
+    }
+
+    return ret_val;
+}
+
+/*!
+ * This function returns the emi_core_clk_root clock.
+ */
+u32 get_emi_core_clk(void)
+{
+    u32 cbcdr6 = readl(CCM_BASE_ADDR + CLKCTL_CBCDR6);
+    u32 cbcdr2 = readl(CCM_BASE_ADDR + CLKCTL_CBCDR2);
+    u32 clk_sel = 0, pdf = 0, max_pdf = 0, peri_clk = 0, ahb_clk = 0;
+    u32 ret_val = 0;
+
+    max_pdf = (cbcdr2 >> 10) & 0x7;
+    peri_clk = get_periph_clk();
+    ahb_clk = peri_clk / (max_pdf + 1);
+
+    pdf = cbcdr6 & 0x7;
+    clk_sel = (cbcdr6 >> 3) & 1;
+    if (clk_sel == 0) {
+        ret_val = peri_clk / (pdf + 1);
+    } else {
+        ret_val = ahb_clk / (pdf + 1);
+    }
+    return ret_val;
+}
+
+// The clocks are on by default. But need to setup the IOMUX
+void mxc_i2c_init(unsigned int module_base)
+{
+    unsigned int val, reg;
+
+    switch (module_base) {
+    case I2C_BASE_ADDR:
+        reg = IOMUXC_BASE_ADDR + 0xA0;
+        val = (readl(reg) & 0xFFFF0000) | 0x1212; // func mode
+        writel(val, reg);
+        break;
+    case I2C2_BASE_ADDR:
+        reg = IOMUXC_BASE_ADDR + 0x210; // i2c SCL
+        writel(0x2, reg);
+        reg = IOMUXC_BASE_ADDR + 0x214; // i2c SDA
+        writel(0x2, reg);
+        break;
+    case I2C3_BASE_ADDR:
+        reg = IOMUXC_BASE_ADDR + 0x84;
+        val = (readl(reg) & 0xFFFFFF00) | 0x24; // alt mode 1
+        writel(val, reg);
+        reg = IOMUXC_BASE_ADDR + 0x80;
+        val = (readl(reg) & 0x00FFFFFF) | 0x24000000; // alt mode 1
+        writel(val, reg);
+        break;
+    default:
+        diag_printf("Invalide I2C base: 0x%x\n", module_base);
+        return;
+    }
+}
+
+/*!
+ * This function returns the main clock value in Hz.
+ */
+u32 get_main_clock(enum main_clocks clk)
+{
+    u32 mcu_podf, max_pdf, ipg_pdf, nfc_pdf, clk_sel;
+    u32 pll, ret_val = 0;
+    u32 cacrr = readl(CCM_BASE_ADDR + CLKCTL_CACRR);
+    u32 cbcdr2 = readl(CCM_BASE_ADDR + CLKCTL_CBCDR2);
+    u32 cbcdr3 = readl(CCM_BASE_ADDR + CLKCTL_CBCDR3);
+    u32 cbcdr4 = readl(CCM_BASE_ADDR + CLKCTL_CBCDR4);
+    u32 cbcdr5 = readl(CCM_BASE_ADDR + CLKCTL_CBCDR5);
+    u32 cbcdr7 = readl(CCM_BASE_ADDR + CLKCTL_CBCDR7);
+    u32 camr = readl(CCM_BASE_ADDR + CLKCTL_CAMR);
+
+    switch (clk) {
+    case CPU_CLK:
+        mcu_podf = cacrr & 0x7;
+        pll = pll_clock(PLL1);
+        ret_val = pll / (mcu_podf + 1);
+        break;
+    case AHB_CLK:
+        max_pdf = (cbcdr2 >> 10) & 0x7;
+        pll = get_periph_clk();
+        ret_val = pll / (max_pdf + 1);
+        break;
+    case IPG_CLK:
+        max_pdf = (cbcdr2 >> 10) & 0x7;
+        ipg_pdf = (cbcdr2 >> 8) & 0x3;
+        pll = get_periph_clk();
+        ret_val = pll / ((max_pdf + 1) * (ipg_pdf + 1));
+        break;
+    case IPG_PER_CLK:
+#if 0
+        clk_sel = ccmr & (1 << 24);
+        pdf = (mpdr0 >> 16) & 0x1F;
+        if (clk_sel != 0) {
+            // get the ipg_clk
+            max_pdf = (reg >> 3) & 0x7;
+            ipg_pdf = (reg >> 6) & 0x3;
+            pll = pll_clock(PLL1);
+            ret_val = pll / ((max_pdf + 1) * (ipg_pdf + 1));
+        } else {
+            ret_val = pll_clock(PLL2) / (pdf + 1);
+        }
+#endif
+        break;
+    case DDR_CLK:
+        clk_sel = (camr >> 10) & 3;
+        if (clk_sel == 0) {
+            ret_val = get_periph_clk() / ((cbcdr3 & 7) + 1);
+        } else if (clk_sel == 1) {
+            ret_val = get_periph_clk() / ((cbcdr4 & 7) + 1);
+        } else if (clk_sel == 2) {
+            ret_val = get_periph_clk() / ((cbcdr5 & 7) + 1);
+        } else if (clk_sel == 3) {
+            ret_val = get_emi_core_clk();
+        }
+        break;
+    case NFC_CLK:
+        nfc_pdf = cbcdr7 & 0x7;
+        pll = get_emi_core_clk();
+        /* AHB/nfc_pdf */
+        ret_val = pll / (nfc_pdf + 1);
+        break;
+    case USB_CLK:
+#if 0
+        usb_prdf = reg1 >> 30;
+        usb_podf = (reg1 >> 27) & 0x7;
+        pll = pll_clock(PLL2);
+        ret_val = pll / ((usb_prdf + 1) * (usb_podf + 1));
+#endif
+        break;
+    default:
+        diag_printf("Unknown clock: %d\n", clk);
+        break;
+    }
+
+    return ret_val;
+}
+
+/*!
+ * This function returns the peripheral clock value in Hz.
+ */
+u32 get_peri_clock(enum peri_clocks clk)
+{
+    u32 ret_val = 0, pdf, pre_pdf, clk_sel;
+    u32 cscmr1 = readl(CCM_BASE_ADDR + CLKCTL_CSCMR1);
+    u32 cscdr1 = readl(CCM_BASE_ADDR + CLKCTL_CSCDR1);
+    u32 cscdr2 = readl(CCM_BASE_ADDR + CLKCTL_CSCDR2);
+    u32 cs1cdr = readl(CCM_BASE_ADDR + CLKCTL_CS1CDR);
+    u32 cs2cdr = readl(CCM_BASE_ADDR + CLKCTL_CS2CDR);
+
+    switch (clk) {
+    case UART1_BAUD:
+    case UART2_BAUD:
+    case UART3_BAUD:
+        pre_pdf = (cscdr1 >> 3) & 0x7;
+        pdf = cscdr1 & 0x7;
+        clk_sel = (cscmr1 >> 24) & 3;
+        if (clk_sel == 0) {
+            ret_val = pll_clock(PLL1) / ((pre_pdf + 1) * (pdf + 1));
+        } else if (clk_sel == 1) {
+            ret_val = pll_clock(PLL2) / ((pre_pdf + 1) * (pdf + 1));
+        } else if (clk_sel == 2) {
+            ret_val = pll_clock(PLL3) / ((pre_pdf + 1) * (pdf + 1));
+        }
+        break;
+    case SSI1_BAUD:
+        pre_pdf = (cs1cdr >> 6) & 0x7;
+        pdf = cs1cdr & 0x3F;
+        clk_sel = (cscmr1 >> 14) & 3;
+        if (clk_sel == 0) {
+            ret_val = pll_clock(PLL1) / ((pre_pdf + 1) * (pdf + 1));
+        } else if (clk_sel == 0x1) {
+            ret_val = pll_clock(PLL2) / ((pre_pdf + 1) * (pdf + 1));
+        } else if (clk_sel == 0x2) {
+            ret_val = pll_clock(PLL3) / ((pre_pdf + 1) * (pdf + 1));
+        } else {
+            diag_printf("Error: Use reserved value for SSI1!\n");
+            ret_val = 0;
+        }
+        break;
+    case SSI2_BAUD:
+        pre_pdf = (cs2cdr >> 6) & 0x7;
+        pdf = cs2cdr & 0x3F;
+        clk_sel = (cscmr1 >> 12) & 3;
+        if (clk_sel == 0) {
+            ret_val = pll_clock(PLL1) / ((pre_pdf + 1) * (pdf + 1));
+        } else if (clk_sel == 0x1) {
+            ret_val = pll_clock(PLL2) / ((pre_pdf + 1) * (pdf + 1));
+        } else if (clk_sel == 0x2) {
+            ret_val = pll_clock(PLL3) / ((pre_pdf + 1) * (pdf + 1));
+        } else {
+            diag_printf("Error: Use reserved value for SSI2!\n");
+            ret_val = 0;
+        }
+        break;
+    case CSI_BAUD:
+#if 0
+        clk_sel = ccmr & (1 << 25);
+        pdf = (mpdr0 >> 23) & 0x1FF;
+        ret_val = (clk_sel != 0) ? (pll_clock(PLL3) / (pdf + 1)) :
+                  (pll_clock(PLL2) / (pdf + 1));
+#endif
+        break;
+    case MSTICK1_CLK:
+#if 0
+        pdf = mpdr2 & 0x3F;
+        ret_val = pll_clock(PLL2) / (pdf + 1);
+#endif
+        break;
+    case MSTICK2_CLK:
+#if 0
+        pdf = (mpdr2 >> 7) & 0x3F;
+        ret_val = pll_clock(PLL2) / (pdf + 1);
+#endif
+        break;
+    case SPI1_CLK:
+    case SPI2_CLK:
+        pre_pdf = (cscdr2 >> 25) & 0x7;
+        pdf = (cscdr2 >> 19) & 0x3F;
+        clk_sel = (cscmr1 >> 4) & 3;
+        if (clk_sel == 0) {
+            ret_val = pll_clock(PLL1) / ((pre_pdf + 1) * (pdf + 1));
+        } else if (clk_sel == 1) {
+            ret_val = pll_clock(PLL2) / ((pre_pdf + 1) * (pdf + 1));
+        } else if (clk_sel == 2) {
+            ret_val = pll_clock(PLL3) / ((pre_pdf + 1) * (pdf + 1));
+        }
+        break;
+    default:
+        diag_printf("%s(): This clock: %d not supported yet \n",
+                    __FUNCTION__, clk);
+        break;
+    }
+
+    return ret_val;
+}
+
+RedBoot_cmd("clko",
+            "Select clock source for CLKO (J11 on the CPU daughter card)",
+            " Default is 1/8 of ARM core\n\
+          <0> - display current clko selection \n\
+          <1> - mpl_dpdgck_clk (MPLL) \n\
+          <2> - ipg_clk_ccm (IPG) \n\
+          <3> - upl_dpdgck_clk (UPLL) \n\
+          <4> - pll_ref_clk \n\
+          <5> - fpm_ckil512_clk \n\
+          <6> - ipg_clk_ahb_arm (AHB) \n\
+          <7> - ipg_clk_arm (ARM) \n\
+          <8> - spl_dpdgck_clk (SPLL) \n\
+          <9> - ckih \n\
+          <10> - ipg_clk_ahb_emi_clk \n\
+          <11> - ipg_clk_ipu_hsp \n\
+          <12> - ipg_clk_nfc_20m \n\
+          <13> - ipg_clk_perclk_uart1 (IPG_PER)",
+            clko
+           );
+
+static u8* clko_name[] ={
+    "NULL",
+    "1/8 of mpl_dpdgck_clk (MPLL)",
+    "ipg_clk_ccm (IPG)",
+    "1/8 of upl_dpdgck_clk (UPLL)",
+    "pll_ref_clk",
+    "fpm_ckil512_clk",
+    "ipg_clk_ahb_arm (AHB)",
+    "1/8 of ipg_clk_arm (ARM)",
+    "1/8 of spl_dpdgck_clk (SPLL)",
+    "ckih",
+    "ipg_clk_ahb_emi_clk",
+    "ipg_clk_ipu_hsp",
+    "ipg_clk_nfc_20m",
+    "ipg_clk_perclk_uart1 (IPG_PER)",
+};
+
+#define CLKO_MAX_INDEX          (sizeof(clko_name) / sizeof(u8*))
+
+static void clko(int argc,char *argv[])
+{
+    u32 action = 0, cosr;
+
+    if (!scan_opts(argc, argv, 1, 0, 0, (void*) &action,
+                   OPTION_ARG_TYPE_NUM, "action"))
+        return;
+
+    if (action >= CLKO_MAX_INDEX) {
+        diag_printf("%d is not supported\n\n", action);
+        return;
+    }
+
+    cosr = readl(CCM_BASE_ADDR + CLKCTL_COSR);
+
+    if (action != 0) {
+        cosr = (cosr & (~0x1FF)) + action - 1;
+        if (action == 1 || action == 3 || action == 7 || action == 8) {
+            cosr |= (0x3 << 6); // make it divided by 8
+        }
+        writel(cosr, CCM_BASE_ADDR + CLKCTL_COSR);
+        diag_printf("Set clko to ");
+    }
+
+    cosr = readl(CCM_BASE_ADDR + CLKCTL_COSR);
+    diag_printf("%s\n", clko_name[(cosr & 0xF) + 1]);
+    diag_printf("COSR register[0x%x] = 0x%x\n",
+                (CCM_BASE_ADDR + CLKCTL_COSR), cosr);
+}
+
+#ifdef L2CC_ENABLED
+/*
+ * This command is added for some simple testing only. It turns on/off
+ * L2 cache regardless of L1 cache state. The side effect of this is
+ * when doing any flash operations such as "fis init", the L2
+ * will be turned back on along with L1 caches even though it is off
+ * by using this command.
+ */
+RedBoot_cmd("L2",
+            "L2 cache",
+            "[ON | OFF]",
+            do_L2_caches
+           );
+
+void do_L2_caches(int argc, char *argv[])
+{
+    u32 oldints;
+    int L2cache_on=0;
+
+    if (argc == 2) {
+        if (strcasecmp(argv[1], "on") == 0) {
+            HAL_DISABLE_INTERRUPTS(oldints);
+            HAL_ENABLE_L2();
+            HAL_RESTORE_INTERRUPTS(oldints);
+        } else if (strcasecmp(argv[1], "off") == 0) {
+            HAL_DISABLE_INTERRUPTS(oldints);
+            HAL_CLEAN_INVALIDATE_L2();
+            HAL_DISABLE_L2();
+            HAL_RESTORE_INTERRUPTS(oldints);
+        } else {
+            diag_printf("Invalid L2 cache mode: %s\n", argv[1]);
+        }
+    } else {
+        HAL_L2CACHE_IS_ENABLED(L2cache_on);
+        diag_printf("L2 cache: %s\n", L2cache_on?"On":"Off");
+    }
+}
+#endif //L2CC_ENABLED
+
+#define IIM_ERR_SHIFT       8
+#define POLL_FUSE_PRGD      (IIM_STAT_PRGD | (IIM_ERR_PRGE << IIM_ERR_SHIFT))
+#define POLL_FUSE_SNSD      (IIM_STAT_SNSD | (IIM_ERR_SNSE << IIM_ERR_SHIFT))
+
+static void fuse_op_start(void)
+{
+    /* Do not generate interrupt */
+    writel(0, IIM_BASE_ADDR + IIM_STATM_OFF);
+    // clear the status bits and error bits
+    writel(0x3, IIM_BASE_ADDR + IIM_STAT_OFF);
+    writel(0xFE, IIM_BASE_ADDR + IIM_ERR_OFF);
+}
+
+/*
+ * The action should be either:
+ *          POLL_FUSE_PRGD
+ * or:
+ *          POLL_FUSE_SNSD
+ */
+static int poll_fuse_op_done(int action)
+{
+
+    u32 status, error;
+
+    if (action != POLL_FUSE_PRGD && action != POLL_FUSE_SNSD) {
+        diag_printf("%s(%d) invalid operation\n", __FUNCTION__, action);
+        return -1;
+    }
+
+    /* Poll busy bit till it is NOT set */
+    while ((readl(IIM_BASE_ADDR + IIM_STAT_OFF) & IIM_STAT_BUSY) != 0 ) {
+    }
+
+    /* Test for successful write */
+    status = readl(IIM_BASE_ADDR + IIM_STAT_OFF);
+    error = readl(IIM_BASE_ADDR + IIM_ERR_OFF);
+
+    if ((status & action) != 0 && (error & (action >> IIM_ERR_SHIFT)) == 0) {
+        if (error) {
+            diag_printf("Even though the operation seems successful...\n");
+            diag_printf("There are some error(s) at addr=0x%x: 0x%x\n",
+                        (IIM_BASE_ADDR + IIM_ERR_OFF), error);
+        }
+        return 0;
+    }
+    diag_printf("%s(%d) failed\n", __FUNCTION__, action);
+    diag_printf("status address=0x%x, value=0x%x\n",
+                (IIM_BASE_ADDR + IIM_STAT_OFF), status);
+    diag_printf("There are some error(s) at addr=0x%x: 0x%x\n",
+                (IIM_BASE_ADDR + IIM_ERR_OFF), error);
+    return -1;
+}
+
+static void sense_fuse(int bank, int row, int bit)
+{
+    int addr, addr_l, addr_h, reg_addr;
+
+    fuse_op_start();
+
+    addr = ((bank << 11) | (row << 3) | (bit & 0x7));
+    /* Set IIM Program Upper Address */
+    addr_h = (addr >> 8) & 0x000000FF;
+    /* Set IIM Program Lower Address */
+    addr_l = (addr & 0x000000FF);
+
+#ifdef IIM_FUSE_DEBUG
+    diag_printf("%s: addr_h=0x%x, addr_l=0x%x\n",
+                __FUNCTION__, addr_h, addr_l);
+#endif
+    writel(addr_h, IIM_BASE_ADDR + IIM_UA_OFF);
+    writel(addr_l, IIM_BASE_ADDR + IIM_LA_OFF);
+    /* Start sensing */
+    writel(0x8, IIM_BASE_ADDR + IIM_FCTL_OFF);
+    if (poll_fuse_op_done(POLL_FUSE_SNSD) != 0) {
+        diag_printf("%s(bank: %d, row: %d, bit: %d failed\n",
+                    __FUNCTION__, bank, row, bit);
+    }
+    reg_addr = IIM_BASE_ADDR + IIM_SDAT_OFF;
+    diag_printf("fuses at (bank:%d, row:%d) = 0x%x\n", bank, row, readl(reg_addr));
+}
+
+void do_fuse_read(int argc, char *argv[])
+{
+    int bank, row;
+
+    if (argc == 1) {
+        diag_printf("Useage: fuse_read <bank> <row>\n");
+        return;
+    } else if (argc == 3) {
+        if (!parse_num(*(&argv[1]), (unsigned long *)&bank, &argv[1], " ")) {
+                diag_printf("Error: Invalid parameter\n");
+            return;
+        }
+        if (!parse_num(*(&argv[2]), (unsigned long *)&row, &argv[2], " ")) {
+                diag_printf("Error: Invalid parameter\n");
+                return;
+            }
+
+        diag_printf("Read fuse at bank:%d row:%d\n", bank, row);
+        sense_fuse(bank, row, 0);
+
+    } else {
+        diag_printf("Passing in wrong arguments: %d\n", argc);
+        diag_printf("Useage: fuse_read <bank> <row>\n");
+    }
+}
+
+/* Blow fuses based on the bank, row and bit positions (all 0-based)
+*/
+static int fuse_blow(int bank,int row,int bit)
+{
+    int addr, addr_l, addr_h, ret = -1;
+
+    fuse_op_start();
+
+    /* Disable IIM Program Protect */
+    writel(0xAA, IIM_BASE_ADDR + IIM_PREG_P_OFF);
+
+    addr = ((bank << 11) | (row << 3) | (bit & 0x7));
+    /* Set IIM Program Upper Address */
+    addr_h = (addr >> 8) & 0x000000FF;
+    /* Set IIM Program Lower Address */
+    addr_l = (addr & 0x000000FF);
+
+#ifdef IIM_FUSE_DEBUG
+    diag_printf("blowing addr_h=0x%x, addr_l=0x%x\n", addr_h, addr_l);
+#endif
+
+    writel(addr_h, IIM_BASE_ADDR + IIM_UA_OFF);
+    writel(addr_l, IIM_BASE_ADDR + IIM_LA_OFF);
+    /* Start Programming */
+    writel(0x31, IIM_BASE_ADDR + IIM_FCTL_OFF);
+    if (poll_fuse_op_done(POLL_FUSE_PRGD) == 0) {
+        ret = 0;
+    }
+
+    /* Enable IIM Program Protect */
+    writel(0x0, IIM_BASE_ADDR + IIM_PREG_P_OFF);
+    return ret;
+}
+
+/*
+ * This command is added for burning IIM fuses
+ */
+RedBoot_cmd("fuse_read",
+            "read some fuses",
+            "<bank> <row>",
+            do_fuse_read
+           );
+
+RedBoot_cmd("fuse_blow",
+            "blow some fuses",
+            "<bank> <row> <value>",
+            do_fuse_blow
+           );
+
+#define         INIT_STRING              "12345678"
+static char ready_to_blow[] = INIT_STRING;
+
+void quick_itoa(u32 num, char *a)
+{
+    int i, j, k;
+    for (i = 0; i <= 7; i++) {
+        j = (num >> (4 * i)) & 0xF;
+        k = (j < 10) ? '0' : ('a' - 0xa);
+        a[i] = j + k;
+    }
+}
+
+void do_fuse_blow(int argc, char *argv[])
+{
+    int bank, row, value, i;
+
+    if (argc == 1) {
+        diag_printf("It is too dangeous for you to use this command.\n");
+        return;
+    } else if (argc == 2) {
+        if (strcasecmp(argv[1], "nandboot") == 0) {
+            quick_itoa(readl(EPIT_BASE_ADDR + EPITCNR), ready_to_blow);
+            diag_printf("%s\n", ready_to_blow);
+        }
+        return;
+    } else if (argc == 3) {
+        if (strcasecmp(argv[1], "nandboot") == 0 &&
+            strcasecmp(argv[2], ready_to_blow) == 0) {
+#if defined(CYGPKG_HAL_ARM_MXC91131) || defined(CYGPKG_HAL_ARM_MX21) || defined(CYGPKG_HAL_ARM_MX27) || defined(CYGPKG_HAL_ARM_MX31)
+            diag_printf("No need to blow any fuses for NAND boot on this platform\n\n");
+#else
+            diag_printf("Ready to burn NAND boot fuses\n");
+            if (fuse_blow(0, 16, 1) != 0 || fuse_blow(0, 16, 7) != 0) {
+                diag_printf("NAND BOOT fuse blown failed miserably ...\n");
+            } else {
+                diag_printf("NAND BOOT fuse blown successfully ...\n");
+            }
+        } else {
+            diag_printf("Not ready: %s, %s\n", argv[1], argv[2]);
+#endif
+        }
+    } else if (argc == 4) {
+        if (!parse_num(*(&argv[1]), (unsigned long *)&bank, &argv[1], " ")) {
+                diag_printf("Error: Invalid parameter\n");
+                return;
+        }
+        if (!parse_num(*(&argv[2]), (unsigned long *)&row, &argv[2], " ")) {
+                diag_printf("Error: Invalid parameter\n");
+                return;
+        }
+        if (!parse_num(*(&argv[3]), (unsigned long *)&value, &argv[3], " ")) {
+                diag_printf("Error: Invalid parameter\n");
+                return;
+        }
+
+        diag_printf("Blowing fuse at bank:%d row:%d value:%d\n",
+                    bank, row, value);
+        for (i = 0; i < 8; i++) {
+            if (((value >> i) & 0x1) == 0) {
+                continue;
+            }
+            if (fuse_blow(bank, row, i) != 0) {
+                diag_printf("fuse_blow(bank: %d, row: %d, bit: %d failed\n",
+                            bank, row, i);
+            } else {
+                diag_printf("fuse_blow(bank: %d, row: %d, bit: %d successful\n",
+                            bank, row, i);
+            }
+        }
+        sense_fuse(bank, row, 0);
+
+    } else {
+        diag_printf("Passing in wrong arguments: %d\n", argc);
+    }
+    /* Reset to default string */
+    strcpy(ready_to_blow, INIT_STRING);;
+}
+
+/* precondition: m>0 and n>0.  Let g=gcd(m,n). */
+int gcd(int m, int n)
+{
+    int t;
+    while(m > 0) {
+        if(n > m) {t = m; m = n; n = t;} /* swap */
+        m -= n;
+    }
+    return n;
+}
+
+#define CLOCK_SRC_DETECT_MS         100
+#define CLOCK_IPG_DEFAULT           66500000
+#define CLOCK_SRC_DETECT_MARGIN     500000
+void mxc_show_clk_input(void)
+{
+//    u32 c1, c2, diff, ipg_real, num = 0;
+
+    return;  // FIXME
+#if 0
+    switch (prcs) {
+    case 0x01:
+        diag_printf("FPM enabled --> 32KHz input source\n");
+        return;
+    case 0x02:
+        break;
+    default:
+        diag_printf("Error %d: unknown clock source %d\n", __LINE__, prcs);
+        return;
+    }
+
+    // enable GPT with IPG clock input
+    writel(0x241, GPT_BASE_ADDR + GPTCR);
+    // prescaler = 1
+    writel(0, GPT_BASE_ADDR + GPTPR);
+
+    c1 = readl(GPT_BASE_ADDR + GPTCNT);
+    // use 32KHz input clock to get the delay
+    hal_delay_us(CLOCK_SRC_DETECT_MS * 1000);
+    c2 = readl(GPT_BASE_ADDR + GPTCNT);
+    diff = (c2 > c1) ? (c2 - c1) : (0xFFFFFFFF - c1 + c2);
+
+    ipg_real = diff * (1000 / CLOCK_SRC_DETECT_MS);
+
+    if (num != 0) {
+        diag_printf("Error: Actural clock input is %d MHz\n", num);
+        diag_printf("       ipg_real=%d CLOCK_IPG_DEFAULT - CLOCK_SRC_DETECT_MARGIN=%d\n\n",
+                    ipg_real, CLOCK_IPG_DEFAULT - CLOCK_SRC_DETECT_MARGIN);
+        hal_delay_us(2000000);
+    } else {
+        diag_printf("ipg_real=%d CLOCK_IPG_DEFAULT - CLOCK_SRC_DETECT_MARGIN=%d\n\n",
+                    ipg_real, CLOCK_IPG_DEFAULT - CLOCK_SRC_DETECT_MARGIN);
+    }
+#endif
+}
+
+RedBoot_init(mxc_show_clk_input, RedBoot_INIT_LAST);
+
+void imx_power_mode(int mode)
+{
+    volatile unsigned int val;
+    switch (mode) {
+    case 2:
+        writel(0x0000030f, GPC_PGR);
+        writel(0x1, SRPGCR_EMI);
+        writel(0x1, SRPGCR_ARM);
+        writel(0x1, PGC_PGCR_VPU);
+        writel(0x1, PGC_PGCR_IPU);
+
+
+    case 1:
+        // stop mode - from validation code
+        // Set DSM_INT_HOLDOFF bit in TZIC
+        // If the TZIC didn't write the bit then there was interrupt pending
+        // It will be serviced while we're in the loop
+        // So we write to this bit again
+        while (readl(INTC_BASE_ADDR + 0x14) == 0) {
+            writel(1, INTC_BASE_ADDR + 0x14);
+            // Wait few cycles
+            __asm("nop");
+            __asm("nop");
+            __asm("nop");
+            __asm("nop");
+            __asm("nop");
+            __asm("nop");
+            __asm("nop");
+        }
+        diag_printf("Entering stop mode\n");
+        val = readl(CCM_BASE_ADDR + 0x74);
+        val = (val & 0xfffffffc) | 0x2; // set STOP mode
+        writel(val, CCM_BASE_ADDR + 0x74);
+        val = readl(PLATFORM_LPC_REG);
+        writel(val | (1 << 16), PLATFORM_LPC_REG);// ENABLE DSM in ELBOW submodule of ARM platform
+        writel(val | (1 << 17), PLATFORM_LPC_REG);// ENABLE DSM in ELBOW submodule of ARM platform
+        break;
+    default:
+        break;
+    }
+
+    hal_delay_us(50);
+
+    asm("mov r1, #0");
+    asm("mcr p15, 0, r1, c7, c0, 4");
+}
+
+void do_power_mode(int argc, char *argv[])
+{
+    int mode;
+
+    if (argc == 1) {
+        diag_printf("Useage: power_mode <mode>\n");
+        return;
+    } else if (argc == 2) {
+        if (!parse_num(*(&argv[1]), (unsigned long *)&mode, &argv[1], " ")) {
+                diag_printf("Error: Invalid parameter\n");
+            return;
+        }
+        diag_printf("Entering power mode: %d\n", mode);
+        imx_power_mode(mode);
+
+    } else {
+        diag_printf("Passing in wrong arguments: %d\n", argc);
+        diag_printf("Useage: power_mode <mode>\n");
+    }
+}
+
+/*
+ * This command is added for burning IIM fuses
+ */
+RedBoot_cmd("power_mode",
+            "Enter various power modes:",
+            "\n\
+	    <0> - WAIT\n\
+	    <1> - SRPG\n\
+	    <2> - STOP\n\
+	    <3> - STOP with Power-Gating\n\
+	    -- need reset after issuing the command",
+            do_power_mode
+           );
+
diff -urN -x CVS -x doc -x lwip_tcpip -x calmrisc16 -x calmrisc32 ecos_20050912/packages/hal/arm/mx51/var/current/src/soc_diag.c ecos_base/packages/hal/arm/mx51/var/current/src/soc_diag.c
--- ecos_20050912/packages/hal/arm/mx51/var/current/src/soc_diag.c	1969-12-31 18:00:00.000000000 -0600
+++ ecos_base/packages/hal/arm/mx51/var/current/src/soc_diag.c	2008-03-31 18:32:56.000000000 -0500
@@ -0,0 +1,739 @@
+/*=============================================================================
+//
+//      hal_diag.c
+//
+//      HAL diagnostic output code
+//
+//=============================================================================
+//####ECOSGPLCOPYRIGHTBEGIN####
+// -------------------------------------------
+// This file is part of eCos, the Embedded Configurable Operating System.
+// Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+//
+// eCos is free software; you can redistribute it and/or modify it under
+// the terms of the GNU General Public License as published by the Free
+// Software Foundation; either version 2 or (at your option) any later version.
+//
+// eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with eCos; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+//
+// As a special exception, if other files instantiate templates or use macros
+// or inline functions from this file, or you compile this file and link it
+// with other works to produce a work based on this file, this file does not
+// by itself cause the resulting work to be covered by the GNU General Public
+// License. However the source code for this file must still be made available
+// in accordance with section (3) of the GNU General Public License.
+//
+// This exception does not invalidate any other reasons why a work based on
+// this file might be covered by the GNU General Public License.
+//
+// Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+// at http://sources.redhat.com/ecos/ecos-license/
+// -------------------------------------------
+//####ECOSGPLCOPYRIGHTEND####
+//===========================================================================*/
+
+#include <pkgconf/hal.h>
+#include <pkgconf/system.h>
+#include CYGBLD_HAL_PLATFORM_H
+
+#include <cyg/infra/cyg_type.h>         // base types
+#include <cyg/infra/cyg_trac.h>         // tracing macros
+#include <cyg/infra/cyg_ass.h>          // assertion macros
+
+#include <cyg/hal/hal_arch.h>           // basic machine info
+#include <cyg/hal/hal_intr.h>           // interrupt macros
+#include <cyg/hal/hal_io.h>             // IO macros
+#include <cyg/hal/hal_if.h>             // Calling interface definitions
+#include <cyg/hal/hal_diag.h>
+#include <cyg/hal/drv_api.h>            // cyg_drv_interrupt_acknowledge
+#include <cyg/hal/hal_misc.h>           // Helper functions
+#include <cyg/hal/hal_soc.h>         // Hardware definitions
+
+/*
+ * UART Control Register 0 Bit Fields.
+ */
+#define EUartUCR1_ADEN      (1 << 15)           // Auto dectect interrupt
+#define EUartUCR1_ADBR      (1 << 14)           // Auto detect baud rate
+#define EUartUCR1_TRDYEN    (1 << 13)           // Transmitter ready interrupt enable
+#define EUartUCR1_IDEN      (1 << 12)           // Idle condition interrupt
+#define EUartUCR1_RRDYEN    (1 << 9)            // Recv ready interrupt enable
+#define EUartUCR1_RDMAEN    (1 << 8)            // Recv ready DMA enable
+#define EUartUCR1_IREN      (1 << 7)            // Infrared interface enable
+#define EUartUCR1_TXMPTYEN  (1 << 6)            // Transimitter empty interrupt enable
+#define EUartUCR1_RTSDEN    (1 << 5)            // RTS delta interrupt enable
+#define EUartUCR1_SNDBRK    (1 << 4)            // Send break
+#define EUartUCR1_TDMAEN    (1 << 3)            // Transmitter ready DMA enable
+#define EUartUCR1_DOZE      (1 << 1)            // Doze
+#define EUartUCR1_UARTEN    (1 << 0)            // UART enabled
+#define EUartUCR2_ESCI      (1 << 15)           // Escape seq interrupt enable
+#define EUartUCR2_IRTS      (1 << 14)           // Ignore RTS pin
+#define EUartUCR2_CTSC      (1 << 13)           // CTS pin control
+#define EUartUCR2_CTS       (1 << 12)           // Clear to send
+#define EUartUCR2_ESCEN     (1 << 11)           // Escape enable
+#define EUartUCR2_PREN      (1 << 8)            // Parity enable
+#define EUartUCR2_PROE      (1 << 7)            // Parity odd/even
+#define EUartUCR2_STPB      (1 << 6)            // Stop
+#define EUartUCR2_WS        (1 << 5)            // Word size
+#define EUartUCR2_RTSEN     (1 << 4)            // Request to send interrupt enable
+#define EUartUCR2_ATEN      (1 << 3)            // Aging timer enable
+#define EUartUCR2_TXEN      (1 << 2)            // Transmitter enabled
+#define EUartUCR2_RXEN      (1 << 1)            // Receiver enabled
+#define EUartUCR2_SRST_     (1 << 0)            // SW reset
+#define EUartUCR3_PARERREN  (1 << 12)           // Parity enable
+#define EUartUCR3_FRAERREN  (1 << 11)           // Frame error interrupt enable
+#define EUartUCR3_ADNIMP    (1 << 7)            // Autobaud detection not improved
+#define EUartUCR3_RXDSEN    (1 << 6)            // Receive status interrupt enable
+#define EUartUCR3_AIRINTEN  (1 << 5)            // Async IR wake interrupt enable
+#define EUartUCR3_AWAKEN    (1 << 4)            // Async wake interrupt enable
+#define EUartUCR3_RXDMUXSEL (1 << 2)            // RXD muxed input selected
+#define EUartUCR3_INVT      (1 << 1)            // Inverted Infrared transmission
+#define EUartUCR3_ACIEN     (1 << 0)            // Autobaud counter interrupt enable
+#define EUartUCR4_CTSTL_32  (32 << 10)          // CTS trigger level (32 chars)
+#define EUartUCR4_INVR      (1 << 9)            // Inverted infrared reception
+#define EUartUCR4_ENIRI     (1 << 8)            // Serial infrared interrupt enable
+#define EUartUCR4_WKEN      (1 << 7)            // Wake interrupt enable
+#define EUartUCR4_IRSC      (1 << 5)            // IR special case
+#define EUartUCR4_LPBYP     (1 << 4)            // Low power bypass
+#define EUartUCR4_TCEN      (1 << 3)            // Transmit complete interrupt enable
+#define EUartUCR4_BKEN      (1 << 2)            // Break condition interrupt enable
+#define EUartUCR4_OREN      (1 << 1)            // Receiver overrun interrupt enable
+#define EUartUCR4_DREN      (1 << 0)            // Recv data ready interrupt enable
+#define EUartUFCR_RXTL_SHF  0                   // Receiver trigger level shift
+#define EUartUFCR_RFDIV_1   (5 << 7)            // Reference freq divider (div 1)
+#define EUartUFCR_RFDIV_2   (4 << 7)            // Reference freq divider (div 2)
+#define EUartUFCR_RFDIV_3   (3 << 7)            // Reference freq divider (div 3)
+#define EUartUFCR_RFDIV_4   (2 << 7)            // Reference freq divider (div 4)
+#define EUartUFCR_RFDIV_5   (1 << 7)            // Reference freq divider (div 5)
+#define EUartUFCR_RFDIV_6   (0 << 7)            // Reference freq divider (div 6)
+#define EUartUFCR_RFDIV_7   (6 << 7)            // Reference freq divider (div 7)
+#define EUartUFCR_TXTL_SHF  10                  // Transmitter trigger level shift
+#define EUartUSR1_PARITYERR (1 << 15)           // Parity error interrupt flag
+#define EUartUSR1_RTSS      (1 << 14)           // RTS pin status
+#define EUartUSR1_TRDY      (1 << 13)           // Transmitter ready interrupt/dma flag
+#define EUartUSR1_RTSD      (1 << 12)           // RTS delta
+#define EUartUSR1_ESCF      (1 << 11)           // Escape seq interrupt flag
+#define EUartUSR1_FRAMERR   (1 << 10)           // Frame error interrupt flag
+#define EUartUSR1_RRDY      (1 << 9)            // Receiver ready interrupt/dma flag
+#define EUartUSR1_AGTIM     (1 << 8)            // Aging timeout interrupt status
+#define EUartUSR1_RXDS      (1 << 6)            // Receiver idle interrupt flag
+#define EUartUSR1_AIRINT    (1 << 5)            // Async IR wake interrupt flag
+#define EUartUSR1_AWAKE     (1 << 4)            // Aysnc wake interrupt flag
+#define EUartUSR2_ADET      (1 << 15)           // Auto baud rate detect complete
+#define EUartUSR2_TXFE      (1 << 14)           // Transmit buffer FIFO empty
+#define EUartUSR2_IDLE      (1 << 12)           // Idle condition
+#define EUartUSR2_ACST      (1 << 11)           // Autobaud counter stopped
+#define EUartUSR2_IRINT     (1 << 8)            // Serial infrared interrupt flag
+#define EUartUSR2_WAKE      (1 << 7)            // Wake
+#define EUartUSR2_RTSF      (1 << 4)            // RTS edge interrupt flag
+#define EUartUSR2_TXDC      (1 << 3)            // Transmitter complete
+#define EUartUSR2_BRCD      (1 << 2)            // Break condition
+#define EUartUSR2_ORE       (1 << 1)            // Overrun error
+#define EUartUSR2_RDR       (1 << 0)            // Recv data ready
+#define EUartUTS_FRCPERR    (1 << 13)           // Force parity error
+#define EUartUTS_LOOP       (1 << 12)           // Loop tx and rx
+#define EUartUTS_TXEMPTY    (1 << 6)            // TxFIFO empty
+#define EUartUTS_RXEMPTY    (1 << 5)            // RxFIFO empty
+#define EUartUTS_TXFULL     (1 << 4)            // TxFIFO full
+#define EUartUTS_RXFULL     (1 << 3)            // RxFIFO full
+#define EUartUTS_SOFTRST    (1 << 0)            // Software reset
+
+#define EUartUFCR_RFDIV                        EUartUFCR_RFDIV_2
+//#define EUartUFCR_RFDIV                        EUartUFCR_RFDIV_4
+//#define EUartUFCR_RFDIV                        EUartUFCR_RFDIV_7
+
+#if (EUartUFCR_RFDIV==EUartUFCR_RFDIV_2)
+#define MXC_UART_REFFREQ                        (get_peri_clock(UART1_BAUD) / 2)
+#endif
+
+#if (EUartUFCR_RFDIV==EUartUFCR_RFDIV_4)
+#define MXC_UART_REFFREQ                        (get_peri_clock(UART1_BAUD) / 4)
+#endif
+
+#if (EUartUFCR_RFDIV==EUartUFCR_RFDIV_7)
+#define MXC_UART_REFFREQ                        (get_peri_clock(UART1_BAUD) / 7)
+#endif
+
+#if 0
+void
+cyg_hal_plf_comms_init(void)
+{
+    static int initialized = 0;
+
+    if (initialized)
+        return;
+
+    initialized = 1;
+
+    cyg_hal_plf_serial_init();
+}
+#endif
+
+//=============================================================================
+// MXC Serial Port (UARTx) for Debug
+//=============================================================================
+#ifdef UART_WIDTH_32
+struct mxc_serial {
+    volatile cyg_uint32 urxd[16];
+    volatile cyg_uint32 utxd[16];
+    volatile cyg_uint32 ucr1;
+    volatile cyg_uint32 ucr2;
+    volatile cyg_uint32 ucr3;
+    volatile cyg_uint32 ucr4;
+    volatile cyg_uint32 ufcr;
+    volatile cyg_uint32 usr1;
+    volatile cyg_uint32 usr2;
+    volatile cyg_uint32 uesc;
+    volatile cyg_uint32 utim;
+    volatile cyg_uint32 ubir;
+    volatile cyg_uint32 ubmr;
+    volatile cyg_uint32 ubrc;
+    volatile cyg_uint32 onems;
+    volatile cyg_uint32 uts;
+};
+#else
+struct mxc_serial {
+    volatile cyg_uint16 urxd[1];
+    volatile cyg_uint16 resv0[31];
+
+    volatile cyg_uint16 utxd[1];
+    volatile cyg_uint16 resv1[31];
+    volatile cyg_uint16 ucr1;
+    volatile cyg_uint16 resv2;
+    volatile cyg_uint16 ucr2;
+    volatile cyg_uint16 resv3;
+    volatile cyg_uint16 ucr3;
+    volatile cyg_uint16 resv4;
+    volatile cyg_uint16 ucr4;
+    volatile cyg_uint16 resv5;
+    volatile cyg_uint16 ufcr;
+    volatile cyg_uint16 resv6;
+    volatile cyg_uint16 usr1;
+    volatile cyg_uint16 resv7;
+    volatile cyg_uint16 usr2;
+    volatile cyg_uint16 resv8;
+    volatile cyg_uint16 uesc;
+    volatile cyg_uint16 resv9;
+    volatile cyg_uint16 utim;
+    volatile cyg_uint16 resv10;
+    volatile cyg_uint16 ubir;
+    volatile cyg_uint16 resv11;
+    volatile cyg_uint16 ubmr;
+    volatile cyg_uint16 resv12;
+    volatile cyg_uint16 ubrc;
+    volatile cyg_uint16 resv13;
+    volatile cyg_uint16 onems;
+    volatile cyg_uint16 resv14;
+    volatile cyg_uint16 uts;
+    volatile cyg_uint16 resv15;
+};
+#endif
+
+typedef struct {
+    volatile struct mxc_serial* base;
+    cyg_int32 msec_timeout;
+    int isr_vector;
+    int baud_rate;
+} channel_data_t;
+
+static channel_data_t channels[] = {
+#if CYGHWR_HAL_ARM_SOC_UART1 != 0
+    {(volatile struct mxc_serial*)UART1_BASE_ADDR, 1000,
+      CYGNUM_HAL_INTERRUPT_UART1, CYGNUM_HAL_VIRTUAL_VECTOR_CONSOLE_CHANNEL_BAUD},
+#endif
+#if CYGHWR_HAL_ARM_SOC_UART2 != 0
+    {(volatile struct mxc_serial*)UART2_BASE_ADDR, 1000,
+     CYGNUM_HAL_INTERRUPT_UART2, CYGNUM_HAL_VIRTUAL_VECTOR_CONSOLE_CHANNEL_BAUD},
+#endif
+#if CYGHWR_HAL_ARM_SOC_UART3 != 0
+    {(volatile struct mxc_serial*)UART3_BASE_ADDR, 1000,
+     CYGNUM_HAL_INTERRUPT_UART3, CYGNUM_HAL_VIRTUAL_VECTOR_CONSOLE_CHANNEL_BAUD},
+#endif
+};
+
+/*---------------------------------------------------------------------------*/
+
+static void init_serial_channel(channel_data_t* __ch_data)
+{
+    volatile struct mxc_serial* base = __ch_data->base;
+
+    /* Wait for UART to finish transmitting */
+    while (!(base->uts & EUartUTS_TXEMPTY));
+
+    /* Disable UART */
+    base->ucr1 &= ~EUartUCR1_UARTEN;
+
+    /* Set to default POR state */
+    base->ucr1 = 0x00000000;
+    base->ucr2 = 0x00000000;
+
+    while (!(base->ucr2 & EUartUCR2_SRST_));
+
+    base->ucr3 = 0x00000704;
+    base->ucr4 = 0x00008000;
+    base->ufcr = 0x00000801;
+    base->uesc = 0x0000002B;
+    base->utim = 0x00000000;
+    base->ubir = 0x00000000;
+    base->ubmr = 0x00000000;
+    base->onems = 0x00000000;
+    base->uts  = 0x00000000;
+
+    /* Configure FIFOs */
+    base->ufcr = (1 << EUartUFCR_RXTL_SHF) | EUartUFCR_RFDIV
+                 | (2 << EUartUFCR_TXTL_SHF);
+
+    /* Setup One MS timer */
+    base->onems  = (MXC_UART_REFFREQ / 1000);
+
+    /* Set to 8N1 */
+    base->ucr2 &= ~EUartUCR2_PREN;
+    base->ucr2 |= EUartUCR2_WS;
+    base->ucr2 &= ~EUartUCR2_STPB;
+
+    /* Ignore RTS */
+    base->ucr2 |= EUartUCR2_IRTS;
+
+    /* Enable UART */
+    base->ucr1 |= EUartUCR1_UARTEN;
+
+    /* Enable FIFOs */
+    base->ucr2 |= EUartUCR2_SRST_ | EUartUCR2_RXEN | EUartUCR2_TXEN;
+
+    /* Clear status flags */
+    base->usr2 |= EUartUSR2_ADET  |
+                  EUartUSR2_IDLE  |
+                  EUartUSR2_IRINT |
+                  EUartUSR2_WAKE  |
+                  EUartUSR2_RTSF  |
+                  EUartUSR2_BRCD  |
+                  EUartUSR2_ORE   |
+                  EUartUSR2_RDR;
+
+    /* Clear status flags */
+    base->usr1 |= EUartUSR1_PARITYERR |
+                  EUartUSR1_RTSD      |
+                  EUartUSR1_ESCF      |
+                  EUartUSR1_FRAMERR   |
+                  EUartUSR1_AIRINT    |
+                  EUartUSR1_AWAKE;
+
+    /* Set the numerator value minus one of the BRM ratio */
+    base->ubir = (__ch_data->baud_rate / 100) - 1;
+
+    /* Set the denominator value minus one of the BRM ratio    */
+    base->ubmr = ((MXC_UART_REFFREQ / 1600) - 1);
+
+}
+
+static void stop_serial_channel(channel_data_t* __ch_data)
+{
+    volatile struct mxc_serial* base = __ch_data->base;
+
+    /* Wait for UART to finish transmitting */
+    while (!(base->uts & EUartUTS_TXEMPTY));
+
+    /* Disable UART */
+    base->ucr1 &= ~EUartUCR1_UARTEN;
+}
+
+//#define debug_uart_log_buf
+#ifdef debug_uart_log_buf
+#define DIAG_BUFSIZE 2048
+static char __log_buf[DIAG_BUFSIZE];
+static int diag_bp = 0;
+#endif
+
+void cyg_hal_plf_serial_putc(void *__ch_data, char c)
+{
+    volatile struct mxc_serial* base = ((channel_data_t*)__ch_data)->base;
+
+#ifdef debug_uart_log_buf
+    __log_buf[diag_bp++] = c;
+    return;
+#endif
+
+    CYGARC_HAL_SAVE_GP();
+
+    // Wait for Tx FIFO not full
+    while (base->uts & EUartUTS_TXFULL)
+        ;
+    base->utxd[0] = c;
+
+    CYGARC_HAL_RESTORE_GP();
+}
+
+static cyg_bool cyg_hal_plf_serial_getc_nonblock(void* __ch_data,
+                                                 cyg_uint8* ch)
+{
+    volatile struct mxc_serial* base = ((channel_data_t*)__ch_data)->base;
+
+    // If receive fifo is empty, return false
+    if (base->uts & EUartUTS_RXEMPTY)
+        return false;
+
+    *ch = (char)base->urxd[0];
+
+    return true;
+}
+
+cyg_uint8 cyg_hal_plf_serial_getc(void* __ch_data)
+{
+    cyg_uint8 ch;
+    CYGARC_HAL_SAVE_GP();
+
+    while (!cyg_hal_plf_serial_getc_nonblock(__ch_data, &ch));
+
+    CYGARC_HAL_RESTORE_GP();
+    return ch;
+}
+
+static void cyg_hal_plf_serial_write(void* __ch_data, const cyg_uint8* __buf,
+                         cyg_uint32 __len)
+{
+    CYGARC_HAL_SAVE_GP();
+
+    while(__len-- > 0)
+        cyg_hal_plf_serial_putc(__ch_data, *__buf++);
+
+    CYGARC_HAL_RESTORE_GP();
+}
+
+static void cyg_hal_plf_serial_read(void* __ch_data, cyg_uint8* __buf,
+                                    cyg_uint32 __len)
+{
+    CYGARC_HAL_SAVE_GP();
+
+    while (__len-- > 0)
+        *__buf++ = cyg_hal_plf_serial_getc(__ch_data);
+
+    CYGARC_HAL_RESTORE_GP();
+}
+
+cyg_bool cyg_hal_plf_serial_getc_timeout(void* __ch_data,
+                                         cyg_uint8* ch)
+{
+    int delay_count;
+    channel_data_t* chan = (channel_data_t*)__ch_data;
+    cyg_bool res;
+    CYGARC_HAL_SAVE_GP();
+
+    delay_count = chan->msec_timeout * 10; // delay in .1 ms steps
+
+    for(;;) {
+        res = cyg_hal_plf_serial_getc_nonblock(__ch_data, ch);
+        if (res || 0 == delay_count--)
+            break;
+
+        CYGACC_CALL_IF_DELAY_US(100);
+    }
+
+    CYGARC_HAL_RESTORE_GP();
+    return res;
+}
+
+static int cyg_hal_plf_serial_control(void *__ch_data,
+                                      __comm_control_cmd_t __func, ...)
+{
+    static int irq_state = 0;
+    channel_data_t* chan = (channel_data_t*)__ch_data;
+    int ret = -1;
+    va_list ap;
+
+    CYGARC_HAL_SAVE_GP();
+    va_start(ap, __func);
+
+    switch (__func) {
+    case __COMMCTL_GETBAUD:
+        ret = chan->baud_rate;
+        break;
+    case __COMMCTL_SETBAUD:
+        chan->baud_rate = va_arg(ap, cyg_int32);
+        // Should we verify this value here?
+        init_serial_channel(chan);
+        ret = 0;
+        break;
+    case __COMMCTL_IRQ_ENABLE:
+        irq_state = 1;
+
+        chan->base->ucr1 |= EUartUCR1_RRDYEN;
+
+        HAL_INTERRUPT_UNMASK(chan->isr_vector);
+        break;
+    case __COMMCTL_IRQ_DISABLE:
+        ret = irq_state;
+        irq_state = 0;
+
+        chan->base->ucr1 &= ~EUartUCR1_RRDYEN;
+
+        HAL_INTERRUPT_MASK(chan->isr_vector);
+        break;
+    case __COMMCTL_DBG_ISR_VECTOR:
+        ret = chan->isr_vector;
+        break;
+    case __COMMCTL_SET_TIMEOUT:
+        ret = chan->msec_timeout;
+        chan->msec_timeout = va_arg(ap, cyg_uint32);
+        break;
+    default:
+        break;
+    }
+    va_end(ap);
+    CYGARC_HAL_RESTORE_GP();
+    return ret;
+}
+
+static int cyg_hal_plf_serial_isr(void *__ch_data, int* __ctrlc,
+                       CYG_ADDRWORD __vector, CYG_ADDRWORD __data)
+{
+    int res = 0;
+    channel_data_t* chan = (channel_data_t*)__ch_data;
+    char c;
+
+    CYGARC_HAL_SAVE_GP();
+
+    cyg_drv_interrupt_acknowledge(chan->isr_vector);
+
+    *__ctrlc = 0;
+    if (!(chan->base->uts & EUartUTS_RXEMPTY)) {
+	c = (char)chan->base->urxd[0];
+
+        if (cyg_hal_is_break( &c , 1 ))
+            *__ctrlc = 1;
+
+        res = CYG_ISR_HANDLED;
+    }
+
+    CYGARC_HAL_RESTORE_GP();
+    return res;
+}
+
+void cyg_hal_plf_serial_init(void)
+{
+    hal_virtual_comm_table_t* comm;
+    int cur = CYGACC_CALL_IF_SET_CONSOLE_COMM(CYGNUM_CALL_IF_SET_COMM_ID_QUERY_CURRENT);
+    int i;
+    static int jjj = 0;
+
+    // Init channels
+#define NUMOF(x) (sizeof(x)/sizeof(x[0]))
+    for (i = 0;  i < NUMOF(channels);  i++) {
+        init_serial_channel(&channels[i]);
+        CYGACC_CALL_IF_SET_CONSOLE_COMM(i+2);
+        comm = CYGACC_CALL_IF_CONSOLE_PROCS();
+        CYGACC_COMM_IF_CH_DATA_SET(*comm, &channels[i]);
+        CYGACC_COMM_IF_WRITE_SET(*comm, cyg_hal_plf_serial_write);
+        CYGACC_COMM_IF_READ_SET(*comm, cyg_hal_plf_serial_read);
+        CYGACC_COMM_IF_PUTC_SET(*comm, cyg_hal_plf_serial_putc);
+        CYGACC_COMM_IF_GETC_SET(*comm, cyg_hal_plf_serial_getc);
+        CYGACC_COMM_IF_CONTROL_SET(*comm, cyg_hal_plf_serial_control);
+        CYGACC_COMM_IF_DBG_ISR_SET(*comm, cyg_hal_plf_serial_isr);
+        CYGACC_COMM_IF_GETC_TIMEOUT_SET(*comm, cyg_hal_plf_serial_getc_timeout);
+        if (jjj == 0) {
+            cyg_hal_plf_serial_putc(&channels[i], '+');
+            jjj++;
+        }
+        cyg_hal_plf_serial_putc(&channels[i], '+');
+    }
+
+    // Restore original console
+    CYGACC_CALL_IF_SET_CONSOLE_COMM(cur);
+}
+
+void cyg_hal_plf_serial_stop(void)
+{
+        int i;
+
+        // Init channels
+#define NUMOF(x) (sizeof(x)/sizeof(x[0]))
+        for (i = 0;  i < NUMOF(channels);  i++) {
+                stop_serial_channel(&channels[i]);
+        }
+}
+
+//=============================================================================
+// Compatibility with older stubs
+//=============================================================================
+
+#ifndef CYGSEM_HAL_VIRTUAL_VECTOR_DIAG
+
+#include <cyg/hal/hal_stub.h>           // cyg_hal_gdb_interrupt
+
+#if (CYGNUM_HAL_VIRTUAL_VECTOR_CONSOLE_CHANNEL == 2)
+#define __BASE ((void*)UART1_BASE_ADDR)
+#define CYGHWR_HAL_GDB_PORT_VECTOR CYGNUM_HAL_INTERRUPT_UART1
+#elif (CYGNUM_HAL_VIRTUAL_VECTOR_CONSOLE_CHANNEL == 3)
+#define __BASE ((void*)UART2_BASE_ADDR)
+#define CYGHWR_HAL_GDB_PORT_VECTOR CYGNUM_HAL_INTERRUPT_UART2
+#elif (CYGNUM_HAL_VIRTUAL_VECTOR_CONSOLE_CHANNEL == 4)
+#define __BASE ((void*)UART3_BASE_ADDR)
+#endif
+
+#ifdef __BASE
+
+#ifdef CYGSEM_HAL_ROM_MONITOR
+#define CYG_HAL_STARTUP_ROM
+#define CYG_HAL_STARTUP_ROMRAM
+#undef CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS
+#endif
+
+#if (defined(CYG_HAL_STARTUP_ROM) || defined(CYG_HAL_STARTUP_ROMRAM)) && !defined(CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS)
+#define HAL_DIAG_USES_HARDWARE
+#elif !defined(CYGDBG_HAL_DIAG_TO_DEBUG_CHAN)
+#define HAL_DIAG_USES_HARDWARE
+#elif CYGNUM_HAL_VIRTUAL_VECTOR_CONSOLE_CHANNEL != CYGNUM_HAL_VIRTUAL_VECTOR_DEBUG_CHANNEL
+#define HAL_DIAG_USES_HARDWARE
+#endif
+
+static channel_data_t channel = {
+    (volatile struct mxc_serial*)__BASE, 0, CYGHWR_HAL_GDB_PORT_VECTOR
+};
+
+#ifdef HAL_DIAG_USES_HARDWARE
+
+void hal_diag_init(void)
+{
+    static int init = 0;
+    char *msg = "\n\rARM eCos\n\r";
+    cyg_uint8 lcr;
+
+    if (init++) return;
+
+    init_serial_channel(&channel);
+
+    while (*msg) hal_diag_write_char(*msg++);
+}
+
+#ifdef DEBUG_DIAG
+#ifndef CYG_HAL_STARTUP_ROM
+#define DIAG_BUFSIZE 2048
+static char diag_buffer[DIAG_BUFSIZE];
+static int diag_bp = 0;
+#endif
+#endif
+
+void hal_diag_write_char(char c)
+{
+#ifdef DEBUG_DIAG
+#ifndef CYG_HAL_STARTUP_ROM
+    diag_buffer[diag_bp++] = c;
+    if (diag_bp == sizeof(diag_buffer)) diag_bp = 0;
+#endif
+#endif
+    cyg_hal_plf_serial_putc(&channel, c);
+}
+
+void hal_diag_read_char(char *c)
+{
+    *c = cyg_hal_plf_serial_getc(&channel);
+}
+
+#else // not HAL_DIAG_USES_HARDWARE - it uses GDB protocol
+
+void hal_diag_read_char(char *c)
+{
+    *c = cyg_hal_plf_serial_getc(&channel);
+}
+
+void hal_diag_write_char(char c)
+{
+    static char line[100];
+    static int pos = 0;
+
+    // FIXME: Some LED blinking might be nice right here.
+
+    // No need to send CRs
+    if( c == '\r' ) return;
+
+    line[pos++] = c;
+
+        if (c == '\n' || pos == sizeof(line)) {
+        CYG_INTERRUPT_STATE old;
+
+        // Disable interrupts. This prevents GDB trying to interrupt us
+        // while we are in the middle of sending a packet. The serial
+        // receive interrupt will be seen when we re-enable interrupts
+        // later.
+
+#ifdef CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS
+        CYG_HAL_GDB_ENTER_CRITICAL_IO_REGION(old);
+#else
+        HAL_DISABLE_INTERRUPTS(old);
+#endif
+
+        while (1) {
+            static char hex[] = "0123456789ABCDEF";
+            cyg_uint8 csum = 0;
+            int i;
+#ifndef CYGDBG_HAL_DEBUG_GDB_CTRLC_SUPPORT
+            char c1;
+#endif
+            cyg_hal_plf_serial_putc(&channel, '$');
+            cyg_hal_plf_serial_putc(&channel, 'O');
+            csum += 'O';
+            for(i = 0; i < pos; i++) {
+                char ch = line[i];
+                char h = hex[(ch>>4)&0xF];
+                char l = hex[ch&0xF];
+                cyg_hal_plf_serial_putc(&channel, h);
+                cyg_hal_plf_serial_putc(&channel, l);
+                csum += h;
+                csum += l;
+            }
+            cyg_hal_plf_serial_putc(&channel, '#');
+            cyg_hal_plf_serial_putc(&channel, hex[(csum>>4)&0xF]);
+            cyg_hal_plf_serial_putc(&channel, hex[csum&0xF]);
+
+#ifdef CYGDBG_HAL_DEBUG_GDB_CTRLC_SUPPORT
+
+            break; // regardless
+
+#else // not CYGDBG_HAL_DEBUG_GDB_CTRLC_SUPPORT Ie. usually...
+
+            // Wait for the ACK character '+' from GDB here and handle
+            // receiving a ^C instead.  This is the reason for this clause
+            // being a loop.
+            c1 = cyg_hal_plf_serial_getc(&channel);
+
+            if( c1 == '+' )
+                break;              // a good acknowledge
+
+#ifdef CYGDBG_HAL_DEBUG_GDB_BREAK_SUPPORT
+            cyg_drv_interrupt_acknowledge(CYGHWR_HAL_GDB_PORT_VECTOR);
+            if( c1 == 3 ) {
+                // Ctrl-C: breakpoint.
+                cyg_hal_gdb_interrupt(
+                    (target_register_t)__builtin_return_address(0) );
+                break;
+            }
+#endif // CYGDBG_HAL_DEBUG_GDB_BREAK_SUPPORT
+
+#endif // ! CYGDBG_HAL_DEBUG_GDB_CTRLC_SUPPORT
+            // otherwise, loop round again
+        }
+
+        pos = 0;
+
+        // And re-enable interrupts
+#ifdef CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS
+        CYG_HAL_GDB_LEAVE_CRITICAL_IO_REGION(old);
+#else
+        HAL_RESTORE_INTERRUPTS(old);
+#endif
+
+    }
+}
+#endif
+
+#endif // __BASE
+
+#endif // !CYGSEM_HAL_VIRTUAL_VECTOR_DIAG
+
+/*---------------------------------------------------------------------------*/
+/* End of hal_diag.c */
diff -urN -x CVS -x doc -x lwip_tcpip -x calmrisc16 -x calmrisc32 ecos_20050912/packages/hal/arm/mx51/var/current/src/soc_misc.c ecos_base/packages/hal/arm/mx51/var/current/src/soc_misc.c
--- ecos_20050912/packages/hal/arm/mx51/var/current/src/soc_misc.c	1969-12-31 18:00:00.000000000 -0600
+++ ecos_base/packages/hal/arm/mx51/var/current/src/soc_misc.c	2008-03-31 18:32:56.000000000 -0500
@@ -0,0 +1,375 @@
+//==========================================================================
+//
+//      soc_misc.c
+//
+//      HAL misc board support code
+//
+//==========================================================================
+//####ECOSGPLCOPYRIGHTBEGIN####
+// -------------------------------------------
+// This file is part of eCos, the Embedded Configurable Operating System.
+// Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+//
+// eCos is free software; you can redistribute it and/or modify it under
+// the terms of the GNU General Public License as published by the Free
+// Software Foundation; either version 2 or (at your option) any later version.
+//
+// eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with eCos; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+//
+// As a special exception, if other files instantiate templates or use macros
+// or inline functions from this file, or you compile this file and link it
+// with other works to produce a work based on this file, this file does not
+// by itself cause the resulting work to be covered by the GNU General Public
+// License. However the source code for this file must still be made available
+// in accordance with section (3) of the GNU General Public License.
+//
+// This exception does not invalidate any other reasons why a work based on
+// this file might be covered by the GNU General Public License.
+//
+// Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+// at http://sources.redhat.com/ecos/ecos-license/
+// -------------------------------------------
+//####ECOSGPLCOPYRIGHTEND####
+//========================================================================*/
+
+#include <redboot.h>
+#include <pkgconf/hal.h>
+#include <pkgconf/system.h>
+#include CYGBLD_HAL_PLATFORM_H
+
+#include <cyg/infra/cyg_type.h>         // base types
+#include <cyg/infra/cyg_trac.h>         // tracing macros
+#include <cyg/infra/cyg_ass.h>          // assertion macros
+
+#include <cyg/hal/hal_misc.h>           // Size constants
+#include <cyg/hal/hal_io.h>             // IO macros
+#include <cyg/hal/hal_arch.h>           // Register state info
+#include <cyg/hal/hal_diag.h>
+#include <cyg/hal/hal_intr.h>           // Interrupt names
+#include <cyg/hal/hal_cache.h>          // Cache control
+#include <cyg/hal/hal_soc.h>            // Hardware definitions
+#include <cyg/hal/hal_mm.h>             // MMap table definitions
+
+#include <cyg/infra/diag.h>             // diag_printf
+
+// Most initialization has already been done before we get here.
+// All we do here is set up the interrupt environment.
+// FIXME: some of the stuff in hal_platform_setup could be moved here.
+
+externC void plf_hardware_init(void);
+
+#define IIM_PROD_REV_SH         3
+#define IIM_PROD_REV_LEN        5
+#define IIM_SREV_REV_SH         4
+#define IIM_SREV_REV_LEN        4
+#define PROD_SIGNATURE_MX37     0x1
+
+#define PROD_SIGNATURE_SUPPORTED  PROD_SIGNATURE_MX37
+
+#define CHIP_VERSION_NONE           0xFFFFFFFF      // invalid product ID
+#define CHIP_VERSION_UNKNOWN        0xDEADBEEF      // invalid chip rev
+
+#define PART_NUMBER_OFFSET          (12)
+#define MAJOR_NUMBER_OFFSET         (4)
+#define MINOR_NUMBER_OFFSET         (0)
+
+/*
+ * System_rev will have the following format
+ * 31-12 = part # (0x31, 0x32, 0x27, 0x91131, 0x91321, etc)
+ * 11-8 = unused
+ * 7-4 = major (1.y)
+ * 3-0 = minor (x.0)
+ */
+unsigned int system_rev = CHIP_REV_1_0;
+static int find_correct_chip;
+extern char HAL_PLATFORM_EXTRA[20];
+
+/*
+ * This functions reads the IIM module and returns the system revision number.
+ * It returns the IIM silicon revision reg value if valid product rev is found.
+ . Otherwise, it returns -1.
+ */
+static int read_system_rev(void)
+{
+    int val;
+
+    val = readl(IIM_BASE_ADDR + IIM_PREV_OFF);
+
+    system_rev = 0x37 << PART_NUMBER_OFFSET; /* For MX37 Platform*/
+
+#if 0
+    /* If the IIM doesn't contain valid product signature, return
+     * the lowest revision number */
+    if (MXC_GET_FIELD(val, IIM_PROD_REV_LEN, IIM_PROD_REV_SH) !=
+        PROD_SIGNATURE_SUPPORTED) {
+        return CHIP_VERSION_NONE;
+    }
+#endif
+
+    /* Now trying to retrieve the silicon rev from IIM's SREV register */
+    return readl(IIM_BASE_ADDR + IIM_SREV_OFF);
+}
+
+extern nfc_setup_func_t *nfc_setup;
+unsigned int mxc_nfc_soc_setup(unsigned int pg_sz, unsigned int io_sz,
+                                      unsigned int is_mlc);
+void hal_hardware_init(void)
+{
+
+    volatile unsigned int esdmisc = readl(ESDCTL_BASE + 0x10);
+    volatile unsigned int esdctl0 = readl(ESDCTL_BASE);
+    int ver = read_system_rev();
+
+    find_correct_chip = ver;
+
+    if (ver != CHIP_VERSION_NONE) {
+        /* Valid product revision found. Check actual silicon rev and
+         * NOT use the version from the ROM code. */
+        if (((ver >> 4) & 0xF) == 0x0) {
+            HAL_PLATFORM_EXTRA[5] = '1';
+            HAL_PLATFORM_EXTRA[7] = '0';
+            system_rev |= 1 << MAJOR_NUMBER_OFFSET; /*Major Number*/
+            system_rev |= 0 << MINOR_NUMBER_OFFSET; /*Minor Number*/
+        } else {
+            HAL_PLATFORM_EXTRA[5] = 'x';
+            HAL_PLATFORM_EXTRA[7] = 'x';
+            system_rev |= 1 << MAJOR_NUMBER_OFFSET; /*Major Number*/
+            system_rev |= 0 << MINOR_NUMBER_OFFSET; /*Minor Number*/
+            find_correct_chip = CHIP_VERSION_UNKNOWN;
+        }
+    }
+#if 0
+    if ((esdmisc & 0x4) == 0) {
+        HAL_PLATFORM_EXTRA[14] = 'S';
+    }
+    if ((esdctl0 & 0x30000) != 0x20000) {
+        HAL_PLATFORM_EXTRA[11] = '1';
+        HAL_PLATFORM_EXTRA[12] = '6';
+    }
+
+    // Mask all interrupts
+    writel(0xFFFFFFFF, AVIC_NIMASK);
+
+    // Make all interrupts do IRQ and not FIQ
+    // FIXME: Change this if you use FIQs.
+    writel(0, AVIC_INTTYPEH);
+    writel(0, AVIC_INTTYPEL);
+#endif
+    // Enable caches
+    HAL_ICACHE_ENABLE();
+    HAL_DCACHE_ENABLE();
+
+    // enable EPIT and start it with 32KHz input clock
+    writel(0x00010000, EPIT_BASE_ADDR + EPITCR);
+
+    // make sure reset is complete
+    while ((readl(EPIT_BASE_ADDR + EPITCR) & 0x10000) != 0) {
+    }
+
+    writel(0x030E0002, EPIT_BASE_ADDR + EPITCR);
+    writel(0x030E0003, EPIT_BASE_ADDR + EPITCR);
+
+    writel(0, EPIT_BASE_ADDR + EPITCMPR);  // always compare with 0
+
+    if ((readw(WDOG_BASE_ADDR) & 4) != 0) {
+        // increase the WDOG timeout value to the max
+        writew(readw(WDOG_BASE_ADDR) | 0xFF00, WDOG_BASE_ADDR);
+    }
+
+    // Perform any platform specific initializations
+    plf_hardware_init();
+
+    // Set up eCos/ROM interfaces
+    hal_if_init();
+
+    nfc_setup = (nfc_setup_func_t*)mxc_nfc_soc_setup;
+}
+
+// -------------------------------------------------------------------------
+void hal_clock_initialize(cyg_uint32 period)
+{
+}
+
+// This routine is called during a clock interrupt.
+
+// Define this if you want to ensure that the clock is perfect (i.e. does
+// not drift).  One reason to leave it turned off is that it costs some
+// us per system clock interrupt for this maintenance.
+#undef COMPENSATE_FOR_CLOCK_DRIFT
+
+void hal_clock_reset(cyg_uint32 vector, cyg_uint32 period)
+{
+}
+
+// Read the current value of the clock, returning the number of hardware
+// "ticks" that have occurred (i.e. how far away the current value is from
+// the start)
+
+// Note: The "contract" for this function is that the value is the number
+// of hardware clocks that have happened since the last interrupt (i.e.
+// when it was reset).  This value is used to measure interrupt latencies.
+// However, since the hardware counter runs freely, this routine computes
+// the difference between the current clock period and the number of hardware
+// ticks left before the next timer interrupt.
+void hal_clock_read(cyg_uint32 *pvalue)
+{
+}
+
+// This is to cope with the test read used by tm_basic with
+// CYGVAR_KERNEL_COUNTERS_CLOCK_LATENCY defined; we read the count ASAP
+// in the ISR, *before* resetting the clock.  Which returns 1tick +
+// latency if we just use plain hal_clock_read().
+void hal_clock_latency(cyg_uint32 *pvalue)
+{
+}
+
+unsigned int hal_timer_count(void)
+{
+    return (0xFFFFFFFF - readl(EPIT_BASE_ADDR + EPITCNR));
+}
+
+#define WDT_MAGIC_1             0x5555
+#define WDT_MAGIC_2             0xAAAA
+#define MXC_WDT_WSR             0x2
+
+unsigned int i2c_base_addr[] = {
+    I2C_BASE_ADDR,
+    I2C2_BASE_ADDR,
+    I2C3_BASE_ADDR
+};
+unsigned int i2c_num = 3;
+
+//
+// Delay for some number of micro-seconds
+//
+void hal_delay_us(unsigned int usecs)
+{
+    /*
+     * This causes overflow.
+     * unsigned int delayCount = (usecs * 32768) / 1000000;
+     * So use the following one instead
+     */
+    unsigned int delayCount = (usecs * 512) / 15625;
+
+    if (delayCount == 0) {
+        return;
+    }
+
+    // issue the service sequence instructions
+    if ((readw(WDOG_BASE_ADDR) & 4) != 0) {
+        writew(WDT_MAGIC_1, WDOG_BASE_ADDR + MXC_WDT_WSR);
+        writew(WDT_MAGIC_2, WDOG_BASE_ADDR + MXC_WDT_WSR);
+    }
+
+    writel(0x01, EPIT_BASE_ADDR + EPITSR); // clear the compare status bit
+
+    writel(delayCount, EPIT_BASE_ADDR + EPITLR);
+
+    while ((0x1 & readl(EPIT_BASE_ADDR + EPITSR)) == 0); // return until compare bit is set
+}
+
+// -------------------------------------------------------------------------
+
+// This routine is called to respond to a hardware interrupt (IRQ).  It
+// should interrogate the hardware and return the IRQ vector number.
+int hal_IRQ_handler(void)
+{
+#ifdef HAL_EXTENDED_IRQ_HANDLER
+    cyg_uint32 index;
+
+    // Use platform specific IRQ handler, if defined
+    // Note: this macro should do a 'return' with the appropriate
+    // interrupt number if such an extended interrupt exists.  The
+    // assumption is that the line after the macro starts 'normal' processing.
+    HAL_EXTENDED_IRQ_HANDLER(index);
+#endif
+
+    return CYGNUM_HAL_INTERRUPT_NONE; // This shouldn't happen!
+}
+
+//
+// Interrupt control
+//
+
+void hal_interrupt_mask(int vector)
+{
+//    diag_printf("6hal_interrupt_mask(vector=%d) \n", vector);
+#ifdef HAL_EXTENDED_INTERRUPT_MASK
+    // Use platform specific handling, if defined
+    // Note: this macro should do a 'return' for "extended" values of 'vector'
+    // Normal vectors are handled by code subsequent to the macro call.
+    HAL_EXTENDED_INTERRUPT_MASK(vector);
+#endif
+}
+
+void hal_interrupt_unmask(int vector)
+{
+//    diag_printf("7hal_interrupt_unmask(vector=%d) \n", vector);
+
+#ifdef HAL_EXTENDED_INTERRUPT_UNMASK
+    // Use platform specific handling, if defined
+    // Note: this macro should do a 'return' for "extended" values of 'vector'
+    // Normal vectors are handled by code subsequent to the macro call.
+    HAL_EXTENDED_INTERRUPT_UNMASK(vector);
+#endif
+}
+
+void hal_interrupt_acknowledge(int vector)
+{
+
+//    diag_printf("8hal_interrupt_acknowledge(vector=%d) \n", vector);
+#ifdef HAL_EXTENDED_INTERRUPT_UNMASK
+    // Use platform specific handling, if defined
+    // Note: this macro should do a 'return' for "extended" values of 'vector'
+    // Normal vectors are handled by code subsequent to the macro call.
+    HAL_EXTENDED_INTERRUPT_ACKNOWLEDGE(vector);
+#endif
+}
+
+void hal_interrupt_configure(int vector, int level, int up)
+{
+
+#ifdef HAL_EXTENDED_INTERRUPT_CONFIGURE
+    // Use platform specific handling, if defined
+    // Note: this macro should do a 'return' for "extended" values of 'vector'
+    // Normal vectors are handled by code subsequent to the macro call.
+    HAL_EXTENDED_INTERRUPT_CONFIGURE(vector, level, up);
+#endif
+}
+
+void hal_interrupt_set_level(int vector, int level)
+{
+
+#ifdef HAL_EXTENDED_INTERRUPT_SET_LEVEL
+    // Use platform specific handling, if defined
+    // Note: this macro should do a 'return' for "extended" values of 'vector'
+    // Normal vectors are handled by code subsequent to the macro call.
+    HAL_EXTENDED_INTERRUPT_SET_LEVEL(vector, level);
+#endif
+
+    // Interrupt priorities are not configurable.
+}
+
+unsigned int mxc_nfc_soc_setup(unsigned int pg_sz, unsigned int io_sz, unsigned int is_mlc)
+{
+    return MXC_NFC_V2;
+}
+
+static void check_correct_chip(void)
+{
+    if (find_correct_chip == CHIP_VERSION_UNKNOWN) {
+        diag_printf("Unrecognized chip version: 0x%x!!!\n", read_system_rev());
+        diag_printf("Assuming chip version=0x%x\n", system_rev);
+    } else if (find_correct_chip == CHIP_VERSION_NONE) {
+        diag_printf("Unrecognized chip: 0x%x!!!\n", readl(IIM_BASE_ADDR + IIM_PREV_OFF));
+    }
+}
+
+RedBoot_init(check_correct_chip, RedBoot_INIT_LAST);
diff -urN -x CVS -x doc -x lwip_tcpip -x calmrisc16 -x calmrisc32 ecos_20050912/packages/redboot/current/cdl/redboot.cdl ecos_base/packages/redboot/current/cdl/redboot.cdl
--- ecos_20050912/packages/redboot/current/cdl/redboot.cdl	2005-09-08 07:14:30.000000000 -0500
+++ ecos_base/packages/redboot/current/cdl/redboot.cdl	2006-09-06 18:46:11.000000000 -0500
@@ -212,7 +212,7 @@
             cdl_option CYGPRI_REDBOOT_ZLIB_FLASH {
                  display       "Support compression of Flash images"
                  active_if     CYGPKG_REDBOOT_FLASH
-                 active_if     !CYGSEM_IO_FLASH_READ_INDIRECT
+                 active_if     { (!CYGSEM_IO_FLASH_READ_INDIRECT) || CYGPRI_REDBOOT_ZLIB_FLASH_FORCE }
                  calculated    1
                  description   "
                         This CDL indicates whether flash images can
@@ -227,6 +227,13 @@
                         to uncompress GZIP compressed data."
                  compile -library=libextras.a gunzip.c
             }
+
+            cdl_option CYGPRI_REDBOOT_ZLIB_FLASH_FORCE {
+                 display       "Turn on CYGPRI_REDBOOT_ZLIB_FLASH"
+                 default_value 0
+                 description   "
+                        Force CYGPRI_REDBOOT_ZLIB_FLASH to be chosen"
+            }
         }
 
         cdl_option CYGBLD_BUILD_REDBOOT_WITH_XYZMODEM {
@@ -238,6 +245,13 @@
             compile -library=libextras.a xyzModem.c
         }
 
+        cdl_option CYGBLD_BUILD_REDBOOT_WITH_MXCUSB {
+            display       "Include support for MXC USB downloads"
+            no_define
+            default_value 0
+            compile -library=libextras.a mxc_usb.c
+        }
+
         cdl_option CYGBLD_BUILD_REDBOOT_WITH_CKSUM {
             display       "Include POSIX checksum command"
             doc           ref/cksum-command.html
@@ -304,7 +318,7 @@
         cdl_option CYGDBG_REDBOOT_TICK_GRANULARITY {
             display          "Granularity of timer/ticks"
             flavor           data
-            legal_values     { 50 100 250 500 1000 }	
+            legal_values     { 10 25 50 100 250 500 1000 }	
             default_value    250
             description      "
                 This option controls the granularity of the timers.
@@ -1189,4 +1203,4 @@
     }
 }
 
-# EOF redboot.cdl
+# EOF redboot.cdl
diff -urN -x CVS -x doc -x lwip_tcpip -x calmrisc16 -x calmrisc32 ecos_20050912/packages/redboot/current/src/flash.c ecos_base/packages/redboot/current/src/flash.c
--- ecos_20050912/packages/redboot/current/src/flash.c	2005-09-08 07:14:34.000000000 -0500
+++ ecos_base/packages/redboot/current/src/flash.c	2008-03-19 23:22:29.000000000 -0500
@@ -1393,6 +1393,13 @@
             fis_addr = (void *)((CYG_ADDRESS)flash_start + 
                                 (CYGNUM_REDBOOT_FIS_DIRECTORY_BLOCK*flash_block_size));
         }
+#if defined(MXCFLASH_SELECT_NAND) || defined(MXCFLASH_SELECT_NAND)
+extern int mxc_nand_fis_start(void);
+        if (IS_FIS_FROM_NAND()) {
+            fis_addr = (void *)((CYG_ADDRESS)flash_start + mxc_nand_fis_start());
+        }
+#endif
+
         if (((CYG_ADDRESS)fis_addr + fisdir_size - 1) > (CYG_ADDRESS)flash_end) {
             diag_printf("FIS directory doesn't fit\n");
             return false;
diff -urN -x CVS -x doc -x lwip_tcpip -x calmrisc16 -x calmrisc32 ecos_20050912/packages/redboot/current/src/load.c ecos_base/packages/redboot/current/src/load.c
--- ecos_20050912/packages/redboot/current/src/load.c	2005-09-09 08:26:04.000000000 -0500
+++ ecos_base/packages/redboot/current/src/load.c	2006-09-06 21:19:58.000000000 -0500
@@ -74,7 +74,7 @@
 #endif
 #include <cyg/infra/cyg_ass.h>         // assertion macros
 
-static char usage[] = "[-r] [-v] "
+static char usage[] = "[-r] [-v] [-z to swap endianness on 16 bit] "
 #ifdef CYGBLD_BUILD_REDBOOT_WITH_ZLIB
                       "[-d] "
 #endif
@@ -289,8 +289,14 @@
 //
 // Load an ELF [binary] image 
 //
+//
+// Note that in case of multicore and the core we wanna load the 
+// image for is not in the same endianness that the core we run 
+// redboot from, have to invert bytes on 16-bit boundary 
+// (16-bit memory)
+//
 static unsigned long
-load_elf_image(getc_t getc, unsigned long base)
+load_elf_image(getc_t getc, unsigned long base, bool swap16bit)
 {
 #ifdef CYGSEM_REDBOOT_ELF
     Elf32_Ehdr ehdr;
@@ -298,7 +304,7 @@
     Elf32_Phdr phdr[MAX_PHDR];
     unsigned long offset = 0;
     int phx, len, ch;
-    unsigned char *addr;
+    unsigned char *addr, *addr_swap;
     unsigned long addr_offset = 0;
     unsigned long highest_address = 0;
     unsigned long lowest_address = 0xFFFFFFFF;
@@ -410,7 +416,25 @@
                     redboot_getc_terminate(true);
                     return 0;
                 }
-                *addr++ = ch;
+     
+                /* In case of multicore and the core we wanna load the image for is not in the same endianness
+	    	that the core we run redboot from, have to invert bytes on 16-bit boundary (16-bit memory)*/
+                if(swap16bit){
+                    // addr is even, have to write char data to the last address
+                    if(((unsigned long)addr)%2){
+                        addr_swap=addr-1;
+                        *addr_swap = ch;
+                    }
+                    // addr is odd, have to write char data to the next address
+                    else{
+                        addr_swap=addr+1;
+                       *addr_swap = ch;
+                    }
+                    addr++;
+                }
+                else {
+                    *addr++ = ch;
+            	}
                 offset++;
                 if ((unsigned long)(addr-addr_offset) > highest_address) {
                     highest_address = (unsigned long)(addr - addr_offset);
@@ -481,12 +505,17 @@
 // Because of this, "base" probably only makes sense for a set of
 // data which has only one section, e.g. a ROM image.
 //
+// Note that in case of multicore and the core we wanna load the 
+// image for is not in the same endianness that the core we run 
+// redboot from, have to invert bytes on 16-bit boundary 
+// (16-bit memory)
+//
 static unsigned long
-load_srec_image(getc_t getc, unsigned long base)
+load_srec_image(getc_t getc, unsigned long base, bool swap16bit)
 {
     int  c;
     long offset = 0, count, sum, val, cksum;
-    unsigned char *addr, *base_addr;
+    unsigned char *addr, *base_addr, *addr_swap;
     char type;
     bool first_addr = true;
     unsigned long addr_offset = 0;
@@ -543,8 +572,25 @@
             offset += count;
             while (count-- > 0) {
                 val = _hex2(getc, 1, &sum);
+                /* In case of multicore and the core we wanna load the image for is not in the same endianness
+	    	that the core we run redboot from, have to invert bytes on 16-bit boundary (16-bit memory)*/
+                if(swap16bit){
+                    // addr is even, have to write char data to the last address
+                    if(((unsigned long)addr)%2){
+                        addr_swap=addr-1;
+                        *addr_swap = val;
+                    }
+                    // addr is odd, have to write char data to the next address
+                    else{
+                        addr_swap=addr+1;
+                        *addr_swap = val;
+                    }
+                    addr++;
+                }
+                else {
                 *addr++ = val;
-            }
+                }
+            }
             cksum = _hex2(getc, 1, 0);
             offset += 1;
             sum = sum & 0xFF;
@@ -605,7 +651,7 @@
 {
     int res, num_options;
     int i, err;
-    bool verbose, raw;
+    bool verbose, raw, swap16bit;
     bool base_addr_set, mode_str_set;
     char *mode_str;
 #ifdef CYGPKG_REDBOOT_NETWORKING
@@ -624,7 +670,7 @@
     unsigned long end = 0;
     char type[4];
     char *filename = 0;
-    struct option_info opts[8];
+    struct option_info opts[9];
     connection_info_t info;
     getc_io_funcs_t *io = NULL;
     struct load_io_entry *io_tab;
@@ -648,7 +694,9 @@
               (void *)&base, (bool *)&base_addr_set, "load address");
     init_opts(&opts[3], 'm', true, OPTION_ARG_TYPE_STR, 
               (void *)&mode_str, (bool *)&mode_str_set, "download mode (TFTP, xyzMODEM, or disk)");
-    num_options = 4;
+    init_opts(&opts[4], 'z', false, OPTION_ARG_TYPE_FLG, 
+              (void *)&swap16bit, 0, "swap endianness on 16 bit");
+    num_options = 5;
 #if CYGNUM_HAL_VIRTUAL_VECTOR_NUM_CHANNELS > 1
     init_opts(&opts[num_options], 'c', true, OPTION_ARG_TYPE_NUM, 
               (void *)&chan, (bool *)&chan_set, "I/O channel");
@@ -776,6 +824,7 @@
     // Stream open, process the data
     if (raw) {
         unsigned char *mp = (unsigned char *)base;
+        unsigned char *addr_swap;
         err = 0;
         while ((res = redboot_getc()) >= 0) {
 #ifdef CYGSEM_REDBOOT_VALIDATE_USER_RAM_LOADS
@@ -789,8 +838,26 @@
                 break;
             }
 #endif
-            *mp++ = res;
-        }
+
+            /* In case of multicore and the core we wanna load the image for is not in the same endianness
+            that the core we run redboot from, have to invert bytes on 16-bit boundary (16-bit memory)*/
+            if(swap16bit){
+                // addr is even, have to write char data to the last address
+                if(((unsigned long)mp)%2){
+                    addr_swap=mp-1;
+                    *addr_swap = res;
+                }
+                // addr is odd, have to write char data to the next address
+                else{
+                   addr_swap=mp+1;
+                    *addr_swap = res;
+                }
+                mp++;
+            }
+            else {
+                *mp++ = res;
+            }
+        }
         end = (unsigned long) mp;
 
         // Save load base/top
@@ -815,10 +882,20 @@
             redboot_getc_rewind();  // Restore header to stream
             // Treat data as some sort of executable image
             if (strncmp(&type[1], "ELF", 3) == 0) {
-                end = load_elf_image(redboot_getc, base);
+            	if(swap16bit) {
+                    end = load_elf_image(redboot_getc, base, true);
+                }
+                else {
+                    end = load_elf_image(redboot_getc, base, false);
+                }
             } else if ((type[0] == 'S') &&
                        ((type[1] >= '0') && (type[1] <= '9'))) {
-		end = load_srec_image(redboot_getc, base);
+                if(swap16bit) {
+                    end = load_srec_image(redboot_getc, base, true);
+                }
+                else {
+                    end = load_srec_image(redboot_getc, base, false);
+                }
             } else {
                 redboot_getc_terminate(true);
                 diag_printf("Unrecognized image type: 0x%lx\n", *(unsigned long *)type);
@@ -828,4 +905,4 @@
 
     redboot_getc_close();  // Clean up
     return;
-}
+}
diff -urN -x CVS -x doc -x lwip_tcpip -x calmrisc16 -x calmrisc32 ecos_20050912/packages/redboot/current/src/main.c ecos_base/packages/redboot/current/src/main.c
--- ecos_20050912/packages/redboot/current/src/main.c	2005-06-07 13:55:52.000000000 -0500
+++ ecos_base/packages/redboot/current/src/main.c	2005-09-13 23:56:28.000000000 -0500
@@ -353,6 +353,7 @@
             }
             if (res != _GETS_TIMEOUT) break;
             script_timeout_ms -= CYGNUM_REDBOOT_CLI_IDLE_TIMEOUT;
+            hal_delay_us(CYGNUM_REDBOOT_CLI_IDLE_TIMEOUT*1000);            
         }
         if (res == _GETS_CTRLC) {
             script = (unsigned char *)0;  // Disable script
@@ -755,4 +756,4 @@
         }
     }
     return false;
-}
+}
diff -urN -x CVS -x doc -x lwip_tcpip -x calmrisc16 -x calmrisc32 ecos_20050912/packages/redboot/current/src/mxc_usb.c ecos_base/packages/redboot/current/src/mxc_usb.c
--- ecos_20050912/packages/redboot/current/src/mxc_usb.c	1969-12-31 18:00:00.000000000 -0600
+++ ecos_base/packages/redboot/current/src/mxc_usb.c	2006-09-13 13:52:38.000000000 -0500
@@ -0,0 +1,147 @@
+//==========================================================================
+//
+//      mxc_usb.c
+//
+//      usb download support for RedBoot
+//
+//==========================================================================
+//####ECOSGPLCOPYRIGHTBEGIN####
+// -------------------------------------------
+// This file is part of eCos, the Embedded Configurable Operating System.
+// Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+// Copyright (C) 2002, 2003 Gary Thomas
+//
+// eCos is free software; you can redistribute it and/or modify it under
+// the terms of the GNU General Public License as published by the Free
+// Software Foundation; either version 2 or (at your option) any later version.
+//
+// eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with eCos; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+//
+// As a special exception, if other files instantiate templates or use macros
+// or inline functions from this file, or you compile this file and link it
+// with other works to produce a work based on this file, this file does not
+// by itself cause the resulting work to be covered by the GNU General Public
+// License. However the source code for this file must still be made available
+// in accordance with section (3) of the GNU General Public License.
+//
+// This exception does not invalidate any other reasons why a work based on
+// this file might be covered by the GNU General Public License.
+//
+// Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+// at http://sources.redhat.com/ecos/ecos-license/
+// -------------------------------------------
+//####ECOSGPLCOPYRIGHTEND####
+//==========================================================================
+//#####DESCRIPTIONBEGIN####
+//
+// Author(s):    Kevin Zhang
+// Contributors: Kevin Zhang
+// Date:         2006-09-06
+// Purpose:      
+// Description:  this code is based on tftp_client.c
+//              
+// This code is part of RedBoot (tm).
+//
+//####DESCRIPTIONEND####
+//
+//==========================================================================
+
+#include <redboot.h>
+
+static struct {
+    bool open;
+    int  total_timeouts, packets_received;
+    unsigned long last_good_block;
+    int  avail, actual_len;
+//    char data[SEGSIZE+sizeof(struct mxcusbhdr)];
+//    char *bufp;
+} mxcusb_stream;
+
+extern void mxc_pcd_open(void);
+extern void mxc_pcd_exit(void);
+extern int mxc_pcd_int_hndlr(long buffer, long length);
+
+int
+mxcusb_stream_open(connection_info_t *info,
+                 int *err)
+{
+//    diag_printf("%s()\n", __FUNCTION__);
+    
+    mxc_pcd_open();
+    return 0;
+}
+
+void
+mxcusb_stream_close(int *err)
+{
+//    diag_printf("%s()\n", __FUNCTION__);
+
+    mxc_pcd_exit();
+}
+
+void
+mxcusb_stream_terminate(bool abort,
+                      int (*getc)(void))
+{
+    int err;
+
+//    diag_printf("%s()\n", __FUNCTION__);
+}
+
+int
+mxcusb_stream_read(char *buf,
+                 int len,
+                 int *err)
+{
+//    diag_printf("%s(len=%d buf=%x)\n", __FUNCTION__, len, buf);
+
+	return mxc_pcd_int_hndlr(buf, len);
+}
+
+char *
+mxcusb_error(int err)
+{
+    char *errmsg = "Unknown error";
+
+    diag_printf("%s()\n", __FUNCTION__);
+#if 0
+    switch (err) {
+    case MXCUSB_ENOTFOUND:
+        return "file not found";
+    case MXCUSB_EACCESS:
+        return "access violation";
+    case MXCUSB_ENOSPACE:
+        return "disk full or allocation exceeded";
+    case MXCUSB_EBADOP:
+        return "illegal MXCUSB operation";
+    case MXCUSB_EBADID:
+        return "unknown transfer ID";
+    case MXCUSB_EEXISTS:
+        return "file already exists";
+    case MXCUSB_ENOUSER:
+        return "no such user";
+    case MXCUSB_TIMEOUT:
+        return "operation timed out";
+    case MXCUSB_INVALID:
+        return "invalid parameter";
+    case MXCUSB_TOOLARGE:
+        return "file is larger than buffer";
+    }
+#endif
+    return errmsg;
+}
+
+//
+// RedBoot interface
+//
+GETC_IO_FUNCS(mxcusb_io, mxcusb_stream_open, mxcusb_stream_close,
+              mxcusb_stream_terminate, mxcusb_stream_read, mxcusb_error);
+RedBoot_load(usb, mxcusb_io, true, false, 0);
+
diff -urN -x CVS -x doc -x lwip_tcpip -x calmrisc16 -x calmrisc32 ecos_20050912/packages/redboot/current/src/net/bootp.c ecos_base/packages/redboot/current/src/net/bootp.c
--- ecos_20050912/packages/redboot/current/src/net/bootp.c	2005-02-01 12:25:52.000000000 -0600
+++ ecos_base/packages/redboot/current/src/net/bootp.c	2005-09-13 23:56:29.000000000 -0500
@@ -60,7 +60,7 @@
 #define SHOULD_BE_RANDOM  0x12345555
 
 /* How many milliseconds to wait before retrying the request */
-#define RETRY_TIME  2000
+#define RETRY_TIME  20
 #define MAX_RETRIES    8
 
 static bootp_header_t *bp_info;
@@ -341,4 +341,4 @@
     return -1;
 }
 
-
+
diff -urN -x CVS -x doc -x lwip_tcpip -x calmrisc16 -x calmrisc32 ecos_20050912/packages/redboot/current/src/net/tftp_client.c ecos_base/packages/redboot/current/src/net/tftp_client.c
--- ecos_20050912/packages/redboot/current/src/net/tftp_client.c	2005-09-09 08:26:04.000000000 -0500
+++ ecos_base/packages/redboot/current/src/net/tftp_client.c	2005-09-27 14:22:16.000000000 -0500
@@ -164,13 +164,13 @@
     struct tftphdr *hdr = (struct tftphdr *)tftp_stream.data;
 
     if (strlen(msg) > (SEGSIZE-1)) {
-      *(msg + SEGSIZE) = NULL;
+      *(msg + SEGSIZE) = (char)NULL;
     }
 
     if (tftp_stream.packets_received > 0) {
         hdr->th_opcode = htons(ERROR);
         hdr->th_code = code;
-        strcpy(&hdr->th_data, msg);
+        strcpy((char*)&hdr->th_data, msg);
         if (__udp_sendto(tftp_stream.data, (5 + strlen(msg)), 
                          &tftp_stream.from_addr, &tftp_stream.local_addr) < 0) {
             // Problem sending ACK
diff -urN -x CVS -x doc -x lwip_tcpip -x calmrisc16 -x calmrisc32 ecos_20050912/packages/services/diagnosis/current/cdl/diagnosis.cdl ecos_base/packages/services/diagnosis/current/cdl/diagnosis.cdl
--- ecos_20050912/packages/services/diagnosis/current/cdl/diagnosis.cdl	1969-12-31 18:00:00.000000000 -0600
+++ ecos_base/packages/services/diagnosis/current/cdl/diagnosis.cdl	2008-03-14 01:19:19.000000000 -0500
@@ -0,0 +1,83 @@
+# ====================================================================
+#
+#      diagnosis.cdl
+#
+#      diagnosis configuration data. 
+#
+# ====================================================================
+#####ECOSGPLCOPYRIGHTBEGIN####
+## -------------------------------------------
+## This file is part of eCos, the Embedded Configurable Operating System.
+## Copyright (C) 2008 Freescale
+##
+## eCos is free software; you can redistribute it and/or modify it under
+## the terms of the GNU General Public License as published by the Free
+## Software Foundation; either version 2 or (at your option) any later version.
+##
+## eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+## WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+## for more details.
+##
+## You should have received a copy of the GNU General Public License along
+## with eCos; if not, write to the Free Software Foundation, Inc.,
+## 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+##
+## As a special exception, if other files instantiate templates or use macros
+## or inline functions from this file, or you compile this file and link it
+## with other works to produce a work based on this file, this file does not
+## by itself cause the resulting work to be covered by the GNU General Public
+## License. However the source code for this file must still be made available
+## in accordance with section (3) of the GNU General Public License.
+##
+## This exception does not invalidate any other reasons why a work based on
+## this file might be covered by the GNU General Public License.
+##
+## Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+## at http://sources.redhat.com/ecos/ecos-license/
+## -------------------------------------------
+#####ECOSGPLCOPYRIGHTEND####
+# ====================================================================
+######DESCRIPTIONBEGIN####
+#
+# Author(s):      Fred.Fan
+# Original data:  Fred.Fan
+# Contributors:
+# Date:           2008-03-15
+#
+#####DESCRIPTIONEND####
+#
+# ====================================================================
+
+cdl_package CYGPKG_DIAGNOSIS {
+    display       "Diagnostic tools"
+    include_dir   cyg/diagnosis
+#   doc           ref/services-diagnosis.html
+
+    description "
+      This package provides support for hardware diagnosis."
+
+    compile -library=libextras.a core.c 
+
+    cdl_component CYGPKG_MEMORY_DIAGNOSIS {
+        display "memory diagnosis"
+        flavor  bool
+
+	description "This option includes memory test cases."
+	
+        compile -library=libextras.a memory/cmds.c
+	
+	cdl_option CYGSEM_RAM_RW_DIAGNOSIS {
+                display "perform ram read/write diagnosis"
+                flavor  bool
+                default_value 1
+         
+	       	description      "
+                    This option is overriden by the configuration in hal."
+
+		compile memory/ram_rw.c
+	}
+    }
+}
+
+
diff -urN -x CVS -x doc -x lwip_tcpip -x calmrisc16 -x calmrisc32 ecos_20050912/packages/services/diagnosis/current/include/diagnosis.h ecos_base/packages/services/diagnosis/current/include/diagnosis.h
--- ecos_20050912/packages/services/diagnosis/current/include/diagnosis.h	1969-12-31 18:00:00.000000000 -0600
+++ ecos_base/packages/services/diagnosis/current/include/diagnosis.h	2008-03-14 01:19:19.000000000 -0500
@@ -0,0 +1,19 @@
+#ifndef _DIAGNOSIS_H_
+#define _DIAGNOSIS_H_
+
+#include <pkgconf/hal.h>
+#include <cyg/hal/hal_arch.h>
+#include <cyg/hal/hal_cache.h>
+#include <redboot.h>
+#include <stdlib.h>
+
+#include <pkgconf/diagnosis.h>
+
+#ifdef CYGPKG_MEMORY_DIAGNOSIS
+#include <cyg/diagnosis/memory.h>
+#endif
+
+extern struct cmd __DIAGNOSIS_cmds_TAB__[], __DIAGNOSIS_cmds_TAB_END__;
+extern void diagnosis_usage(char *why);
+
+#endif 		/* _DIAGNOSIS_H_ */
diff -urN -x CVS -x doc -x lwip_tcpip -x calmrisc16 -x calmrisc32 ecos_20050912/packages/services/diagnosis/current/include/memory.h ecos_base/packages/services/diagnosis/current/include/memory.h
--- ecos_20050912/packages/services/diagnosis/current/include/memory.h	1969-12-31 18:00:00.000000000 -0600
+++ ecos_base/packages/services/diagnosis/current/include/memory.h	2008-03-14 01:19:19.000000000 -0500
@@ -0,0 +1,12 @@
+#ifndef __DIAGNOSIS_MEMORY_H_
+#define __DIAGNOSIS_MEMORY_H_
+
+#ifdef CYGSEM_RAM_RW_DIAGNOSIS
+extern void ram_rw_test(int argc, char * argv[]);
+#endif
+
+enum {
+DIAGNOSIS_MEM_RAM_RD = 0,
+};
+
+#endif 		/* __DIAGNOSIS_MEMORY_H_ */
diff -urN -x CVS -x doc -x lwip_tcpip -x calmrisc16 -x calmrisc32 ecos_20050912/packages/services/diagnosis/current/src/core.c ecos_base/packages/services/diagnosis/current/src/core.c
--- ecos_20050912/packages/services/diagnosis/current/src/core.c	1969-12-31 18:00:00.000000000 -0600
+++ ecos_base/packages/services/diagnosis/current/src/core.c	2008-03-14 01:19:20.000000000 -0500
@@ -0,0 +1,42 @@
+#include <redboot.h>
+#include <stdlib.h>
+#include <cyg/diagnosis/diagnosis.h>
+
+#include CYGHWR_MEMORY_LAYOUT_H
+
+// Define table boundaries
+CYG_HAL_TABLE_BEGIN( __DIAGNOSIS_cmds_TAB__, DIAGNOSIS_cmds);
+CYG_HAL_TABLE_END( __DIAGNOSIS_cmds_TAB_END__, DIAGNOSIS_cmds);
+
+// CLI function
+static cmd_fun do_diagnosis_cmds;
+RedBoot_nested_cmd("diagnosis",
+           "Tools for diagnosis system",
+           "{cmds}",
+           do_diagnosis_cmds,
+           __DIAGNOSIS_cmds_TAB__, &__DIAGNOSIS_cmds_TAB_END__
+          );
+
+
+
+void diagnosis_usage(char *why)
+{
+    diag_printf("*** invalid 'diagnosis' command: %s\n", why);
+    cmd_usage(__DIAGNOSIS_cmds_TAB__, &__DIAGNOSIS_cmds_TAB_END__, "diagnosis ");
+}
+
+static void do_diagnosis_cmds(int argc, char *argv[])
+{
+	struct cmd * cmd;
+	if (argc < 2) {
+        	diagnosis_usage("too few arguments");
+        	return;
+    	}
+	if ((cmd = cmd_search(__DIAGNOSIS_cmds_TAB__, 
+			  &__DIAGNOSIS_cmds_TAB_END__,
+                          argv[1])) != (struct cmd *)0) {
+        	(cmd->fun)(argc, argv);
+        	return;
+    	}
+    	diagnosis_usage("unrecognized command");
+}
diff -urN -x CVS -x doc -x lwip_tcpip -x calmrisc16 -x calmrisc32 ecos_20050912/packages/services/diagnosis/current/src/memory/cmds.c ecos_base/packages/services/diagnosis/current/src/memory/cmds.c
--- ecos_20050912/packages/services/diagnosis/current/src/memory/cmds.c	1969-12-31 18:00:00.000000000 -0600
+++ ecos_base/packages/services/diagnosis/current/src/memory/cmds.c	2008-03-14 01:19:20.000000000 -0500
@@ -0,0 +1,11 @@
+#include <cyg/diagnosis/diagnosis.h>
+
+#ifdef CYGSEM_RAM_RW_DIAGNOSIS
+local_cmd_entry("ram_rw",
+        "ram read/write accessing",
+        "-c iterators -b <base address> -l <length> "\
+        "-p pattern -m case [-s]\n",
+        ram_rw_test,
+        DIAGNOSIS_cmds
+           );
+#endif
diff -urN -x CVS -x doc -x lwip_tcpip -x calmrisc16 -x calmrisc32 ecos_20050912/packages/services/diagnosis/current/src/memory/ram_rw.c ecos_base/packages/services/diagnosis/current/src/memory/ram_rw.c
--- ecos_20050912/packages/services/diagnosis/current/src/memory/ram_rw.c	1969-12-31 18:00:00.000000000 -0600
+++ ecos_base/packages/services/diagnosis/current/src/memory/ram_rw.c	2008-03-14 01:19:20.000000000 -0500
@@ -0,0 +1,129 @@
+#include <redboot.h>
+#include <stdlib.h>
+#include <cyg/diagnosis/diagnosis.h>
+#include <cyg/hal/plf_io.h>
+
+#include CYGHWR_MEMORY_LAYOUT_H
+
+
+static int loops;
+static unsigned int pattern1, pattern2;
+static unsigned int start;
+static int length;
+static int burst = 0;
+
+static void raw_rw_case1(void)
+{
+	unsigned int * current_write;
+	unsigned int * current_read;
+	int round = 0;
+	diag_printf("RAM diagnostical pattern from David.Young of freescale\n");
+	diag_printf("burst is %s\n", burst?"enabled":"disabled");
+	while( (round++) < loops) {
+	    if(burst) {
+		current_write =(unsigned int *)start;
+		memset(current_write, (pattern1&0xFF000000)>>24, length);
+	    } else {
+		for(current_write=(unsigned int *)start; current_write<(unsigned int *)(start + length); current_write += 2) {
+			*current_write = ((unsigned int)current_write & 0x0000FFFF)|(0xFFFF0000 & pattern1);
+		}
+		for(current_write=(unsigned int *)start + 1; current_write<(unsigned int *)(start + length); current_write += 2) {
+			*current_write = ((unsigned int)current_write & 0x0000FFFF)|(0xFFFF0000 & pattern2);
+		}
+	    }	
+		for(current_read=(unsigned int *)start; current_read<(unsigned int *)(start + length); current_read ++) {
+		    if(burst) {
+			if((*current_read) != pattern2) {
+					diag_printf("\tround %d::[0x%08x]=0x%08x:0x%08x\n", round, current_read, pattern2, *current_read);
+					goto fail;
+
+			}
+		    } else {
+			if((current_read - (unsigned int *)start)&1) {
+				if(((*current_read)&0xFFFF0000) != (pattern2&0xFFFF0000)) {
+					diag_printf("\tround %d::[0x%08x]=0x%08x:0x%08x\n", round, current_read, (pattern2&0xFFFF0000)|((unsigned int)current_read)&0xFFFF, *current_read);
+					goto fail;
+				}	
+			} else {
+				if(((*current_read)&0xFFFF0000) != (pattern1&0xFFFF0000)) {
+					diag_printf("\tround %d::[0x%08x]=0x%08x:0x%08x\n", round, current_read, (pattern1&0xFFFF0000)|((unsigned int)current_read)&0xFFFF, *current_read);
+					goto fail;
+				}	
+
+			}
+		    }
+		}	
+	}
+	diag_printf("Diagnosis is successful!\n");
+	return;
+fail:
+	diag_printf("Diagnosis is failure !\n");	
+}
+
+void ram_rw_test(int argc, char * argv[])
+{
+	int opts_map[6];
+	struct option_info opts[6];
+	int mode;
+
+	memset(opts_map, 0, sizeof(int)*5);
+
+	init_opts(&opts[0], 'c', true, OPTION_ARG_TYPE_NUM,
+          (void *)&loops, (bool *)&opts_map[0], "the rounds of test");
+    	init_opts(&opts[1], 'b', true, OPTION_ARG_TYPE_NUM,
+          (void *)&start, (bool *)&opts_map[1], "accessing start address");
+    	init_opts(&opts[2], 'l', true, OPTION_ARG_TYPE_NUM,
+          (void *)&length, (bool *)&opts_map[2], "accessing size(bytes)");
+    	init_opts(&opts[3], 'p', true, OPTION_ARG_TYPE_NUM,
+          (void *)&pattern1, (bool *)&opts_map[3], "High 16bit is valid");
+    	init_opts(&opts[4], 'm', true, OPTION_ARG_TYPE_NUM,
+          (void *)&mode, (bool *)&opts_map[4], "Test case number");
+    	init_opts(&opts[5], 's', false, OPTION_ARG_TYPE_FLG,
+          (void *)&burst, (bool *)0, "enable bust mode(based on memset)");
+
+	if (!scan_opts(argc, argv, 2, opts, 6, 0, 0, 0)) {
+        	diagnosis_usage("invalid arguments");
+        	return;
+    	}
+
+	if(!opts_map[0]) {
+		loops = 32;
+	} 
+
+	if(!opts_map[1]) {
+		start = 0x80000;
+	}
+
+	if(!opts_map[2]) {
+		length = 8192;
+	}
+	
+	if(!opts_map[3]) {
+		pattern1 = 0x55550000;
+	}
+
+	if(!opts_map[4]) {
+		mode = DIAGNOSIS_MEM_RAM_RD;
+	}
+
+	if(burst) {
+		pattern2 = (pattern1&0xFF000000);
+		pattern2 |= pattern2>>8;
+		pattern2 |= pattern2>>16;
+	} else {
+		pattern2 = (~pattern1)&0xFFFF0000;
+	}
+
+	if(!valid_address((unsigned char *)start)) {
+		if (!verify_action("Specified address (%p) is not believed to be in RAM", (void*)start))
+            return;
+	}
+
+	switch(mode) {
+	case DIAGNOSIS_MEM_RAM_RD:
+		raw_rw_case1();
+		break;
+	default:
+		diag_printf("Invalid memory diagnosis case!\n");	
+	}
+}
diff -urN -x CVS -x doc -x lwip_tcpip -x calmrisc16 -x calmrisc32 ecos_20050912/packages/services/memalloc/common/current/src/heapgen.tcl ecos_base/packages/services/memalloc/common/current/src/heapgen.tcl
--- ecos_20050912/packages/services/memalloc/common/current/src/heapgen.tcl	2004-10-04 06:48:34.000000000 -0500
+++ ecos_base/packages/services/memalloc/common/current/src/heapgen.tcl	2006-01-26 15:00:45.000000000 -0600
@@ -1,201 +1,201 @@
-#!/bin/bash
-# restart using a Tcl shell \
-    exec sh -c 'for tclshell in tclsh tclsh83 cygtclsh80 ; do \
-            ( echo | $tclshell ) 2> /dev/null && exec $tclshell "`( cygpath -w \"$0\" ) 2> /dev/null || echo $0`" "$@" ; \
-        done ; \
-        echo "heapgen.tcl: cannot find Tcl shell" ; exit 1' "$0" "$@"
-
-#===============================================================================
-#
-#    heapgen.tcl
-#
-#    Script to generate memory pool instantiations based on the memory map
-#
-#===============================================================================
-#####ECOSGPLCOPYRIGHTBEGIN####
-## -------------------------------------------
-## This file is part of eCos, the Embedded Configurable Operating System.
-## Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
-##
-## eCos is free software; you can redistribute it and/or modify it under
-## the terms of the GNU General Public License as published by the Free
-## Software Foundation; either version 2 or (at your option) any later version.
-##
-## eCos is distributed in the hope that it will be useful, but WITHOUT ANY
-## WARRANTY; without even the implied warranty of MERCHANTABILITY or
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-## for more details.
-##
-## You should have received a copy of the GNU General Public License along
-## with eCos; if not, write to the Free Software Foundation, Inc.,
-## 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
-##
-## As a special exception, if other files instantiate templates or use macros
-## or inline functions from this file, or you compile this file and link it
-## with other works to produce a work based on this file, this file does not
-## by itself cause the resulting work to be covered by the GNU General Public
-## License. However the source code for this file must still be made available
-## in accordance with section (3) of the GNU General Public License.
-##
-## This exception does not invalidate any other reasons why a work based on
-## this file might be covered by the GNU General Public License.
-##
-## Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
-## at http://sources.redhat.com/ecos/ecos-license/
-## -------------------------------------------
-#####ECOSGPLCOPYRIGHTEND####
-#===============================================================================
-######DESCRIPTIONBEGIN####
-#
-# Author(s):	jlarmour
-# Contributors:	
-# Date:		2000-06-13
-# Purpose:      Generate memory pool instantiations based on the memory map
-#               along with information in a header file to allow access from
-#               C source
-# Description:
-# Usage:
-#
-#####DESCRIPTIONEND####
-#===============================================================================
-
-set debug 0
-
-proc dputs { args } {
-    global debug
-    if { $debug > 0 } {
-        puts -nonewline "DEBUG: "
-        foreach i $args {
-          puts -nonewline $i
-        }
-        puts ""
-    }
-}
-
-proc tcl_path { posix_path } {
-    global tcl_platform
-    if { $tcl_platform(platform) == "windows" } {
-        return [ exec cygpath -w $posix_path ]
-    } else {
-        return $posix_path
-    }
-}
-
-dputs "argc=" $argc
-dputs "argv=" $argv
-
-if { $argc != 2 } {
-    error "Usage: heapgen.tcl installdir builddir"
-}
-
-set installdir [ tcl_path [ lindex $argv 0 ] ]
-set builddir   [ tcl_path [ lindex $argv 1 ] ]
-
-dputs "builddir=" $builddir
-dputs "installdir=" $installdir
-dputs "pwd=" [pwd]
-
-# Fetch relevant config data placed in the generated file heapgeninc.tcl
-source [ file join $builddir heapgeninc.tcl ]
-
-dputs "memlayout_h=" $memlayout_h
-
-# ----------------------------------------------------------------------------
-# Get heap information
-
-# trim brackets
-set ldi_name [ string trim $memlayout_ldi "<>" ]
-dputs $ldi_name 
-# prefix full leading path including installdir
-set ldifile [open [ file join $installdir include $ldi_name ] r]
-
-# now read the .ldi file and find the user-defined sections with the
-# prefix "heap"
-set heaps ""
-while { [gets $ldifile line] >= 0} {
-    # Search for user-defined name beginning heap (possibly with leading
-    # underscores
-    if [ regexp {^[ \t]+(CYG_LABEL_DEFN\(|)[ \t]*_*heap} $line ] {
-        set heapnamestart [ string first heap $line ]
-        set heapnameend1 [ string first ")" $line ]
-        incr heapnameend1 -1
-        set heapnameend2 [ string wordend $line $heapnamestart ]
-        if { $heapnameend1 < 0 } {
-            set $heapnameend1 $heapnameend2
-        }
-        set heapnameend [ expr $heapnameend1 < $heapnameend2 ? $heapnameend1 : $heapnameend2 ]
-        set heapname [ string range $line $heapnamestart $heapnameend ]
-        set heaps [ concat $heaps $heapname ]
-        dputs [ format "Found heap \"%s\"" $heapname ]
-    }
-}
-close $ldifile
-
-set heapcount [ llength $heaps ]
-set heapcount1 [ expr 1 + $heapcount ]
-
-# ----------------------------------------------------------------------------
-# Generate header file
-
-# Could have made it generate the header file straight into include/pkgconf,
-# but that knowledge of the build system is best left in the make rules in CDL
-
-set hfile [ open [ file join $builddir heaps.hxx ] w]
-puts $hfile "#ifndef CYGONCE_PKGCONF_HEAPS_HXX"
-puts $hfile "#define CYGONCE_PKGCONF_HEAPS_HXX"
-puts $hfile "/* <pkgconf/heaps.hxx> */\n"
-puts $hfile "/* This is a generated file - do not edit! */\n"
-# Allow CYGMEM_HEAP_COUNT to be available to the implementation header file
-puts $hfile [ format "#define CYGMEM_HEAP_COUNT %d" $heapcount ]
-puts $hfile [ concat "#include " $malloc_impl_h ]
-puts $hfile ""
-puts $hfile [ format "extern %s *cygmem_memalloc_heaps\[ %d \];" \
-        $malloc_impl_class $heapcount1 ]
-puts $hfile "\n#endif"
-puts $hfile "/* EOF <pkgconf/heaps.hxx> */"
-close $hfile
-
-# ----------------------------------------------------------------------------
-# Generate C file in the current directory (ie. the build directory)
-# that instantiates the pools
-
-set cfile [ open [ file join $builddir heaps.cxx ] w ]
-puts $cfile "/* heaps.cxx */\n"
-puts $cfile "/* This is a generated file - do not edit! */\n"
-puts $cfile "#include <pkgconf/heaps.hxx>"
-puts $cfile [ concat "#include " $memlayout_h ]
-puts $cfile "#include <cyg/infra/cyg_type.h>"
-puts $cfile "#include <cyg/hal/hal_intr.h>"
-puts $cfile [ concat "#include " $malloc_impl_h ]
-puts $cfile ""
-
-foreach heap $heaps {
-    puts $cfile "#ifdef HAL_MEM_REAL_REGION_TOP\n"
-
-    puts $cfile [ format "%s CYGBLD_ATTRIB_INIT_PRI(CYG_INIT_MEMALLOC) cygmem_pool_%s ( (cyg_uint8 *)CYGMEM_SECTION_%s ," \
-            $malloc_impl_class $heap $heap ]
-    puts $cfile [ format "    HAL_MEM_REAL_REGION_TOP( (cyg_uint8 *)CYGMEM_SECTION_%s + CYGMEM_SECTION_%s_SIZE ) - (cyg_uint8 *)CYGMEM_SECTION_%s ) " \
-            $heap $heap $heap ]
-    puts $cfile "        ;\n"
-
-    puts $cfile "#else\n"
-
-    puts $cfile [ format "%s CYGBLD_ATTRIB_INIT_PRI(CYG_INIT_MEMALLOC) cygmem_pool_%s ( (cyg_uint8 *)CYGMEM_SECTION_%s , CYGMEM_SECTION_%s_SIZE ) ;\n" \
-            $malloc_impl_class $heap $heap $heap ]
-
-    puts $cfile "#endif"
-}
-
-puts $cfile ""
-puts $cfile [ format "%s *cygmem_memalloc_heaps\[ %d \] = { " \
-        $malloc_impl_class $heapcount1 ]
-foreach heap $heaps {
-    puts $cfile [ format "    &cygmem_pool_%s," $heap ]
-}
-puts $cfile "    NULL\n};"
-
-puts $cfile "\n/* EOF heaps.cxx */"
-close $cfile
-
-# ----------------------------------------------------------------------------
-# EOF heapgen.tcl
+#!/bin/bash
+# restart using a Tcl shell \
+    exec sh -c 'for tclshell in tclsh tclsh83 cygtclsh80 ; do \
+            ( echo | $tclshell ) 2> /dev/null && exec $tclshell "`( cygpath -w \"$0\" ) 2> /dev/null || echo $0`" "$@" ; \
+        done ; \
+        echo "heapgen.tcl: cannot find Tcl shell" ; exit 1' "$0" "$@"
+
+#===============================================================================
+#
+#    heapgen.tcl
+#
+#    Script to generate memory pool instantiations based on the memory map
+#
+#===============================================================================
+#####ECOSGPLCOPYRIGHTBEGIN####
+## -------------------------------------------
+## This file is part of eCos, the Embedded Configurable Operating System.
+## Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+##
+## eCos is free software; you can redistribute it and/or modify it under
+## the terms of the GNU General Public License as published by the Free
+## Software Foundation; either version 2 or (at your option) any later version.
+##
+## eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+## WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+## for more details.
+##
+## You should have received a copy of the GNU General Public License along
+## with eCos; if not, write to the Free Software Foundation, Inc.,
+## 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+##
+## As a special exception, if other files instantiate templates or use macros
+## or inline functions from this file, or you compile this file and link it
+## with other works to produce a work based on this file, this file does not
+## by itself cause the resulting work to be covered by the GNU General Public
+## License. However the source code for this file must still be made available
+## in accordance with section (3) of the GNU General Public License.
+##
+## This exception does not invalidate any other reasons why a work based on
+## this file might be covered by the GNU General Public License.
+##
+## Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+## at http://sources.redhat.com/ecos/ecos-license/
+## -------------------------------------------
+#####ECOSGPLCOPYRIGHTEND####
+#===============================================================================
+######DESCRIPTIONBEGIN####
+#
+# Author(s):	jlarmour
+# Contributors:	
+# Date:		2000-06-13
+# Purpose:      Generate memory pool instantiations based on the memory map
+#               along with information in a header file to allow access from
+#               C source
+# Description:
+# Usage:
+#
+#####DESCRIPTIONEND####
+#===============================================================================
+
+set debug 0
+
+proc dputs { args } {
+    global debug
+    if { $debug > 0 } {
+        puts -nonewline "DEBUG: "
+        foreach i $args {
+          puts -nonewline $i
+        }
+        puts ""
+    }
+}
+
+proc tcl_path { posix_path } {
+    global tcl_platform
+    if { $tcl_platform(platform) == "windows" } {
+        return [ exec cygpath -w $posix_path ]
+    } else {
+        return $posix_path
+    }
+}
+
+dputs "argc=" $argc
+dputs "argv=" $argv
+
+if { $argc != 2 } {
+    error "Usage: heapgen.tcl installdir builddir"
+}
+
+set installdir [ tcl_path [ lindex $argv 0 ] ]
+set builddir   [ tcl_path [ lindex $argv 1 ] ]
+
+dputs "builddir=" $builddir
+dputs "installdir=" $installdir
+dputs "pwd=" [pwd]
+
+# Fetch relevant config data placed in the generated file heapgeninc.tcl
+source [ file join $builddir heapgeninc.tcl ]
+
+dputs "memlayout_h=" $memlayout_h
+
+# ----------------------------------------------------------------------------
+# Get heap information
+
+# trim brackets
+set ldi_name [ string trim $memlayout_ldi "<>" ]
+dputs $ldi_name 
+# prefix full leading path including installdir
+set ldifile [open [ file join $installdir include $ldi_name ] r]
+
+# now read the .ldi file and find the user-defined sections with the
+# prefix "heap"
+set heaps ""
+while { [gets $ldifile line] >= 0} {
+    # Search for user-defined name beginning heap (possibly with leading
+    # underscores
+    if [ regexp {^[ \t]+(CYG_LABEL_DEFN\(|)[ \t]*_*heap} $line ] {
+        set heapnamestart [ string first heap $line ]
+        set heapnameend1 [ string first ")" $line ]
+        incr heapnameend1 -1
+        set heapnameend2 [ string wordend $line $heapnamestart ]
+        if { $heapnameend1 < 0 } {
+            set $heapnameend1 $heapnameend2
+        }
+        set heapnameend [ expr $heapnameend1 < $heapnameend2 ? $heapnameend1 : $heapnameend2 ]
+        set heapname [ string range $line $heapnamestart $heapnameend ]
+        set heaps [ concat $heaps $heapname ]
+        dputs [ format "Found heap \"%s\"" $heapname ]
+    }
+}
+close $ldifile
+
+set heapcount [ llength $heaps ]
+set heapcount1 [ expr 1 + $heapcount ]
+
+# ----------------------------------------------------------------------------
+# Generate header file
+
+# Could have made it generate the header file straight into include/pkgconf,
+# but that knowledge of the build system is best left in the make rules in CDL
+
+set hfile [ open [ file join $builddir heaps.hxx ] w]
+puts $hfile "#ifndef CYGONCE_PKGCONF_HEAPS_HXX"
+puts $hfile "#define CYGONCE_PKGCONF_HEAPS_HXX"
+puts $hfile "/* <pkgconf/heaps.hxx> */\n"
+puts $hfile "/* This is a generated file - do not edit! */\n"
+# Allow CYGMEM_HEAP_COUNT to be available to the implementation header file
+puts $hfile [ format "#define CYGMEM_HEAP_COUNT %d" $heapcount ]
+puts $hfile [ concat "#include " $malloc_impl_h ]
+puts $hfile ""
+puts $hfile [ format "extern %s *cygmem_memalloc_heaps\[ %d \];" \
+        $malloc_impl_class $heapcount1 ]
+puts $hfile "\n#endif"
+puts $hfile "/* EOF <pkgconf/heaps.hxx> */"
+close $hfile
+
+# ----------------------------------------------------------------------------
+# Generate C file in the current directory (ie. the build directory)
+# that instantiates the pools
+
+set cfile [ open [ file join $builddir heaps.cxx ] w ]
+puts $cfile "/* heaps.cxx */\n"
+puts $cfile "/* This is a generated file - do not edit! */\n"
+puts $cfile "#include <pkgconf/heaps.hxx>"
+puts $cfile [ concat "#include " $memlayout_h ]
+puts $cfile "#include <cyg/infra/cyg_type.h>"
+puts $cfile "#include <cyg/hal/hal_intr.h>"
+puts $cfile [ concat "#include " $malloc_impl_h ]
+puts $cfile ""
+
+foreach heap $heaps {
+    puts $cfile "#ifdef HAL_MEM_REAL_REGION_TOP\n"
+
+    puts $cfile [ format "%s CYGBLD_ATTRIB_INIT_PRI(CYG_INIT_MEMALLOC) cygmem_pool_%s ( (cyg_uint8 *)CYGMEM_SECTION_%s ," \
+            $malloc_impl_class $heap $heap ]
+    puts $cfile [ format "    HAL_MEM_REAL_REGION_TOP( (cyg_uint8 *)CYGMEM_SECTION_%s + CYGMEM_SECTION_%s_SIZE ) - (cyg_uint8 *)CYGMEM_SECTION_%s ) " \
+            $heap $heap $heap ]
+    puts $cfile "        ;\n"
+
+    puts $cfile "#else\n"
+
+    puts $cfile [ format "%s CYGBLD_ATTRIB_INIT_PRI(CYG_INIT_MEMALLOC) cygmem_pool_%s ( (cyg_uint8 *)CYGMEM_SECTION_%s , CYGMEM_SECTION_%s_SIZE ) ;\n" \
+            $malloc_impl_class $heap $heap $heap ]
+
+    puts $cfile "#endif"
+}
+
+puts $cfile ""
+puts $cfile [ format "%s *cygmem_memalloc_heaps\[ %d \] = { " \
+        $malloc_impl_class $heapcount1 ]
+foreach heap $heaps {
+    puts $cfile [ format "    &cygmem_pool_%s," $heap ]
+}
+puts $cfile "    NULL\n};"
+
+puts $cfile "\n/* EOF heaps.cxx */"
+close $cfile
+
+# ----------------------------------------------------------------------------
+# EOF heapgen.tcl
