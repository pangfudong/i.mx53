diff -urN -x CVS dummy/packages/devs/eth/arm/mx31ads/current/cdl/board_eth_drivers.cdl ecos_mx31/packages/devs/eth/arm/mx31ads/current/cdl/board_eth_drivers.cdl
--- dummy/packages/devs/eth/arm/mx31ads/current/cdl/board_eth_drivers.cdl	1969-12-31 18:00:00.000000000 -0600
+++ ecos_mx31/packages/devs/eth/arm/mx31ads/current/cdl/board_eth_drivers.cdl	2006-02-09 15:23:01.000000000 -0600
@@ -0,0 +1,95 @@
+# ====================================================================
+#
+#      board_eth_drivers.cdl
+#
+# ====================================================================
+#####ECOSGPLCOPYRIGHTBEGIN####
+## -------------------------------------------
+## This file is part of eCos, the Embedded Configurable Operating System.
+## Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+##
+## eCos is free software; you can redistribute it and/or modify it under
+## the terms of the GNU General Public License as published by the Free
+## Software Foundation; either version 2 or (at your option) any later version.
+##
+## eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+## WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+## for more details.
+##
+## You should have received a copy of the GNU General Public License along
+## with eCos; if not, write to the Free Software Foundation, Inc.,
+## 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+##
+## As a special exception, if other files instantiate templates or use macros
+## or inline functions from this file, or you compile this file and link it
+## with other works to produce a work based on this file, this file does not
+## by itself cause the resulting work to be covered by the GNU General Public
+## License. However the source code for this file must still be made available
+## in accordance with section (3) of the GNU General Public License.
+##
+## This exception does not invalidate any other reasons why a work based on
+## this file might be covered by the GNU General Public License.
+##
+## Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+## at http://sources.redhat.com/ecos/ecos-license/
+## -------------------------------------------
+#####ECOSGPLCOPYRIGHTEND####
+
+cdl_package CYGPKG_DEVS_ETH_ARM_MX31ADS {
+    display       "Ethernet driver for Freescale MXC Board development board"
+
+    parent        CYGPKG_IO_ETH_DRIVERS
+    active_if	  CYGPKG_IO_ETH_DRIVERS
+
+    include_dir   cyg/io
+
+    # FIXME: This really belongs in the CL CS8900A package
+    cdl_interface CYGINT_DEVS_ETH_CL_CS8900A_REQUIRED {
+        display   "Cirrus Logic CS8900A ethernet driver required"
+    }
+
+    define_proc {
+        puts $::cdl_system_header "/***** ethernet driver proc output start *****/"
+        puts $::cdl_system_header "#define CYGDAT_DEVS_ETH_CL_CS8900A_INL <cyg/io/devs_eth_arm_board.inl>"
+        puts $::cdl_system_header "#define CYGDAT_DEVS_ETH_CL_CS8900A_CFG <pkgconf/devs_eth_arm_mx31ads.h>"
+        puts $::cdl_system_header "/*****  ethernet driver proc output end  *****/"
+    }
+
+    cdl_component CYGPKG_DEVS_ETH_ARM_MXCBOARD_ETH0 {
+        display       "MXC Board ethernet port driver"
+        flavor        bool
+        default_value 1
+        description   "
+            This option includes the ethernet device driver for the
+            MXC Board port."
+
+        implements CYGHWR_NET_DRIVER_ETH0
+        implements CYGINT_DEVS_ETH_CL_CS8900A_REQUIRED
+
+        cdl_option CYGDAT_DEVS_ETH_ARM_MXCBOARD_ETH0_NAME {
+            display       "Device name for the ETH0 ethernet driver"
+            flavor        data
+            default_value {"\"eth0\""}
+            description   "
+                This option sets the name of the ethernet device."
+        }
+
+        cdl_component CYGSEM_DEVS_ETH_ARM_MXCBOARD_ETH0_SET_ESA {
+            display       "Set the ethernet station address"
+            flavor        bool
+            default_value 0
+            description   "Enabling this option will allow the ethernet
+            station address to be forced to the value set by the
+            configuration.  This may be required if the hardware does
+            not include a serial EEPROM for the ESA."
+            
+            cdl_option CYGDAT_DEVS_ETH_ARM_MXCBOARD_ETH0_ESA {
+                display       "The ethernet station address"
+                flavor        data
+                default_value {"{0x08, 0x88, 0x12, 0x34, 0x56, 0x78}"}
+                description   "The ethernet station address"
+            }
+        }
+    }
+}
diff -urN -x CVS dummy/packages/devs/eth/arm/mx31ads/current/include/devs_eth_arm_board.inl ecos_mx31/packages/devs/eth/arm/mx31ads/current/include/devs_eth_arm_board.inl
--- dummy/packages/devs/eth/arm/mx31ads/current/include/devs_eth_arm_board.inl	1969-12-31 18:00:00.000000000 -0600
+++ ecos_mx31/packages/devs/eth/arm/mx31ads/current/include/devs_eth_arm_board.inl	2006-02-09 23:09:46.000000000 -0600
@@ -0,0 +1,224 @@
+//==========================================================================
+//
+//      devs_eth_arm_board.inl
+//
+//      Board ethernet I/O definitions.
+//
+//==========================================================================
+//####ECOSGPLCOPYRIGHTBEGIN####
+// -------------------------------------------
+// This file is part of eCos, the Embedded Configurable Operating System.
+// Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+//
+// eCos is free software; you can redistribute it and/or modify it under
+// the terms of the GNU General Public License as published by the Free
+// Software Foundation; either version 2 or (at your option) any later version.
+//
+// eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with eCos; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+//
+// As a special exception, if other files instantiate templates or use macros
+// or inline functions from this file, or you compile this file and link it
+// with other works to produce a work based on this file, this file does not
+// by itself cause the resulting work to be covered by the GNU General Public
+// License. However the source code for this file must still be made available
+// in accordance with section (3) of the GNU General Public License.
+//
+// This exception does not invalidate any other reasons why a work based on
+// this file might be covered by the GNU General Public License.
+//
+// Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+// at http://sources.redhat.com/ecos/ecos-license/
+// -------------------------------------------
+//####ECOSGPLCOPYRIGHTEND####
+//===========================================================================
+
+#include <cyg/hal/hal_intr.h>           // CYGNUM_HAL_INTERRUPT_ETHR
+#include <cyg/hal/hal_if.h>
+
+#ifdef CYGPKG_REDBOOT
+#include <pkgconf/redboot.h>
+#ifdef CYGSEM_REDBOOT_FLASH_CONFIG
+#include <redboot.h>
+#include <flash_config.h>
+#endif
+#endif
+
+#ifdef __WANT_DEVS
+
+#ifdef CYGPKG_DEVS_ETH_ARM_MXCBOARD_ETH0
+
+#if defined(CYGPKG_REDBOOT) && defined(CYGSEM_REDBOOT_FLASH_CONFIG)
+RedBoot_config_option("Set " CYGDAT_DEVS_ETH_ARM_MXCBOARD_ETH0_NAME " network hardware address [MAC]",
+                      eth0_esa,
+                      ALWAYS_ENABLED, true,
+                      CONFIG_BOOL, false
+                     );
+RedBoot_config_option(CYGDAT_DEVS_ETH_ARM_MXCBOARD_ETH0_NAME " network hardware address [MAC]",
+                      eth0_esa_data,
+                      "eth0_esa", true,
+                      CONFIG_ESA, 0
+                     );
+#endif // CYGPKG_REDBOOT && CYGSEM_REDBOOT_FLASH_CONFIG
+
+#ifdef CYGSEM_HAL_VIRTUAL_VECTOR_SUPPORT
+// Note that this section *is* active in an application, outside RedBoot,
+// where the above section is not included.
+
+#include <cyg/hal/hal_if.h>
+
+#ifndef CONFIG_ESA
+#define CONFIG_ESA (6)
+#endif
+#ifndef CONFIG_BOOL
+#define CONFIG_BOOL (1)
+#endif
+
+cyg_bool _board_provide_eth0_esa(struct cs8900a_priv_data* cpd)
+{
+    cyg_bool set_esa;
+    int ok;
+    ok = CYGACC_CALL_IF_FLASH_CFG_OP( CYGNUM_CALL_IF_FLASH_CFG_GET,
+                                      "eth0_esa", &set_esa, CONFIG_BOOL);
+    if (ok && set_esa) {
+        ok = CYGACC_CALL_IF_FLASH_CFG_OP( CYGNUM_CALL_IF_FLASH_CFG_GET,
+                                          "eth0_esa_data", cpd->esa, CONFIG_ESA);
+    }
+
+    return ok && set_esa;
+}
+
+#endif // CYGSEM_HAL_VIRTUAL_VECTOR_SUPPORT
+
+
+// ------------------------------------------------------------------------
+// EEPROM access functions
+// 
+#define PP_ECR                  0x0040
+#define PP_EE_READ_CMD          0x0200
+#define PP_EE_WRITE_CMD         0x0100
+#define PP_EE_EWEN_CMD          0x00F0
+#define PP_EE_EWDS_CMD          0x0000
+#define PP_EE_ERASE_CMD         0x0300
+
+#define PP_EE_DATA              0x0042
+#define PP_EE_ADDR_W0           0x001C
+#define PP_EE_ADDR_W1           0x001D
+#define PP_EE_ADDR_W2           0x001E
+
+#define EE_TIMEOUT              50000
+__inline__ cyg_uint16 read_eeprom(cyg_addrword_t base, cyg_uint16 offset)
+{
+    unsigned long timeout = EE_TIMEOUT;
+    if (get_reg(base, PP_SelfStat) & PP_SelfStat_EEPROM) {
+#if 0
+        diag_printf("EEPROM PP_SelfStat=0x%x\n", get_reg(base, PP_SelfStat));
+#endif
+    } else {
+        diag_printf("Error: NO EEPROM present\n");
+        return 0;
+    }
+
+    while ((timeout -- > 0) && (get_reg(base, PP_SelfStat) & PP_SelfStat_SIBSY))
+        ;
+    if (timeout == 0) {
+        diag_printf("read_eeprom() timeout\n");
+        return 0;
+    }
+    timeout = EE_TIMEOUT;
+    put_reg(base, PP_ECR, (offset | PP_EE_READ_CMD));
+    while ((timeout -- > 0) && (get_reg(base, PP_SelfStat) & PP_SelfStat_SIBSY))
+        ;
+    if (timeout == 0) {
+        diag_printf("read_eeprom() timeout\n");
+        return 0;
+    }
+    return get_reg(base, PP_EE_DATA);
+}
+
+/*
+ * Write a word to an EEPROM location
+ * base: package page base (IO base)
+ * offset: the EEPROM word offset starting from 0. So for word 1, should pass in 1
+ * data: 16 bit data to be written into EEPRM
+ */
+__inline__ void write_eeprom(cyg_addrword_t base, cyg_uint16 offset, cyg_uint16 data)
+{
+    while (get_reg(base, PP_SelfStat) & PP_SelfStat_SIBSY)
+        ;
+    put_reg(base, PP_ECR, PP_EE_EWEN_CMD);
+    while (get_reg(base, PP_SelfStat) & PP_SelfStat_SIBSY)
+        ;
+    put_reg(base, PP_ECR, PP_EE_ERASE_CMD|offset);
+    while (get_reg(base, PP_SelfStat) & PP_SelfStat_SIBSY)
+        ;
+    put_reg(base, PP_EE_DATA, data);
+    while (get_reg(base, PP_SelfStat) & PP_SelfStat_SIBSY)
+        ;
+    put_reg(base, PP_ECR, (PP_EE_WRITE_CMD|offset));
+    while (get_reg(base, PP_SelfStat) & PP_SelfStat_SIBSY)
+        ;
+    put_reg(base, PP_ECR, PP_EE_EWDS_CMD);
+    while (get_reg(base, PP_SelfStat) & PP_SelfStat_SIBSY)
+        ;
+}
+
+#define CS8900A_RESET_BYPASS /* define it when reset is done early */
+
+static __inline__ void copy_eeprom(cyg_addrword_t base)
+{
+    cyg_uint16 esa_word;     
+    int i;
+    for (i = 0;  i < 6;  i += 2) {
+        esa_word = read_eeprom(base, PP_EE_ADDR_W0 + (i/2));
+        put_reg(base, (PP_IA+i), esa_word);
+//         diag_printf("base=0x%x, copy_eeprom (0x%04x)\n", base, esa_word);
+    }
+}
+
+#undef  CYGHWR_CL_CS8900A_PLF_RESET
+#define CYGHWR_CL_CS8900A_PLF_RESET(base) copy_eeprom(base)
+
+static cs8900a_priv_data_t cs8900a_eth0_priv_data = {
+    base : (cyg_addrword_t) BOARD_CS_LAN_BASE,
+    interrupt: CYGNUM_HAL_INTERRUPT_ETH,
+#ifdef CYGSEM_DEVS_ETH_ARM_MXCBOARD_ETH0_SET_ESA
+    esa : CYGDAT_DEVS_ETH_ARM_MXCBOARD_ETH0_ESA,
+    hardwired_esa : true,
+#else
+    hardwired_esa : false,
+#endif
+#ifdef CYGSEM_HAL_VIRTUAL_VECTOR_SUPPORT
+    provide_esa : &_board_provide_eth0_esa,
+#else
+    provide_esa : NULL,
+#endif
+};
+
+ETH_DRV_SC(cs8900a_sc,
+           &cs8900a_eth0_priv_data, // Driver specific data
+           CYGDAT_DEVS_ETH_ARM_MXCBOARD_ETH0_NAME,
+           cs8900a_start,
+           cs8900a_stop,
+           cs8900a_control,
+           cs8900a_can_send,
+           cs8900a_send,
+           cs8900a_recv,
+           cs8900a_deliver,     // "pseudoDSR" called from fast net thread
+           cs8900a_poll,        // poll function, encapsulates ISR and DSR
+           cs8900a_int_vector);
+
+NETDEVTAB_ENTRY(cs8900a_netdev,
+                "cs8900a_" CYGDAT_DEVS_ETH_ARM_MXCBOARD_ETH0_NAME,
+                cs8900a_init,
+                &cs8900a_sc);
+
+#endif // CYGPKG_DEVS_ETH_ARM_MXCBOARD_ETH0
+
+#endif // __WANT_DEVS
diff -urN -x CVS dummy/packages/devs/flash/arm/mx31ads/current/cdl/flash_board_spansion.cdl ecos_mx31/packages/devs/flash/arm/mx31ads/current/cdl/flash_board_spansion.cdl
--- dummy/packages/devs/flash/arm/mx31ads/current/cdl/flash_board_spansion.cdl	1969-12-31 18:00:00.000000000 -0600
+++ ecos_mx31/packages/devs/flash/arm/mx31ads/current/cdl/flash_board_spansion.cdl	2006-02-09 15:23:01.000000000 -0600
@@ -0,0 +1,71 @@
+# ====================================================================
+#
+#      flash_board_spansion.cdl
+#
+#      FLASH memory - Hardware support
+#
+# ====================================================================
+#####ECOSGPLCOPYRIGHTBEGIN####
+## -------------------------------------------
+## This file is part of eCos, the Embedded Configurable Operating System.
+## Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+##
+## eCos is free software; you can redistribute it and/or modify it under
+## the terms of the GNU General Public License as published by the Free
+## Software Foundation; either version 2 or (at your option) any later version.
+##
+## eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+## WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+## for more details.
+##
+## You should have received a copy of the GNU General Public License along
+## with eCos; if not, write to the Free Software Foundation, Inc.,
+## 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+##
+## As a special exception, if other files instantiate templates or use macros
+## or inline functions from this file, or you compile this file and link it
+## with other works to produce a work based on this file, this file does not
+## by itself cause the resulting work to be covered by the GNU General Public
+## License. However the source code for this file must still be made available
+## in accordance with section (3) of the GNU General Public License.
+##
+## This exception does not invalidate any other reasons why a work based on
+## this file might be covered by the GNU General Public License.
+##
+## Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+## at http://sources.redhat.com/ecos/ecos-license/
+## -------------------------------------------
+#####ECOSGPLCOPYRIGHTEND####
+# ====================================================================
+######DESCRIPTIONBEGIN####
+#
+# Author(s):      gthomas
+# Original data:  gthomas
+# Contributors:
+# Date:           2000-07-26
+#
+#####DESCRIPTIONEND####
+#
+# ====================================================================
+
+cdl_package CYGPKG_DEVS_FLASH_MX31ADS_SPANSION {
+    display       "Freescale Spansion FLASH memory support"
+
+    parent        CYGPKG_IO_FLASH
+    active_if	  CYGPKG_IO_FLASH
+
+    implements    CYGHWR_IO_FLASH_DEVICE
+
+    compile       board_spansionflash.c
+
+    # Arguably this should do in the generic package
+    # but then there is a logic loop so you can never enable it.
+    cdl_interface CYGINT_DEVS_FLASH_AMD_AM29XXXXX_REQUIRED {
+        display   "Generic AMD FlashFile driver required"
+    }
+
+    implements    CYGINT_DEVS_FLASH_AMD_AM29XXXXX_REQUIRED
+
+    requires      CYGHWR_DEVS_FLASH_S29WS256N
+}
diff -urN -x CVS dummy/packages/devs/flash/arm/mx31ads/current/cdl/flash_board_strata.cdl ecos_mx31/packages/devs/flash/arm/mx31ads/current/cdl/flash_board_strata.cdl
--- dummy/packages/devs/flash/arm/mx31ads/current/cdl/flash_board_strata.cdl	1969-12-31 18:00:00.000000000 -0600
+++ ecos_mx31/packages/devs/flash/arm/mx31ads/current/cdl/flash_board_strata.cdl	2006-02-09 15:23:01.000000000 -0600
@@ -0,0 +1,80 @@
+# ====================================================================
+#
+#      flash_board_strata.cdl
+#
+#      FLASH memory - Hardware support
+#
+# ====================================================================
+#####ECOSGPLCOPYRIGHTBEGIN####
+## -------------------------------------------
+## This file is part of eCos, the Embedded Configurable Operating System.
+## Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+##
+## eCos is free software; you can redistribute it and/or modify it under
+## the terms of the GNU General Public License as published by the Free
+## Software Foundation; either version 2 or (at your option) any later version.
+##
+## eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+## WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+## for more details.
+##
+## You should have received a copy of the GNU General Public License along
+## with eCos; if not, write to the Free Software Foundation, Inc.,
+## 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+##
+## As a special exception, if other files instantiate templates or use macros
+## or inline functions from this file, or you compile this file and link it
+## with other works to produce a work based on this file, this file does not
+## by itself cause the resulting work to be covered by the GNU General Public
+## License. However the source code for this file must still be made available
+## in accordance with section (3) of the GNU General Public License.
+##
+## This exception does not invalidate any other reasons why a work based on
+## this file might be covered by the GNU General Public License.
+##
+## Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+## at http://sources.redhat.com/ecos/ecos-license/
+## -------------------------------------------
+#####ECOSGPLCOPYRIGHTEND####
+# ====================================================================
+######DESCRIPTIONBEGIN####
+#
+# Author(s):      gthomas
+# Original data:  gthomas
+# Contributors:
+# Date:           2000-07-26
+#
+#####DESCRIPTIONEND####
+#
+# ====================================================================
+
+cdl_package CYGPKG_DEVS_FLASH_MX31ADS_STRATA {
+    display       "Freescale FLASH memory support"
+
+    parent        CYGPKG_IO_FLASH
+    active_if	  CYGPKG_IO_FLASH
+
+    requires      CYGPKG_DEVS_FLASH_STRATA
+    requires      CYGNUM_DEVS_FLASH_STRATA_MAX_BLOCKS == 256
+
+    implements    CYGHWR_IO_FLASH_BLOCK_LOCKING
+
+    include_dir   cyg/io
+
+    # Arguably this should do in the generic package
+    # but then there is a logic loop so you can never enable it.
+    cdl_interface CYGINT_DEVS_FLASH_STRATA_REQUIRED {
+        display   "Generic StrataFLASH driver required"
+    }
+
+    implements    CYGINT_DEVS_FLASH_STRATA_REQUIRED
+
+    define_proc {
+        puts $::cdl_system_header "/***** strataflash driver proc output start *****/"
+        puts $::cdl_system_header "#define CYGDAT_DEVS_FLASH_STRATA_INL <cyg/io/board_strataflash.inl>"
+        puts $::cdl_system_header "#define CYGDAT_DEVS_FLASH_STRATA_CFG <pkgconf/devs_flash_board_strata.h>"
+        puts $::cdl_system_header "/*****  strataflash driver proc output end  *****/"
+    }
+}
+
diff -urN -x CVS dummy/packages/devs/flash/arm/mx31ads/current/ChangeLog ecos_mx31/packages/devs/flash/arm/mx31ads/current/ChangeLog
--- dummy/packages/devs/flash/arm/mx31ads/current/ChangeLog	1969-12-31 18:00:00.000000000 -0600
+++ ecos_mx31/packages/devs/flash/arm/mx31ads/current/ChangeLog	2004-06-04 15:05:30.000000000 -0500
@@ -0,0 +1,78 @@
+2001-03-17  Gary Thomas  <gthomas@redhat.com>
+
+	* src/flash_unlock_block.c: 
+	* src/flash_query.c: 
+	* src/flash_program_buf.c: 
+	* src/flash_lock_block.c: 
+	* src/flash_erase_block.c: 
+	* src/flash.h: 
+	* src/assabet_flash.c: Removed - everything now generic.
+
+	* include/assabet_strataflash.inl: 
+	* cdl/flash_assabet.cdl: Change to use generic StrataFLASH driver.
+
+2000-12-05  Jonathan Larmour  <jlarmour@redhat.com>
+
+	* src/assabet_flash.c (flash_code_overlaps): Define stext/etext
+	as array types so no assumptions can be made by the compiler about
+	location.
+
+2000-10-24  Gary Thomas  <gthomas@redhat.com>
+
+	* src/flash_unlock_block.c (flash_unlock_block): 
+	* src/flash_lock_block.c (flash_lock_block): 
+	* src/flash_program_buf.c (flash_program_buf): 
+	* src/flash_erase_block.c (flash_erase_block): Support up to 32M FLASH.
+
+2000-09-10  Gary Thomas  <gthomas@redhat.com>
+
+	* src/flash_unlock_block.c: 
+	* src/flash_lock_block.c: New file(s).
+
+	* src/flash.h: 
+	* cdl/flash_assabet.cdl: Add region locking functions.
+
+2000-08-29  Gary Thomas  <gthomas@redhat.com>
+
+	* src/assabet_flash.c: Improve error decoding.
+
+2000-08-24  Gary Thomas  <gthomas@redhat.com>
+
+	* src/flash_query.c: 
+	* src/flash_erase_block.c: 
+	* src/flash.h: FLASH support for Intel SA1110 Assabet.
+
+//===========================================================================
+//####ECOSGPLCOPYRIGHTBEGIN####
+// -------------------------------------------
+// This file is part of eCos, the Embedded Configurable Operating System.
+// Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+//
+// eCos is free software; you can redistribute it and/or modify it under
+// the terms of the GNU General Public License as published by the Free
+// Software Foundation; either version 2 or (at your option) any later version.
+//
+// eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with eCos; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+//
+// As a special exception, if other files instantiate templates or use macros
+// or inline functions from this file, or you compile this file and link it
+// with other works to produce a work based on this file, this file does not
+// by itself cause the resulting work to be covered by the GNU General Public
+// License. However the source code for this file must still be made available
+// in accordance with section (3) of the GNU General Public License.
+//
+// This exception does not invalidate any other reasons why a work based on
+// this file might be covered by the GNU General Public License.
+//
+// Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+// at http://sources.redhat.com/ecos/ecos-license/
+// -------------------------------------------
+//####ECOSGPLCOPYRIGHTEND####
+//===========================================================================
diff -urN -x CVS dummy/packages/devs/flash/arm/mx31ads/current/include/board_strataflash.inl ecos_mx31/packages/devs/flash/arm/mx31ads/current/include/board_strataflash.inl
--- dummy/packages/devs/flash/arm/mx31ads/current/include/board_strataflash.inl	1969-12-31 18:00:00.000000000 -0600
+++ ecos_mx31/packages/devs/flash/arm/mx31ads/current/include/board_strataflash.inl	2006-02-09 15:23:01.000000000 -0600
@@ -0,0 +1,64 @@
+#ifndef CYGONCE_DEVS_FLASH_BOARD_STRATAFLASH_INL
+#define CYGONCE_DEVS_FLASH_BOARD_STRATAFLASH_INL
+//==========================================================================
+//
+//      board_strataflash.inl
+//
+//      Flash programming - device constants, etc.
+//
+//==========================================================================
+//####ECOSGPLCOPYRIGHTBEGIN####
+// -------------------------------------------
+// This file is part of eCos, the Embedded Configurable Operating System.
+// Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+//
+// eCos is free software; you can redistribute it and/or modify it under
+// the terms of the GNU General Public License as published by the Free
+// Software Foundation; either version 2 or (at your option) any later version.
+//
+// eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with eCos; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+//
+// As a special exception, if other files instantiate templates or use macros
+// or inline functions from this file, or you compile this file and link it
+// with other works to produce a work based on this file, this file does not
+// by itself cause the resulting work to be covered by the GNU General Public
+// License. However the source code for this file must still be made available
+// in accordance with section (3) of the GNU General Public License.
+//
+// This exception does not invalidate any other reasons why a work based on
+// this file might be covered by the GNU General Public License.
+//
+// Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+// at http://sources.redhat.com/ecos/ecos-license/
+// -------------------------------------------
+//####ECOSGPLCOPYRIGHTEND####
+//==========================================================================
+//#####DESCRIPTIONBEGIN####
+//
+// Author(s):    gthomas, hmt
+// Contributors: gthomas
+// Date:         2001-02-24
+// Purpose:      
+// Description:  
+//              
+//####DESCRIPTIONEND####
+//
+//==========================================================================
+
+// The system has one 16-bit devices.
+// a StrataFlash 28F256L18. The 256 means 256Mbit, so 32Mbyte with 16bit width.
+
+#define CYGNUM_FLASH_DEVICES 	(1)
+#define CYGNUM_FLASH_BASE 	(0xA0000000u)
+#define CYGNUM_FLASH_BASE_MASK  (0xFE000000u) // 32MB devices (size=0x02000000 -> mask=0xFE000000)
+#define CYGNUM_FLASH_WIDTH 	(16)
+#define CYGNUM_FLASH_BLANK      (1)
+
+#endif  // CYGONCE_DEVS_FLASH_BOARD_STRATAFLASH_INL
\ No newline at end of file
diff -urN -x CVS dummy/packages/devs/flash/arm/mx31ads/current/src/board_spansionflash.c ecos_mx31/packages/devs/flash/arm/mx31ads/current/src/board_spansionflash.c
--- dummy/packages/devs/flash/arm/mx31ads/current/src/board_spansionflash.c	1969-12-31 18:00:00.000000000 -0600
+++ ecos_mx31/packages/devs/flash/arm/mx31ads/current/src/board_spansionflash.c	2006-02-09 15:23:01.000000000 -0600
@@ -0,0 +1,73 @@
+//==========================================================================
+//
+//      board_spansionflash.c
+//
+//      Flash programming for AMD Flash devices
+//
+//==========================================================================
+//####ECOSGPLCOPYRIGHTBEGIN####
+// -------------------------------------------
+// This file is part of eCos, the Embedded Configurable Operating System.
+// Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+//
+// eCos is free software; you can redistribute it and/or modify it under
+// the terms of the GNU General Public License as published by the Free
+// Software Foundation; either version 2 or (at your option) any later version.
+//
+// eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with eCos; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+//
+// As a special exception, if other files instantiate templates or use macros
+// or inline functions from this file, or you compile this file and link it
+// with other works to produce a work based on this file, this file does not
+// by itself cause the resulting work to be covered by the GNU General Public
+// License. However the source code for this file must still be made available
+// in accordance with section (3) of the GNU General Public License.
+//
+// This exception does not invalidate any other reasons why a work based on
+// this file might be covered by the GNU General Public License.
+//
+// Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+// at http://sources.redhat.com/ecos/ecos-license/
+// -------------------------------------------
+//####ECOSGPLCOPYRIGHTEND####
+//==========================================================================
+//#####DESCRIPTIONBEGIN####
+//
+// Author(s):    Patrick Doyle <wpd@delcomsys.com>
+// Contributors: Patrick Doyle <wpd@delcomsys.com>
+// Date:         2002-11-26
+// Purpose:      
+// Description:  
+//              
+//####DESCRIPTIONEND####
+//
+//==========================================================================
+
+#include <cyg/hal/hal_soc.h>
+
+//--------------------------------------------------------------------------
+// Device properties
+
+// We use the one SPANSION S29WS256N part on the EVB.
+#define CYGNUM_FLASH_INTERLEAVE (1)
+#define CYGNUM_FLASH_SERIES     (1)
+#define CYGNUM_FLASH_WIDTH      (16)
+#define CYGNUM_FLASH_BASE       (CS0_BASE_ADDR)
+
+#define CYGNUM_FLASH_TIMEOUT_QUERY 5000000
+#define CYGNUM_FLASH_TIMEOUT_ERASE_TIMER	100000000
+#define CYGNUM_FLASH_TIMEOUT_ERASE_COMPLETE	100000000
+#define CYGNUM_FLASH_TIMEOUT_PROGRAM		100000000
+//--------------------------------------------------------------------------
+// Platform specific extras
+
+//--------------------------------------------------------------------------
+// Now include the driver code.
+#include "cyg/io/flash_am29xxxxx.inl"
diff -urN -x CVS dummy/packages/hal/arm/mx31/3stack/current/cdl/hal_arm_board.cdl ecos_mx31/packages/hal/arm/mx31/3stack/current/cdl/hal_arm_board.cdl
--- dummy/packages/hal/arm/mx31/3stack/current/cdl/hal_arm_board.cdl	1969-12-31 18:00:00.000000000 -0600
+++ ecos_mx31/packages/hal/arm/mx31/3stack/current/cdl/hal_arm_board.cdl	2008-04-01 11:25:29.000000000 -0500
@@ -0,0 +1,367 @@
+# ====================================================================
+#
+#      hal_arm_board.cdl
+#
+# ====================================================================
+#####ECOSGPLCOPYRIGHTBEGIN####
+## -------------------------------------------
+## This file is part of eCos, the Embedded Configurable Operating System.
+## Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+##
+## eCos is free software; you can redistribute it and/or modify it under
+## the terms of the GNU General Public License as published by the Free
+## Software Foundation; either version 2 or (at your option) any later version.
+##
+## eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+## WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+## for more details.
+##
+## You should have received a copy of the GNU General Public License along
+## with eCos; if not, write to the Free Software Foundation, Inc.,
+## 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+##
+## As a special exception, if other files instantiate templates or use macros
+## or inline functions from this file, or you compile this file and link it
+## with other works to produce a work based on this file, this file does not
+## by itself cause the resulting work to be covered by the GNU General Public
+## License. However the source code for this file must still be made available
+## in accordance with section (3) of the GNU General Public License.
+##
+## This exception does not invalidate any other reasons why a work based on
+## this file might be covered by the GNU General Public License.
+##
+## Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+## at http://sources.redhat.com/ecos/ecos-license/
+## -------------------------------------------
+#####ECOSGPLCOPYRIGHTEND####
+
+cdl_package CYGPKG_HAL_ARM_MX31_3STACK {
+    display       "Freescale board"
+    parent        CYGPKG_HAL_ARM_MX31
+    hardware
+    include_dir   cyg/hal
+    define_header hal_arm_board.h
+    description   "
+        This HAL platform package provides generic
+        support for the Freescale MX31 3-Stack Board."
+
+    compile       board_misc.c board_diag.c
+    implements    CYGINT_HAL_DEBUG_GDB_STUBS
+    implements    CYGINT_HAL_DEBUG_GDB_STUBS_BREAK
+    implements    CYGINT_HAL_VIRTUAL_VECTOR_SUPPORT
+
+    #implements    CYGHWR_HAL_ARM_DUART_UARTB
+    implements    CYGHWR_HAL_ARM_SOC_UART1
+    #implements    CYGHWR_HAL_ARM_SOC_UART2
+    #implements    CYGHWR_HAL_ARM_SOC_UART3
+
+    define_proc {
+        puts $::cdl_system_header "#define CYGBLD_HAL_TARGET_H   <pkgconf/hal_arm.h>"
+        puts $::cdl_system_header "#define CYGBLD_HAL_VARIANT_H  <pkgconf/hal_arm_soc.h>"
+        puts $::cdl_system_header "#define CYGBLD_HAL_PLATFORM_H <pkgconf/hal_arm_board.h>"
+	puts $::cdl_header "#define HAL_PLATFORM_CPU    \"i.MX\""
+        puts $::cdl_header "#define HAL_PLATFORM_BOARD  \"Freescale\""
+        puts $::cdl_header "#define HAL_PLATFORM_MACHINE_TYPE  1511"
+        puts $::cdl_header "#define HAL_ARCH_PROGRAM_NEW_STACK board_program_new_stack"
+    }
+
+    cdl_component CYG_HAL_STARTUP {
+        display       "Startup type"
+        flavor        data
+        default_value {"ROM"}
+        legal_values  {"RAM" "ROM" "ROMRAM"}
+	no_define
+	define -file system.h CYG_HAL_STARTUP
+        description   "
+           When targetting the eval board it is possible to build
+           the system for either RAM bootstrap or ROM bootstrap(s). Select
+           'ram' when building programs to load into RAM using eCos GDB
+           stubs.  Select 'rom' when building a stand-alone application
+           which will be put into ROM, or for the special case of
+           building the eCos GDB stubs themselves. Using ROMRAM will allow
+           the program to exist in ROM, but be copied to RAM during startup."
+    }
+
+    cdl_interface     CYGHWR_HAL_ARM_DUART_UARTA {
+        display   "ST16552 UARTA available as diagnostic/debug channel"
+        description "
+	  The board has a ST16552 DUART chip. This
+          interface allows a platform to indicate that the specified
+          serial port can be used as a diagnostic and/or debug channel."
+    }
+
+    cdl_interface     CYGHWR_HAL_ARM_DUART_UARTB {
+        display   "ST16552 UARTB available as diagnostic/debug channel"
+        description "
+	  The board has a ST16552 DUART chip. This
+          interface allows a platform to indicate that the specified
+          serial port can be used as a diagnostic and/or debug channel."
+    }
+
+    cdl_option CYGNUM_HAL_VIRTUAL_VECTOR_CONSOLE_CHANNEL_BAUD {
+        display       "Diagnostic serial port baud rate"
+        flavor        data
+        legal_values  9600 19200 38400 57600 115200
+        default_value 115200
+        description   "
+            This option selects the baud rate used for the console port.
+            Note: this should match the value chosen for the GDB port if the
+            console and GDB port are the same."
+    }
+
+    cdl_option CYGNUM_HAL_VIRTUAL_VECTOR_DEBUG_CHANNEL_BAUD {
+        display       "GDB serial port baud rate"
+        flavor        data
+        legal_values  9600 19200 38400 57600 115200
+        default_value 115200
+        description   "
+            This option selects the baud rate used for the GDB port.
+            Note: this should match the value chosen for the console port if the
+            console and GDB port are the same."
+    }
+
+    cdl_option CYGNUM_HAL_VIRTUAL_VECTOR_COMM_CHANNELS {
+        display      "Number of communication channels on the board"
+        flavor       data
+        calculated   6
+    }
+
+    cdl_option CYGNUM_HAL_VIRTUAL_VECTOR_DEBUG_CHANNEL {
+        display          "Debug serial port"
+        active_if        CYGPRI_HAL_VIRTUAL_VECTOR_DEBUG_CHANNEL_CONFIGURABLE
+        flavor data
+        legal_values     0 to CYGNUM_HAL_VIRTUAL_VECTOR_COMM_CHANNELS-1
+        default_value    0
+        description      "
+            The board has three serial ports. This option
+            chooses which port will be used to connect to a host
+            running GDB."
+     }
+
+     cdl_option CYGNUM_HAL_VIRTUAL_VECTOR_CONSOLE_CHANNEL_DEFAULT {
+         display      "Default console channel."
+         flavor       data
+         legal_values     0 to CYGNUM_HAL_VIRTUAL_VECTOR_COMM_CHANNELS-1
+         calculated   0
+     }
+
+     cdl_option CYGNUM_HAL_VIRTUAL_VECTOR_CONSOLE_CHANNEL {
+         display          "Console serial port"
+         active_if        CYGPRI_HAL_VIRTUAL_VECTOR_CONSOLE_CHANNEL_CONFIGURABLE
+         flavor data
+         legal_values     0 to CYGNUM_HAL_VIRTUAL_VECTOR_COMM_CHANNELS-1
+         default_value    CYGNUM_HAL_VIRTUAL_VECTOR_CONSOLE_CHANNEL_DEFAULT
+         description      "
+            The board has only three serial ports.  This option
+            chooses which port will be used for console output."
+     }
+
+    cdl_component CYGBLD_GLOBAL_OPTIONS {
+        display "Global build options"
+        flavor  none
+        no_define
+        description   "
+	    Global build options including control over
+	    compiler flags, linker flags and choice of toolchain."
+
+
+        parent  CYGPKG_NONE
+
+        cdl_option CYGBLD_GLOBAL_COMMAND_PREFIX {
+            display "Global command prefix"
+            flavor  data
+            no_define
+            default_value { "arm-elf" }
+            description "
+                This option specifies the command prefix used when
+                invoking the build tools."
+        }
+
+        cdl_option CYGBLD_GLOBAL_CFLAGS {
+            display "Global compiler flags"
+            flavor  data
+            no_define
+            default_value { "-mcpu=arm9 -Wall -Wpointer-arith -Wstrict-prototypes -Winline -Wundef -Woverloaded-virtual -g -O2 -ffunction-sections -fdata-sections -fno-rtti -fno-exceptions -fvtable-gc -finit-priority" }
+            description   "
+                This option controls the global compiler flags which are used to
+                compile all packages by default. Individual packages may define
+                options which override these global flags."
+        }
+
+        cdl_option CYGBLD_GLOBAL_LDFLAGS {
+            display "Global linker flags"
+            flavor  data
+            no_define
+            default_value { "-Wl,--gc-sections -Wl,-static -g -O2 -nostdlib" }
+            description   "
+                This option controls the global linker flags. Individual
+                packages may define options which override these global flags."
+        }
+
+        cdl_option CYGBLD_BUILD_GDB_STUBS {
+            display "Build GDB stub ROM image"
+            default_value 0
+            requires { CYG_HAL_STARTUP == "ROM" }
+            requires CYGSEM_HAL_ROM_MONITOR
+            requires CYGBLD_BUILD_COMMON_GDB_STUBS
+            requires CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS
+            requires CYGDBG_HAL_DEBUG_GDB_BREAK_SUPPORT
+            requires CYGDBG_HAL_DEBUG_GDB_THREAD_SUPPORT
+            requires ! CYGDBG_HAL_COMMON_INTERRUPTS_SAVE_MINIMUM_CONTEXT
+            requires ! CYGDBG_HAL_COMMON_CONTEXT_SAVE_MINIMUM
+            no_define
+            description "
+                This option enables the building of the GDB stubs for the
+                board. The common HAL controls takes care of most of the
+                build process, but the final conversion from ELF image to
+                binary data is handled by the platform CDL, allowing
+                relocation of the data if necessary."
+
+            make -priority 320 {
+                <PREFIX>/bin/gdb_module.bin : <PREFIX>/bin/gdb_module.img
+                $(OBJCOPY) --remove-section=.fixed_vectors -O binary $< $@
+            }
+        }
+    }
+
+    cdl_component CYGPKG_HAL_ARM_BOARD_OPTIONS {
+        display "Freescale MXC Board build options"
+        flavor  none
+        no_define
+        description   "
+	    Package specific build options including control over
+	    compiler flags used only in building this package,
+	    and details of which tests are built."
+
+        cdl_option CYGPKG_HAL_ARM_BOARD_CFLAGS_ADD {
+            display "Additional compiler flags"
+            flavor  data
+            no_define
+            default_value { "" }
+            description   "
+                This option modifies the set of compiler flags for
+                building the board HAL. These flags are used in addition
+                to the set of global flags."
+        }
+
+        cdl_option CYGPKG_HAL_ARM_BOARD_CFLAGS_REMOVE {
+            display "Suppressed compiler flags"
+            flavor  data
+            no_define
+            default_value { "" }
+            description   "
+                This option modifies the set of compiler flags for
+                building the board HAL. These flags are removed from
+                the set of global flags if present."
+        }
+
+    }
+
+    cdl_component CYGHWR_MEMORY_LAYOUT {
+        display "Memory layout"
+        flavor data
+        no_define
+        calculated { (CYG_HAL_STARTUP == "RAM")    ? "arm_board_ram" :
+                     (CYG_HAL_STARTUP == "ROMRAM") ? "arm_board_romram" :
+	                                             "arm_board_rom" }
+
+        cdl_option CYGHWR_MEMORY_LAYOUT_LDI {
+            display "Memory layout linker script fragment"
+            flavor data
+            no_define
+            define -file system.h CYGHWR_MEMORY_LAYOUT_LDI
+            calculated { (CYG_HAL_STARTUP == "RAM") ?    "<pkgconf/mlt_arm_board_ram.ldi>" :
+                         (CYG_HAL_STARTUP == "ROMRAM") ? "<pkgconf/mlt_arm_board_romram.ldi>" :
+                                                         "<pkgconf/mlt_arm_board_rom.ldi>" }
+        }
+
+        cdl_option CYGHWR_MEMORY_LAYOUT_H {
+            display "Memory layout header file"
+            flavor data
+            no_define
+            define -file system.h CYGHWR_MEMORY_LAYOUT_H
+            calculated { (CYG_HAL_STARTUP == "RAM")    ? "<pkgconf/mlt_arm_board_ram.h>" :
+                         (CYG_HAL_STARTUP == "ROMRAM") ? "<pkgconf/mlt_arm_board_romram.h>" :
+                                                         "<pkgconf/mlt_arm_board_rom.h>" }
+        }
+    }
+
+    cdl_option CYGSEM_HAL_ROM_MONITOR {
+        display       "Behave as a ROM monitor"
+        flavor        bool
+        default_value 0
+        parent        CYGPKG_HAL_ROM_MONITOR
+        requires      { CYG_HAL_STARTUP == "ROM" || CYG_HAL_STARTUP == "ROMRAM" }
+        description   "
+            Enable this option if this program is to be used as a ROM monitor,
+            i.e. applications will be loaded into RAM on the board, and this
+            ROM monitor may process exceptions or interrupts generated from the
+            application. This enables features such as utilizing a separate
+            interrupt stack when exceptions are generated."
+    }
+
+    cdl_option CYGSEM_HAL_USE_ROM_MONITOR {
+         display       "Work with a ROM monitor"
+         flavor        booldata
+         legal_values  { "Generic" "GDB_stubs" }
+         default_value { CYG_HAL_STARTUP == "RAM" ? "GDB_stubs" : 0 }
+         parent        CYGPKG_HAL_ROM_MONITOR
+         requires      { CYG_HAL_STARTUP == "RAM" }
+         description   "
+             Support can be enabled for different varieties of ROM monitor.
+             This support changes various eCos semantics such as the encoding
+             of diagnostic output, or the overriding of hardware interrupt
+             vectors.
+             Firstly there is \"Generic\" support which prevents the HAL
+             from overriding the hardware vectors that it does not use, to
+             instead allow an installed ROM monitor to handle them. This is
+             the most basic support which is likely to be common to most
+             implementations of ROM monitor.
+             \"GDB_stubs\" provides support when GDB stubs are included in
+             the ROM monitor or boot ROM."
+     }
+
+    cdl_component CYGPKG_REDBOOT_HAL_OPTIONS {
+        display       "Redboot HAL options"
+        flavor        none
+        no_define
+        parent        CYGPKG_REDBOOT
+        active_if     CYGPKG_REDBOOT
+        description   "
+            This option lists the target's requirements for a valid Redboot
+            configuration."
+
+            compile -library=libextras.a redboot_cmds.c
+
+        cdl_option CYGBLD_BUILD_REDBOOT_BIN {
+            display       "Build Redboot ROM binary image"
+            active_if     CYGBLD_BUILD_REDBOOT
+            default_value 1
+            no_define
+            description "This option enables the conversion of the Redboot ELF
+                         image to a binary image suitable for ROM programming."
+
+            make -priority 325 {
+                <PREFIX>/bin/redboot.bin : <PREFIX>/bin/redboot.elf
+                $(OBJCOPY) --strip-debug $< $(@:.bin=.img)
+                $(OBJCOPY) -O srec $< $(@:.bin=.srec)
+                $(OBJCOPY) -O binary $< $@
+            }
+        }
+    }
+
+    cdl_component CYGPKG_REDBOOT_HAL_BOARD_OPTIONS {
+        display       "Redboot HAL variant options"
+        flavor        none
+        no_define
+        parent        CYGPKG_REDBOOT
+        active_if     CYGPKG_REDBOOT
+
+        # RedBoot details
+        requires { CYGHWR_REDBOOT_ARM_LINUX_EXEC_ADDRESS_DEFAULT == 0x80008000 }
+        define_proc {
+            puts $::cdl_header "#define CYGHWR_REDBOOT_ARM_TRAMPOLINE_ADDRESS 0x00001f00"
+        }
+    }
+}
diff -urN -x CVS dummy/packages/hal/arm/mx31/3stack/current/include/fsl_board.h ecos_mx31/packages/hal/arm/mx31/3stack/current/include/fsl_board.h
--- dummy/packages/hal/arm/mx31/3stack/current/include/fsl_board.h	1969-12-31 18:00:00.000000000 -0600
+++ ecos_mx31/packages/hal/arm/mx31/3stack/current/include/fsl_board.h	2008-04-01 11:25:29.000000000 -0500
@@ -0,0 +1,85 @@
+#ifndef CYGONCE_FSL_BOARD_H
+#define CYGONCE_FSL_BOARD_H
+
+//=============================================================================
+//
+//      Platform specific support (register layout, etc)
+//
+//=============================================================================
+//####ECOSGPLCOPYRIGHTBEGIN####
+// -------------------------------------------
+// This file is part of eCos, the Embedded Configurable Operating System.
+// Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+//
+// eCos is free software; you can redistribute it and/or modify it under
+// the terms of the GNU General Public License as published by the Free
+// Software Foundation; either version 2 or (at your option) any later version.
+//
+// eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with eCos; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+//
+// As a special exception, if other files instantiate templates or use macros
+// or inline functions from this file, or you compile this file and link it
+// with other works to produce a work based on this file, this file does not
+// by itself cause the resulting work to be covered by the GNU General Public
+// License. However the source code for this file must still be made available
+// in accordance with section (3) of the GNU General Public License.
+//
+// This exception does not invalidate any other reasons why a work based on
+// this file might be covered by the GNU General Public License.
+//
+// Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+// at http://sources.redhat.com/ecos/ecos-license/
+// -------------------------------------------
+//####ECOSGPLCOPYRIGHTEND####
+//===========================================================================
+
+#include <cyg/hal/hal_soc.h>        // Hardware definitions
+
+#define PMIC_SPI_BASE            CSPI2_BASE_ADDR
+#define PMIC_SPI_CHIP_SELECT_NO  SPI_CTRL_CS2
+
+#define PBC_BASE                    CS5_BASE_ADDR    /* Peripheral Bus Controller */
+#define PBC_LED_CTRL                (PBC_BASE + 0x20000)
+#define PBC_SB_STAT                 (PBC_BASE + 0x20008)
+#define PBC_ID_AAAA                 (PBC_BASE + 0x20040)
+#define PBC_ID_5555                 (PBC_BASE + 0x20048)
+#define PBC_VERSION                 (PBC_BASE + 0x20050)
+#define PBC_ID_CAFE                 (PBC_BASE + 0x20058)
+#define PBC_INT_STAT                (PBC_BASE + 0x20010)
+#define PBC_INT_MASK                (PBC_BASE + 0x20038)
+#define PBC_INT_REST                (PBC_BASE + 0x20020)
+#define PBC_SW_RESET                (PBC_BASE + 0x20060)
+#define BOARD_CS_LAN_BASE           (PBC_BASE + 0x300)
+#define BOARD_CS_UART_BASE          (PBC_BASE + 0x8000)
+
+#define REDBOOT_IMAGE_SIZE          0x40000
+
+#define EXT_UART_x16
+/* MX31 ADS SDRAM is from 0x80000000, 128M */
+#define SDRAM_BASE_ADDR             CSD0_BASE_ADDR
+#define SDRAM_SIZE                  0x08000000
+#define RAM_BANK0_BASE              SDRAM_BASE_ADDR
+
+#define LED_MAX_NUM	8
+#define LED_IS_ON(n)    ((readw(PBC_LED_CTRL) & (1<<(n))) != 0)
+#define TURN_LED_ON(n)  writew((readw(PBC_LED_CTRL)|(1<<(n))), PBC_LED_CTRL)
+#define TURN_LED_OFF(n) writew((readw(PBC_LED_CTRL)&(~(1<<(n)))), PBC_LED_CTRL)
+
+#define BOARD_DEBUG_LED(n) 			\
+    CYG_MACRO_START				\
+        if (n >= 0 && n < LED_MAX_NUM) { 	\
+		if (LED_IS_ON(n)) 		\
+			TURN_LED_OFF(n); 	\
+		else 				\
+			TURN_LED_ON(n);		\
+	}					\
+    CYG_MACRO_END
+
+#endif /* CYGONCE_FSL_BOARD_H */
diff -urN -x CVS dummy/packages/hal/arm/mx31/3stack/current/include/hal_platform_setup.h ecos_mx31/packages/hal/arm/mx31/3stack/current/include/hal_platform_setup.h
--- dummy/packages/hal/arm/mx31/3stack/current/include/hal_platform_setup.h	1969-12-31 18:00:00.000000000 -0600
+++ ecos_mx31/packages/hal/arm/mx31/3stack/current/include/hal_platform_setup.h	2008-04-02 11:50:24.000000000 -0500
@@ -0,0 +1,830 @@
+#ifndef CYGONCE_HAL_PLATFORM_SETUP_H
+#define CYGONCE_HAL_PLATFORM_SETUP_H
+
+//=============================================================================
+//
+//      hal_platform_setup.h
+//
+//      Platform specific support for HAL (assembly code)
+//
+//=============================================================================
+//####ECOSGPLCOPYRIGHTBEGIN####
+// -------------------------------------------
+// This file is part of eCos, the Embedded Configurable Operating System.
+// Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+//
+// eCos is free software; you can redistribute it and/or modify it under
+// the terms of the GNU General Public License as published by the Free
+// Software Foundation; either version 2 or (at your option) any later version.
+//
+// eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with eCos; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+//
+// As a special exception, if other files instantiate templates or use macros
+// or inline functions from this file, or you compile this file and link it
+// with other works to produce a work based on this file, this file does not
+// by itself cause the resulting work to be covered by the GNU General Public
+// License. However the source code for this file must still be made available
+// in accordance with section (3) of the GNU General Public License.
+//
+// This exception does not invalidate any other reasons why a work based on
+// this file might be covered by the GNU General Public License.
+//
+// Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+// at http://sources.redhat.com/ecos/ecos-license/
+// -------------------------------------------
+//####ECOSGPLCOPYRIGHTEND####
+//===========================================================================
+
+#include <pkgconf/system.h>             // System-wide configuration info
+#include CYGBLD_HAL_VARIANT_H           // Variant specific configuration
+#include CYGBLD_HAL_PLATFORM_H          // Platform specific configuration
+#include <cyg/hal/hal_soc.h>            // Variant specific hardware definitions
+#include <cyg/hal/hal_mmu.h>            // MMU definitions
+#include <cyg/hal/fsl_board.h>          // Platform specific hardware definitions
+
+#if defined(CYG_HAL_STARTUP_ROM) || defined(CYG_HAL_STARTUP_ROMRAM)
+#define PLATFORM_SETUP1 _platform_setup1
+#define CYGHWR_HAL_ARM_HAS_MMU
+
+#ifdef CYG_HAL_STARTUP_ROMRAM
+#define CYGSEM_HAL_ROM_RESET_USES_JUMP
+#endif
+
+//#define ARM_399MHZ
+#define ARM_532MHZ
+
+//#define NFC_2K_BI_SWAP
+#define SDRAM_FULL_PAGE_BIT     0x100
+#define SDRAM_FULL_PAGE_MODE    0x37
+#define SDRAM_BURST_MODE        0x33
+
+#define CYGHWR_HAL_ROM_VADDR    0x0
+
+#if 0
+#define UNALIGNED_ACCESS_ENABLE
+#define SET_T_BIT_DISABLE
+#define BRANCH_PREDICTION_ENABLE
+#endif
+
+//#define TURN_OFF_IMPRECISE_ABORT
+
+// This macro represents the initial startup code for the platform
+// r11 is reserved to contain chip rev info in this file
+    .macro  _platform_setup1
+FSL_BOARD_SETUP_START:
+/*
+ *       ARM1136 init
+ *       - invalidate I/D cache/TLB and drain write buffer;
+ *       - invalidate L2 cache
+ *       - unaligned access
+ *       - branch predictions
+ */
+#ifdef TURN_OFF_IMPRECISE_ABORT
+    mrs r0, cpsr
+    bic r0, r0, #0x100
+    msr cpsr, r0
+#endif
+
+    mov r0, #0
+    mcr 15, 0, r0, c7, c7, 0        /* invalidate I cache and D cache */
+    mcr 15, 0, r0, c8, c7, 0        /* invalidate TLBs */
+    mcr 15, 0, r0, c7, c10, 4       /* Drain the write buffer */
+
+    /* Also setup the Peripheral Port Remap register inside the core */
+    ldr r0, ARM_PPMRR        /* start from AIPS 2GB region */
+    mcr p15, 0, r0, c15, c2, 4
+
+    /* Reload data from spare area to 0x400 of main area if booting from NAND */
+    mov r0, #NFC_BASE
+    add r1, r0, #0x400
+    cmp pc, r0
+    blo 1f
+    cmp pc, r1
+    bhi 1f
+#ifdef NFC_2K_BI_SWAP
+    ldr r3, [r0, #0x7D0]    // load word at addr 464 of last 512 RAM buffer
+    and r3, r3, #0xFFFFFF00 // mask off the LSB
+    ldr r4, [r0, #0x834]    // load word at addr 4 of the 3rd spare area buffer
+    mov r4, r4, lsr #8      // shift it to get the byte at addr 5
+    and r4, r4, #0xFF       // throw away upper 3 bytes
+    add r3, r4, r3          // construct the word
+    str r3, [r0, #0x7D0]    // write back
+#endif
+
+1:
+    /*** L2 Cache setup/invalidation/disable ***/
+    /* Disable L2 cache first */
+    mov r0, #L2CC_BASE_ADDR
+    ldr r2, [r0, #L2_CACHE_CTL_REG]
+    bic r2, r2, #0x1
+    str r2, [r0, #L2_CACHE_CTL_REG]
+    /*
+     * Configure L2 Cache:
+     * - 128k size(16k way)
+     * - 8-way associativity
+     * - 0 ws TAG/VALID/DIRTY
+     * - 4 ws DATA R/W
+     */
+    ldr r1, [r0, #L2_CACHE_AUX_CTL_REG]
+    and r1, r1, #0xFE000000
+    ldr r2, L2CACHE_PARAM
+    orr r1, r1, r2
+    str r1, [r0, #L2_CACHE_AUX_CTL_REG]
+
+    /* Invalidate L2 */
+    mov r1, #0x000000FF
+    str r1, [r0, #L2_CACHE_INV_WAY_REG]
+L2_loop:
+    /* Poll Invalidate By Way register */
+    ldr r2, [r0, #L2_CACHE_INV_WAY_REG]
+    cmp r2, #0
+    bne L2_loop
+    /*** End of L2 operations ***/
+
+    mov r0, #SDRAM_NON_FLASH_BOOT
+    ldr r1, AVIC_VECTOR0_ADDR_W
+    str r0, [r1] // for checking boot source from nand or sdram
+/*
+ * End of ARM1136 init
+ */
+init_spba_start:
+    init_spba
+init_aips_start:
+    init_aips
+init_max_start:
+    init_max
+init_m3if_start:
+    init_m3if
+
+    ldr r11, =CHIP_REV_1_0
+    ldr r0, IIM_SREV_REG_VAL
+    ldr r1, [r0, #0x0]
+    cmp r1, #0x0
+    ldrne r11, =CHIP_REV_1_1
+    init_drive_strength
+
+    /* If SDRAM has been setup, bypass clock/WEIM setup */
+    cmp pc, #SDRAM_BASE_ADDR
+    blo init_clock_start
+    cmp pc, #(SDRAM_BASE_ADDR + SDRAM_SIZE)
+    blo HWInitialise_skip_SDRAM_setup
+
+    mov r0, #NOR_FLASH_BOOT
+    ldr r1, AVIC_VECTOR0_ADDR_W
+    str r0, [r1]
+
+init_cs5_start:
+    init_cs5
+
+init_clock_start:
+    init_clock
+
+    /* Based on chip rev, setup params for SDRAM controller */
+    ldr r10, =0
+    mov r4, #SDRAM_BURST_MODE
+
+init_sdram_start:
+
+    /* Assuming DDR memory first */
+    setup_sdram ddr X32 DDR 0
+#if 0
+    beq HWInitialise_skip_SDRAM_setup
+    setup_sdram ddr X16 DDR 0
+    beq HWInitialise_skip_SDRAM_setup
+    setup_sdram sdr X32 SDR 0
+    beq HWInitialise_skip_SDRAM_setup
+    setup_sdram sdr X16 SDR 0
+    beq HWInitialise_skip_SDRAM_setup
+
+    /* Reach hear means memory setup problem. Try to
+     * increase the HCLK divider */
+    ldr r0, CCM_BASE_ADDR_W
+    ldr r1, [r0, #CLKCTL_PDR0]
+    and r2, r1, #0x38
+    cmp r2, #0x38
+    beq loop_forever
+    add r1, r1, #0x8
+    str r1, [r0, #CLKCTL_PDR0]
+    b init_sdram_start
+
+loop_forever:
+    b loop_forever  /* shouldn't get here */
+#endif
+
+HWInitialise_skip_SDRAM_setup:
+
+    mov r0, #NFC_BASE
+    add r2, r0, #0x800      // 2K window
+    cmp pc, r0
+    blo Normal_Boot_Continue
+    cmp pc, r2
+    bhi Normal_Boot_Continue
+NAND_Boot_Start:
+    /* Copy image from flash to SDRAM first */
+    ldr r1, MXC_REDBOOT_ROM_START
+
+1:  ldmia r0!, {r3-r10}
+    stmia r1!, {r3-r10}
+    cmp r0, r2
+    blo 1b
+    /* Jump to SDRAM */
+    ldr r1, CONST_0x0FFF
+    and r0, pc, r1     /* offset of pc */
+    ldr r1, MXC_REDBOOT_ROM_START
+    add r1, r1, #0x10
+    add pc, r0, r1
+    nop
+    nop
+    nop
+    nop
+NAND_Copy_Main:
+    // Check if x16/2kb page
+    ldr r7, CCM_BASE_ADDR_W
+    ldr r7, [r7, #0xC]
+    ands r7, r7, #(1 << 30)
+
+    mov r0, #NAND_FLASH_BOOT
+    ldr r1, AVIC_VECTOR0_ADDR_W
+    str r0, [r1]
+    mov r0, #MXCFIS_NAND
+    ldr r1, AVIC_VECTOR1_ADDR_W
+    str r0, [r1]
+
+    mov r0, #NFC_BASE;   //r0: nfc base. Reloaded after each page copying
+    mov r1, #0x800       //r1: starting flash addr to be copied. Updated constantly
+    add r2, r0, #0x800   //r2: end of 3rd RAM buf. Doesn't change
+    addeq r2, r0, #0x200   //r2: end of 1st RAM buf. Doesn't change
+    add r12, r0, #0xE00  //r12: NFC register base. Doesn't change
+    ldr r11, MXC_REDBOOT_ROM_START
+    add r13, r11, #REDBOOT_IMAGE_SIZE //r13: end of SDRAM address for copying. Doesn't change
+    add r11, r11, r1     //r11: starting SDRAM address for copying. Updated constantly
+
+    //unlock internal buffer
+    mov r3, #0x2
+    strh r3, [r12, #0xA]
+
+Nfc_Read_Page:
+//  NFC_CMD_INPUT(FLASH_Read_Mode1);
+    mov r3, #0x0
+    nfc_cmd_input
+
+    // Check if x16/2kb page
+    ldr r7, CCM_BASE_ADDR_W
+    ldr r7, [r7, #0xC]
+    ands r7, r7, #(1 << 30)
+    bne nfc_addr_ops_2kb
+//    start_nfc_addr_ops(ADDRESS_INPUT_READ_PAGE, addr, nflash_dev_info->base_mask);
+    mov r3, r1
+    do_addr_input       //1st addr cycle
+    mov r3, r1, lsr #9
+    do_addr_input       //2nd addr cycle
+    mov r3, r1, lsr #17
+    do_addr_input       //3rd addr cycle
+    mov r3, r1, lsr #25
+    do_addr_input       //4th addr cycle
+    b end_of_nfc_addr_ops
+
+nfc_addr_ops_2kb:
+//    start_nfc_addr_ops(ADDRESS_INPUT_READ_PAGE, addr, nflash_dev_info->base_mask);
+    mov r3, #0
+    do_addr_input       //1st addr cycle
+    mov r3, #0
+    do_addr_input       //2nd addr cycle
+    mov r3, r1, lsr #11
+    do_addr_input       //3rd addr cycle
+    mov r3, r1, lsr #19
+    do_addr_input       //4th addr cycle
+    mov r3, r1, lsr #27
+    do_addr_input       //5th addr cycle
+
+//    NFC_CMD_INPUT(FLASH_Read_Mode1_2K);
+    mov r3, #0x30
+    nfc_cmd_input
+
+end_of_nfc_addr_ops:
+//    NFC_DATA_OUTPUT(buf, FDO_PAGE_SPARE_VAL);
+//        writew(NAND_FLASH_CONFIG1_INT_MSK | NAND_FLASH_CONFIG1_ECC_EN,
+//               NAND_FLASH_CONFIG1_REG);
+    mov r8, #0
+    bl nfc_data_output
+    bl do_wait_op_done
+    // Check if x16/2kb page
+    ldr r7, CCM_BASE_ADDR_W
+    ldr r7, [r7, #0xC]
+    ands r7, r7, #(1 << 30)
+    beq nfc_addr_data_output_done_512
+
+// For 2K page - 2nd 512
+    mov r8, #1
+    bl nfc_data_output
+    bl do_wait_op_done
+
+// 3rd 512
+    mov r8, #2
+    bl nfc_data_output
+    bl do_wait_op_done
+
+// 4th 512
+    mov r8, #3
+    bl nfc_data_output
+    bl do_wait_op_done
+// end of 4th
+#ifdef NFC_2K_BI_SWAP
+    ldr r3, [r0, #0x7D0]    // load word at addr 464 of last 512 RAM buffer
+    and r3, r3, #0xFFFFFF00 // mask off the LSB
+    ldr r4, [r0, #0x834]    // load word at addr 4 of the 3rd spare area buffer
+    mov r4, r4, lsr #8      // shift it to get the byte at addr 5
+    and r4, r4, #0xFF       // throw away upper 3 bytes
+    add r3, r4, r3          // construct the word
+    str r3, [r0, #0x7D0]    // write back
+#endif
+    // check for bad block
+    mov r3, r1, lsl #(32-17)    // get rid of block number
+    cmp r3, #(0x800 << (32-17)) // check if not page 0 or 1
+    b nfc_addr_data_output_done
+
+nfc_addr_data_output_done_512:
+    // check for bad block
+    mov r3, r1, lsl #(32-5-9)    // get rid of block number
+    cmp r3, #(512 << (32-5-9))   // check if not page 0 or 1
+
+nfc_addr_data_output_done:
+    bhi Copy_Good_Blk
+    add r4, r0, #0x800  //r3 -> spare area buf 0
+    ldrh r4, [r4, #0x4]
+    and r4, r4, #0xFF00
+    cmp r4, #0xFF00
+    beq Copy_Good_Blk
+    // really sucks. Bad block!!!!
+    cmp r3, #0x0
+    beq Skip_bad_block
+    // even suckier since we already read the first page!
+    // Check if x16/2kb page
+    ldr r7, CCM_BASE_ADDR_W
+    ldr r7, [r7, #0xC]
+    ands r7, r7, #(1 << 30)
+
+    subeq r11, r11, #512  //rewind 1 page for the sdram pointer
+    subeq r1, r1, #512    //rewind 1 page for the flash pointer
+
+    // for 2k page
+    subne r11, r11, #0x800  //rewind 1 page for the sdram pointer
+    subne r1, r1, #0x800    //rewind 1 page for the flash pointer
+
+Skip_bad_block:
+    // Check if x16/2kb page
+    ldr r7, CCM_BASE_ADDR_W
+    ldr r7, [r7, #0xC]
+    ands r7, r7, #(1 << 30)
+
+    addeq r1, r1, #(32*512)
+    addne r1, r1, #(64*2048)
+
+    b Nfc_Read_Page
+Copy_Good_Blk:
+    //copying page
+1:  ldmia r0!, {r3-r10}
+    stmia r11!, {r3-r10}
+    cmp r0, r2
+    blo 1b
+    cmp r11, r13
+    bge NAND_Copy_Main_done
+    // Check if x16/2kb page
+    ldr r7, CCM_BASE_ADDR_W
+    ldr r7, [r7, #0xC]
+    ands r7, r7, #(1 << 30)
+    addeq r1, r1, #0x200
+    addne r1, r1, #0x800
+    mov r0, #NFC_BASE
+    b Nfc_Read_Page
+
+NAND_Copy_Main_done:
+
+Normal_Boot_Continue:
+
+#ifdef CYG_HAL_STARTUP_ROMRAM     /* enable running from RAM */
+    /* Copy image from flash to SDRAM first */
+    ldr r0, =0xFFFFF000
+    and r0, r0, pc
+    ldr r1, MXC_REDBOOT_ROM_START
+    cmp r0, r1
+    beq HWInitialise_skip_SDRAM_copy
+
+    add r2, r0, #REDBOOT_IMAGE_SIZE
+
+1:  ldmia r0!, {r3-r10}
+    stmia r1!, {r3-r10}
+    cmp r0, r2
+    ble 1b
+    /* Jump to SDRAM */
+    ldr r1, =0xFFFF
+    and r0, pc, r1         /* offset of pc */
+    ldr r1, =(SDRAM_BASE_ADDR + SDRAM_SIZE - 0x100000 + 0x8)
+    add pc, r0, r1
+    nop
+    nop
+    nop
+    nop
+#endif /* CYG_HAL_STARTUP_ROMRAM */
+
+HWInitialise_skip_SDRAM_copy:
+
+NAND_ClockSetup:
+
+/*
+ * Note:
+ *     IOMUX/PBC setup is done in C function plf_hardware_init() for simplicity
+ */
+
+STACK_Setup:
+    // Set up a stack [for calling C code]
+    ldr r1, =__startup_stack
+    ldr r2, =RAM_BANK0_BASE
+    orr sp, r1, r2
+
+    // Create MMU tables
+    bl hal_mmu_init
+
+    // Enable MMU
+    ldr r2, =10f
+    mrc MMU_CP, 0, r1, MMU_Control, c0      // get c1 value to r1 first
+    orr r1, r1, #7                          // enable MMU bit
+    mcr MMU_CP, 0, r1, MMU_Control, c0
+    mov pc,r2    /* Change address spaces */
+    nop
+    nop
+    nop
+10:
+
+    // Save shadow copy of BCR, also hardware configuration
+    ldr r1, =_board_BCR
+    str r2, [r1]
+    ldr r1, =_board_CFG
+    str r9, [r1]                // Saved far above...
+
+    .endm                       // _platform_setup1
+
+do_wait_op_done:
+    1:
+        ldrh r3, [r12, #NAND_FLASH_CONFIG2_REG_OFF]
+        ands r3, r3, #NAND_FLASH_CONFIG2_INT_DONE
+        beq 1b
+    bx lr     // do_wait_op_done
+
+nfc_data_output:
+    mov r3, #(NAND_FLASH_CONFIG1_INT_MSK | NAND_FLASH_CONFIG1_ECC_EN)
+    strh r3, [r12, #NAND_FLASH_CONFIG1_REG_OFF]
+
+    // writew(buf_no, RAM_BUFFER_ADDRESS_REG);
+    strh r8, [r12, #RAM_BUFFER_ADDRESS_REG_OFF]
+    // writew(FDO_PAGE_SPARE_VAL & 0xFF, NAND_FLASH_CONFIG2_REG);
+    mov r3, #FDO_PAGE_SPARE_VAL
+    strh r3, [r12, #NAND_FLASH_CONFIG2_REG_OFF]
+    bx lr
+
+#else // defined(CYG_HAL_STARTUP_ROM) || defined(CYG_HAL_STARTUP_ROMRAM)
+#define PLATFORM_SETUP1
+#endif
+
+    /* Do nothing */
+    .macro  init_spba
+    .endm  /* init_spba */
+
+    /* AIPS setup - Only setup MPROTx registers. The PACR default values are good.*/
+    .macro init_aips
+        /*
+         * Set all MPROTx to be non-bufferable, trusted for R/W,
+         * not forced to user-mode.
+         */
+        ldr r0, AIPS1_CTRL_BASE_ADDR_W
+        ldr r1, AIPS1_PARAM_W
+        str r1, [r0, #0x00]
+        str r1, [r0, #0x04]
+        ldr r0, AIPS2_CTRL_BASE_ADDR_W
+        str r1, [r0, #0x00]
+        str r1, [r0, #0x04]
+
+        /*
+         * Clear the on and off peripheral modules Supervisor Protect bit
+         * for SDMA to access them. Did not change the AIPS control registers
+         * (offset 0x20) access type
+         */
+        ldr r0, AIPS1_CTRL_BASE_ADDR_W
+        ldr r1, =0x0
+        str r1, [r0, #0x40]
+        str r1, [r0, #0x44]
+        str r1, [r0, #0x48]
+        str r1, [r0, #0x4C]
+        ldr r1, [r0, #0x50]
+        and r1, r1, #0x00FFFFFF
+        str r1, [r0, #0x50]
+
+        ldr r0, AIPS2_CTRL_BASE_ADDR_W
+        ldr r1, =0x0
+        str r1, [r0, #0x40]
+        str r1, [r0, #0x44]
+        str r1, [r0, #0x48]
+        str r1, [r0, #0x4C]
+        ldr r1, [r0, #0x50]
+        and r1, r1, #0x00FFFFFF
+        str r1, [r0, #0x50]
+    .endm /* init_aips */
+
+    /* MAX (Multi-Layer AHB Crossbar Switch) setup */
+    .macro init_max
+        ldr r0, MAX_BASE_ADDR_W
+        /* MPR - priority is M4 > M2 > M3 > M5 > M0 > M1 */
+        ldr r1, MAX_PARAM1
+        str r1, [r0, #0x000]        /* for S0 */
+        str r1, [r0, #0x100]        /* for S1 */
+        str r1, [r0, #0x200]        /* for S2 */
+        str r1, [r0, #0x300]        /* for S3 */
+        str r1, [r0, #0x400]        /* for S4 */
+        /* SGPCR - always park on last master */
+        ldr r1, =0x10
+        str r1, [r0, #0x010]        /* for S0 */
+        str r1, [r0, #0x110]        /* for S1 */
+        str r1, [r0, #0x210]        /* for S2 */
+        str r1, [r0, #0x310]        /* for S3 */
+        str r1, [r0, #0x410]        /* for S4 */
+        /* MGPCR - restore default values */
+        ldr r1, =0x0
+        str r1, [r0, #0x800]        /* for M0 */
+        str r1, [r0, #0x900]        /* for M1 */
+        str r1, [r0, #0xA00]        /* for M2 */
+        str r1, [r0, #0xB00]        /* for M3 */
+        str r1, [r0, #0xC00]        /* for M4 */
+        str r1, [r0, #0xD00]        /* for M5 */
+    .endm /* init_max */
+
+    /* Clock setup */
+    .macro    init_clock
+        ldr r0, IPU_CTRL_BASE_ADDR_W
+        ldr r1, =0x40
+        str r1, [r0]
+
+        ldr r0, CCM_BASE_ADDR_W
+        ldr r2, CCM_CCMR_0x074B0BF5
+        ldr r3, CCM_CCMR_0x074B0BFD
+        ldr r4, CCM_CCMR_0x074B0B7D
+
+        // Make sure to use CKIH
+        ldr r1, [r0, #CLKCTL_CCMR]
+        bic r1, r1, #0x8            // disable PLL first
+        str r1, [r0, #CLKCTL_CCMR]
+        str r2, [r0, #CLKCTL_CCMR]  // select CKIH (26MHz) as PLL ref clock
+        ldr r1, =0x1000
+    1:
+        subs r1, r1, #0x1
+        bne 1b
+        str r3, [r0, #CLKCTL_CCMR]  // enable PLL
+        str r4, [r0, #CLKCTL_CCMR]  // switch to PLL (SPLL for FIR)
+
+        // 532-133-66.5
+        ldr r1, CCM_PDR0_W
+        str r1, [r0, #CLKCTL_PDR0]
+        ldr r1, MPCTL_PARAM_W
+        str r1, [r0, #CLKCTL_MPCTL]
+
+        /* Set UPLL=240MHz, USB=60MHz */
+        ldr r1, CCM_PDR1_0x49FCFE7F
+        str r1, [r0, #CLKCTL_PDR1]
+        ldr r1, CCM_UPCTL_PARAM_240
+        str r1, [r0, #CLKCTL_UPCTL]
+        // default CLKO to 1/8 of the ARM core
+        mov r1, #0x000002C0
+        add r1, r1, #0x00000006
+        str r1, [r0, #CLKCTL_COSR]
+    .endm /* init_clock */
+
+    /* M3IF setup */
+    .macro init_m3if
+        /* Configure M3IF registers */
+        ldr r1, M3IF_BASE_W
+        /*
+        * M3IF Control Register (M3IFCTL)
+        * MRRP[0] = L2CC0 not on priority list (0 << 0)        = 0x00000000
+        * MRRP[1] = L2CC1 not on priority list (0 << 0)        = 0x00000000
+        * MRRP[2] = MBX not on priority list (0 << 0)        = 0x00000000
+        * MRRP[3] = MAX1 not on priority list (0 << 0)        = 0x00000000
+        * MRRP[4] = SDMA not on priority list (0 << 0)        = 0x00000000
+        * MRRP[5] = MPEG4 not on priority list (0 << 0)       = 0x00000000
+        * MRRP[6] = IPU1 on priority list (1 << 6)             = 0x00000040
+        * MRRP[7] = IPU2 not on priority list (0 << 0)   = 0x00000000
+        *                                                       ------------
+        *                                                       0x00000040
+        */
+        ldr r0, =0x00000040
+        str r0, [r1]  /* M3IF control reg */
+    .endm /* init_m3if */
+
+     /* CPLD on CS5 setup */
+    .macro init_cs5
+        ldr r0, WEIM_CTRL_CS5_W
+        ldr r1, CS5_0x0000D843
+        str r1, [r0, #CSCRU]
+        ldr r1, CS5_0x22252521
+        str r1, [r0, #CSCRL]
+        ldr r1, CS5_0x22220A00
+        str r1, [r0, #CSCRA]
+    .endm /* init_cs5 */
+
+    .macro setup_sdram, name, bus_width, mode, full_page
+        /* It sets the "Z" flag in the CPSR at the end of the macro */
+        ldr r0, ESDCTL_BASE_W
+        mov r2, #SDRAM_BASE_ADDR
+        ldr r1, SDRAM_0x0075E73A
+        str r1, [r0, #0x4]
+        ldr r1, =0x2            // reset
+        str r1, [r0, #0x10]
+        ldr r1, SDRAM_PARAM1_\mode
+        str r1, [r0, #0x10]
+        // Hold for more than 200ns
+        ldr r1, =0x10000
+1:
+        subs r1, r1, #0x1
+        bne 1b
+
+        ldr r1, SDRAM_0x92100000
+        str r1, [r0]
+        ldr r1, =0x0
+        ldr r12, SDRAM_PARAM2_\mode
+        str r1, [r12]
+        ldr r1, SDRAM_0xA2100000
+        str r1, [r0]
+        ldr r1, =0x0
+        str r1, [r2]
+        ldr r1, SDRAM_0xB2100000
+        str r1, [r0]
+
+        ldr r1, =0x0
+        .if \full_page
+        strb r1, [r2, #SDRAM_FULL_PAGE_MODE]
+        .else
+        strb r1, [r2, #SDRAM_BURST_MODE]
+        .endif
+
+        ldr r1, =0xFF
+        ldr r12, =0x81000000
+        strb r1, [r12]
+        ldr r3, SDRAM_0x82116080
+        ldr r4, SDRAM_PARAM3_\mode
+        add r3, r3, r4
+        ldr r4, SDRAM_PARAM4_\bus_width
+        add r3, r3, r4
+        .if \full_page
+        add r3, r3, #0x100   /* Force to full page mode */
+        .endif
+
+        str r3, [r0]
+        ldr r1, =0x0
+        str r1, [r2]
+        /* Below only for DDR */
+        ldr r1, [r0, #0x10]
+        ands r1, r1, #0x4
+        ldrne r1, =0x0000000C
+        strne r1, [r0, #0x10]
+        /* Testing if it is truly DDR */
+        ldr r1, SDRAM_0x55555555
+        ldr r0, =SDRAM_BASE_ADDR
+        str r1, [r0]
+        ldr r2, SDRAM_0xAAAAAAAA
+        str r2, [r0, #0x4]
+        ldr r2, [r0]
+        cmp r1, r2
+    .endm
+
+    .macro nfc_cmd_input
+        strh r3, [r12, #NAND_FLASH_CMD_REG_OFF]
+        mov r3, #NAND_FLASH_CONFIG2_FCMD_EN;
+        strh r3, [r12, #NAND_FLASH_CONFIG2_REG_OFF]
+        bl do_wait_op_done
+    .endm   // nfc_cmd_input
+
+    .macro do_addr_input
+        and r3, r3, #0xFF
+        strh r3, [r12, #NAND_FLASH_ADD_REG_OFF]
+        mov r3, #NAND_FLASH_CONFIG2_FADD_EN
+        strh r3, [r12, #NAND_FLASH_CONFIG2_REG_OFF]
+        bl do_wait_op_done
+    .endm   // do_addr_input
+
+    /* To support 133MHz DDR */
+    .macro  init_drive_strength
+        /*
+         * Disable maximum drive strength SDRAM/DDR lines by clearing DSE1 bits
+         * in SW_PAD_CTL registers
+         */
+
+        // SDCLK
+        ldr r1, IOMUXC_BASE_ADDR_W
+        add r1, r1, #0x200
+        // Now r1 = (IOMUX_BASE_ADDR + 0x200)
+        ldr r0, [r1, #0x6C]
+        bic r0, r0, #(1 << 12)
+        str r0, [r1, #0x6C]
+
+        // CAS
+        ldr r0, [r1, #0x70]
+        bic r0, r0, #(1 << 22)
+        str r0, [r1, #0x70]
+
+        // RAS
+        ldr r0, [r1, #0x74]
+        bic r0, r0, #(1 << 2)
+        str r0, [r1, #0x74]
+
+        // CS2 (CSD0)
+        ldr r0, [r1, #0x7C]
+        bic r0, r0, #(1 << 22)
+        str r0, [r1, #0x7C]
+
+        // DQM3
+        ldr r0, [r1, #0x84]
+        bic r0, r0, #(1 << 22)
+        str r0, [r1, #0x84]
+
+        // DQM2, DQM1, DQM0, SD31-SD0, A25-A0, MA10 (0x288..0x2DC)
+        ldr r2, =22     // (0x2E0 - 0x288) / 4 = 22
+pad_loop:
+        ldr r0, [r1, #0x88]
+        bic r0, r0, #(1 << 22)
+        bic r0, r0, #(1 << 12)
+        bic r0, r0, #(1 << 2)
+        str r0, [r1, #0x88]
+        add r1, r1, #4
+        subs r2, r2, #0x1
+        bne pad_loop
+    .endm /* init_drive_strength */
+
+#define PLATFORM_VECTORS         _platform_vectors
+    .macro  _platform_vectors
+        .globl  _board_BCR, _board_CFG
+_board_BCR:   .long   0       // Board Control register shadow
+_board_CFG:   .long   0       // Board Configuration (read at RESET)
+    .endm
+
+ARM_PPMRR:              .word   0x40000015
+L2CACHE_PARAM:          .word   0x00030024
+IIM_SREV_REG_VAL:       .word   IIM_BASE_ADDR + IIM_SREV_OFF
+AIPS1_CTRL_BASE_ADDR_W: .word   AIPS1_CTRL_BASE_ADDR
+AIPS2_CTRL_BASE_ADDR_W: .word   AIPS2_CTRL_BASE_ADDR
+AIPS1_PARAM_W:          .word   0x77777777
+MAX_BASE_ADDR_W:        .word   MAX_BASE_ADDR
+MAX_PARAM1:             .word   0x00302154
+CLKCTL_BASE_ADDR_W:     .word   CLKCTL_BASE_ADDR
+ESDCTL_BASE_W:          .word   ESDCTL_BASE
+M3IF_BASE_W:            .word   M3IF_BASE
+SDRAM_PARAM1_DDR:	    .word	0x4
+SDRAM_PARAM1_SDR:	    .word	0x0
+SDRAM_PARAM2_DDR:	    .word	0x80000F00
+SDRAM_PARAM2_SDR:	    .word	0x80000400
+SDRAM_PARAM3_DDR:       .word   0x00100000
+SDRAM_PARAM3_SDR:       .word   0x0
+SDRAM_PARAM4_X32:       .word   0x00010000
+SDRAM_PARAM4_X16:       .word   0x0
+SDRAM_0x55555555:       .word   0x55555555
+SDRAM_0xAAAAAAAA:       .word   0xAAAAAAAA
+SDRAM_0x92100000:       .word   0x92100000
+SDRAM_0xA2100000:       .word   0xA2100000
+SDRAM_0xB2100000:       .word   0xB2100000
+SDRAM_0x82116080:       .word   0x82116080
+SDRAM_0x0075E73A:       .word   0x0075E73A
+IOMUXC_BASE_ADDR_W:     .word   IOMUXC_BASE_ADDR
+#ifdef ARM_399MHZ
+CCM_PDR0_W:             .word   PDR0_399_133_66
+MPCTL_PARAM_W:          .word   MPCTL_PARAM_399
+#endif
+#ifdef ARM_532MHZ
+CCM_PDR0_W:             .word   PDR0_532_133_66
+MPCTL_PARAM_W:          .word   MPCTL_PARAM_532
+#endif
+
+MPCTL_PARAM_532_27_W:   .word   MPCTL_PARAM_532_27
+CCM_PDR1_0x49FCFE7F:    .word   0x49FCFE7F
+CCM_UPCTL_PARAM_240:    .word   UPCTL_PARAM_240
+CCM_UPCTL_PARAM_240_27: .word   UPCTL_PARAM_240_27
+AVIC_VECTOR0_ADDR_W:    .word   MXCBOOT_FLAG_REG
+AVIC_VECTOR1_ADDR_W:    .word   MXCFIS_FLAG_REG
+MXC_REDBOOT_ROM_START:  .word   SDRAM_BASE_ADDR + SDRAM_SIZE - 0x100000
+CONST_0x0FFF:           .word   0x0FFF
+CCM_BASE_ADDR_W:        .word   CCM_BASE_ADDR
+IPU_CTRL_BASE_ADDR_W:   .word   IPU_CTRL_BASE_ADDR
+CCM_CCMR_0x074B0BF5:    .word   0x074B0BF5
+CCM_CCMR_0x074B0BFD:    .word   0x074B0BFD
+CCM_CCMR_0x074B0B7D:    .word   0x074B0B7D
+WEIM_CTRL_CS5_W:    .word   WEIM_CTRL_CS5
+CS5_0x0000D843:     .word   0x0000D843
+CS5_0x22252521:     .word   0x22252521
+CS5_0x22220A00:     .word   0x22220A00
+
+/*---------------------------------------------------------------------------*/
+/* end of hal_platform_setup.h                                               */
+#endif /* CYGONCE_HAL_PLATFORM_SETUP_H */
diff -urN -x CVS dummy/packages/hal/arm/mx31/3stack/current/include/pkgconf/mlt_arm_board_romram.h ecos_mx31/packages/hal/arm/mx31/3stack/current/include/pkgconf/mlt_arm_board_romram.h
--- dummy/packages/hal/arm/mx31/3stack/current/include/pkgconf/mlt_arm_board_romram.h	1969-12-31 18:00:00.000000000 -0600
+++ ecos_mx31/packages/hal/arm/mx31/3stack/current/include/pkgconf/mlt_arm_board_romram.h	2008-04-01 11:25:30.000000000 -0500
@@ -0,0 +1,20 @@
+// eCos memory layout - Fri Oct 20 05:56:55 2000
+
+// This is a generated file - do not edit
+
+#ifndef __ASSEMBLER__
+#include <cyg/infra/cyg_type.h>
+#include <stddef.h>
+
+#endif
+#define CYGMEM_REGION_ram (0x00000000)
+#define CYGMEM_REGION_ram_SIZE (0x7F00000)
+#define CYGMEM_REGION_ram_ATTR (CYGMEM_REGION_ATTR_R | CYGMEM_REGION_ATTR_W)
+#define CYGMEM_REGION_rom (0x87F00000)
+#define CYGMEM_REGION_rom_SIZE (0x100000)
+#define CYGMEM_REGION_rom_ATTR (CYGMEM_REGION_ATTR_R)
+#ifndef __ASSEMBLER__
+extern char CYG_LABEL_NAME (__heap1) [];
+#endif
+#define CYGMEM_SECTION_heap1 (CYG_LABEL_NAME (__heap1))
+#define CYGMEM_SECTION_heap1_SIZE (CYGMEM_REGION_ram_SIZE - (size_t) CYG_LABEL_NAME (__heap1))
diff -urN -x CVS dummy/packages/hal/arm/mx31/3stack/current/include/pkgconf/mlt_arm_board_romram.ldi ecos_mx31/packages/hal/arm/mx31/3stack/current/include/pkgconf/mlt_arm_board_romram.ldi
--- dummy/packages/hal/arm/mx31/3stack/current/include/pkgconf/mlt_arm_board_romram.ldi	1969-12-31 18:00:00.000000000 -0600
+++ ecos_mx31/packages/hal/arm/mx31/3stack/current/include/pkgconf/mlt_arm_board_romram.ldi	2008-04-01 11:25:30.000000000 -0500
@@ -0,0 +1,28 @@
+// eCos memory layout - Fri Oct 20 05:56:55 2000
+
+// This is a generated file - do not edit
+
+#include <cyg/infra/cyg_type.inc>
+
+MEMORY
+{
+    ram : ORIGIN = 0, LENGTH = 0x7F00000
+    rom : ORIGIN = 0x87F00000, LENGTH = 0x100000
+}
+
+SECTIONS
+{
+    SECTIONS_BEGIN
+    SECTION_rom_vectors (rom, 0x87F00000, LMA_EQ_VMA)
+    SECTION_text (rom, ALIGN (0x4), LMA_EQ_VMA)
+    SECTION_fini (rom, ALIGN (0x4), LMA_EQ_VMA)
+    SECTION_rodata (rom, ALIGN (0x4), LMA_EQ_VMA)
+    SECTION_rodata1 (rom, ALIGN (0x4), LMA_EQ_VMA)
+    SECTION_fixup (rom, ALIGN (0x4), LMA_EQ_VMA)
+    SECTION_gcc_except_table (rom, ALIGN (0x4), LMA_EQ_VMA)
+    SECTION_fixed_vectors (ram, 0x20, LMA_EQ_VMA)
+    SECTION_data (ram, 0x8000, FOLLOWING (.gcc_except_table))
+    SECTION_bss (ram, ALIGN (0x4), LMA_EQ_VMA)
+    CYG_LABEL_DEFN(__heap1) = ALIGN (0x8);
+    SECTIONS_END
+}
diff -urN -x CVS dummy/packages/hal/arm/mx31/3stack/current/include/pkgconf/mlt_arm_board_romram.mlt ecos_mx31/packages/hal/arm/mx31/3stack/current/include/pkgconf/mlt_arm_board_romram.mlt
--- dummy/packages/hal/arm/mx31/3stack/current/include/pkgconf/mlt_arm_board_romram.mlt	1969-12-31 18:00:00.000000000 -0600
+++ ecos_mx31/packages/hal/arm/mx31/3stack/current/include/pkgconf/mlt_arm_board_romram.mlt	2008-04-01 11:25:30.000000000 -0500
@@ -0,0 +1,14 @@
+version 0
+region ram 0 7F00000 0 !
+region rom 87F00000 100000 1 !
+section fixed_vectors 0 1 0 1 1 0 1 0 20 20 !
+section data 0 1 1 1 1 1 0 0 8000 bss !
+section bss 0 4 0 1 0 1 0 1 heap1 heap1 !
+section heap1 0 8 0 0 0 0 0 0 !
+section rom_vectors 0 1 0 1 1 1 1 1 87F00000 87F00000 text text !
+section text 0 4 0 1 0 1 0 1 fini fini !
+section fini 0 4 0 1 0 1 0 1 rodata rodata !
+section rodata 0 4 0 1 0 1 0 1 rodata1 rodata1 !
+section rodata1 0 4 0 1 0 1 0 1 fixup fixup !
+section fixup 0 4 0 1 0 1 0 1 gcc_except_table gcc_except_table !
+section gcc_except_table 0 4 0 1 0 0 0 1 data !
diff -urN -x CVS dummy/packages/hal/arm/mx31/3stack/current/include/plf_io.h ecos_mx31/packages/hal/arm/mx31/3stack/current/include/plf_io.h
--- dummy/packages/hal/arm/mx31/3stack/current/include/plf_io.h	1969-12-31 18:00:00.000000000 -0600
+++ ecos_mx31/packages/hal/arm/mx31/3stack/current/include/plf_io.h	2008-04-01 11:25:29.000000000 -0500
@@ -0,0 +1,69 @@
+#ifndef CYGONCE_HAL_ARM_BOARD_PLF_IO_H
+#define CYGONCE_HAL_ARM_BOARD_PLF_IO_H
+
+//=============================================================================
+//
+//      plf_io.h
+//
+//      Platform specific support (register layout, etc)
+//
+//=============================================================================
+//####ECOSGPLCOPYRIGHTBEGIN####
+// -------------------------------------------
+// This file is part of eCos, the Embedded Configurable Operating System.
+// Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+//
+// eCos is free software; you can redistribute it and/or modify it under
+// the terms of the GNU General Public License as published by the Free
+// Software Foundation; either version 2 or (at your option) any later version.
+//
+// eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with eCos; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+//
+// As a special exception, if other files instantiate templates or use macros
+// or inline functions from this file, or you compile this file and link it
+// with other works to produce a work based on this file, this file does not
+// by itself cause the resulting work to be covered by the GNU General Public
+// License. However the source code for this file must still be made available
+// in accordance with section (3) of the GNU General Public License.
+//
+// This exception does not invalidate any other reasons why a work based on
+// this file might be covered by the GNU General Public License.
+//
+// Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+// at http://sources.redhat.com/ecos/ecos-license/
+// -------------------------------------------
+//####ECOSGPLCOPYRIGHTEND####
+//=============================================================================
+
+#include <cyg/hal/fsl_board.h>
+#include <cyg/hal/hal_soc.h>
+
+#define CYGHWR_REDBOOT_LINUX_ATAG_MEM(_p_)                                                           \
+    CYG_MACRO_START                                                                                  \
+    {                                                                                                \
+      extern unsigned int system_rev;                                                                \
+             /* Next ATAG_MEM. */                                                                    \
+         _p_->hdr.size = (sizeof(struct tag_mem32) + sizeof(struct tag_header))/sizeof(long);        \
+         _p_->hdr.tag = ATAG_MEM;                                                                    \
+         /* Round up so there's only one bit set in the memory size.                                 \
+         * Don't double it if it's already a power of two, though.                                   \
+         */                                                                                          \
+         _p_->u.mem.size  = 1<<hal_msbindex(CYGMEM_REGION_ram_SIZE);                                 \
+         if (_p_->u.mem.size < CYGMEM_REGION_ram_SIZE)                                               \
+                 _p_->u.mem.size <<= 1;                                                              \
+         _p_->u.mem.start = CYGARC_PHYSICAL_ADDRESS(CYGMEM_REGION_ram);                              \
+         _p_ = (struct tag *)((long *)_p_ + _p_->hdr.size);                                          \
+         _p_->hdr.size = ((sizeof(struct tag_revision)) + sizeof(struct tag_header))/sizeof(long);   \
+         _p_->hdr.tag = ATAG_REVISION;                                                               \
+         _p_->u.revision.rev = system_rev;                                                           \
+     }                                                                                               \
+    CYG_MACRO_END
+
+#endif // CYGONCE_HAL_ARM_BOARD_PLF_IO_H
diff -urN -x CVS dummy/packages/hal/arm/mx31/3stack/current/include/plf_mmap.h ecos_mx31/packages/hal/arm/mx31/3stack/current/include/plf_mmap.h
--- dummy/packages/hal/arm/mx31/3stack/current/include/plf_mmap.h	1969-12-31 18:00:00.000000000 -0600
+++ ecos_mx31/packages/hal/arm/mx31/3stack/current/include/plf_mmap.h	2008-04-01 11:25:29.000000000 -0500
@@ -0,0 +1,65 @@
+#ifndef CYGONCE_HAL_BOARD_PLATFORM_PLF_MMAP_H
+#define CYGONCE_HAL_BOARD_PLATFORM_PLF_MMAP_H
+//=============================================================================
+//
+//      plf_mmap.h
+//
+//      Platform specific memory map support
+//
+//=============================================================================
+//####ECOSGPLCOPYRIGHTBEGIN####
+// -------------------------------------------
+// This file is part of eCos, the Embedded Configurable Operating System.
+// Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+//
+// eCos is free software; you can redistribute it and/or modify it under
+// the terms of the GNU General Public License as published by the Free
+// Software Foundation; either version 2 or (at your option) any later version.
+//
+// eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with eCos; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+//
+// As a special exception, if other files instantiate templates or use macros
+// or inline functions from this file, or you compile this file and link it
+// with other works to produce a work based on this file, this file does not
+// by itself cause the resulting work to be covered by the GNU General Public
+// License. However the source code for this file must still be made available
+// in accordance with section (3) of the GNU General Public License.
+//
+// This exception does not invalidate any other reasons why a work based on
+// this file might be covered by the GNU General Public License.
+//
+// Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+// at http://sources.redhat.com/ecos/ecos-license/
+// -------------------------------------------
+//####ECOSGPLCOPYRIGHTEND####
+//===========================================================================
+
+#include <cyg/hal/hal_misc.h>
+
+// Get the pagesize for a particular virtual address:
+
+// This does not depend on the vaddr.
+#define HAL_MM_PAGESIZE(vaddr, pagesize) CYG_MACRO_START        \
+        (pagesize) = SZ_1M;                                         \
+CYG_MACRO_END
+
+// Get the physical address from a virtual address:
+
+#define HAL_VIRT_TO_PHYS_ADDRESS( vaddr, paddr ) CYG_MACRO_START           \
+        cyg_uint32 _v_ = (cyg_uint32)(vaddr);                                  \
+        if ( _v_ < 128 * SZ_1M )          /* SDRAM */                           \
+                _v_ += 0x800u * SZ_1M;                                             \
+        else                             /* Rest of it */                      \
+                /* no change */ ;                                                  \
+                (paddr) = _v_;                                                         \
+CYG_MACRO_END
+
+//---------------------------------------------------------------------------
+#endif // CYGONCE_HAL_BOARD_PLATFORM_PLF_MMAP_H
diff -urN -x CVS dummy/packages/hal/arm/mx31/3stack/current/misc/redboot_ROMRAM.ecm ecos_mx31/packages/hal/arm/mx31/3stack/current/misc/redboot_ROMRAM.ecm
--- dummy/packages/hal/arm/mx31/3stack/current/misc/redboot_ROMRAM.ecm	1969-12-31 18:00:00.000000000 -0600
+++ ecos_mx31/packages/hal/arm/mx31/3stack/current/misc/redboot_ROMRAM.ecm	2008-04-02 12:10:02.000000000 -0500
@@ -0,0 +1,124 @@
+cdl_savefile_version 1;
+cdl_savefile_command cdl_savefile_version {};
+cdl_savefile_command cdl_savefile_command {};
+cdl_savefile_command cdl_configuration { description hardware template package };
+cdl_savefile_command cdl_package { value_source user_value wizard_value inferred_value };
+cdl_savefile_command cdl_component { value_source user_value wizard_value inferred_value };
+cdl_savefile_command cdl_option { value_source user_value wizard_value inferred_value };
+cdl_savefile_command cdl_interface { value_source user_value wizard_value inferred_value };
+
+cdl_configuration eCos {
+    description "" ;
+    hardware    mx31_3stack ;
+    template    redboot ;
+    package -hardware CYGPKG_HAL_ARM current ;
+    package -hardware CYGPKG_HAL_ARM_MX31 current ;
+    package -hardware CYGPKG_HAL_ARM_MX31_3STACK current ;
+    package -hardware CYGPKG_IO_ETH_DRIVERS current ;
+    package -hardware CYGPKG_DEVS_ETH_ARM_IMX_3STACK current ;
+    package -hardware CYGPKG_DEVS_ETH_SMSC_LAN92XX current ;
+    package -hardware CYGPKG_COMPRESS_ZLIB current ;
+    package -hardware CYGPKG_IO_FLASH current ;
+    package -hardware CYGPKG_DEVS_FLASH_ONMXC current ;
+    package -hardware CYGPKG_DEVS_MXC_SPI current ;
+    package -hardware CYGPKG_DEVS_MXC_I2C current ;
+    package -template CYGPKG_HAL current ;
+    package -template CYGPKG_INFRA current ;
+    package -template CYGPKG_REDBOOT current ;
+    package -template CYGPKG_ISOINFRA current ;
+    package -template CYGPKG_LIBC_STRING current ;
+    package -template CYGPKG_CRC current ;
+    package CYGPKG_MEMALLOC current ;
+};
+
+cdl_option CYGFUN_LIBC_STRING_BSD_FUNCS {
+    inferred_value 0
+};
+
+cdl_option CYGHWR_DEVS_FLASH_MXC_NOR {
+    inferred_value 0
+};
+
+cdl_option CYGHWR_DEVS_FSL_SPI_VER_0_4 {
+    inferred_value 1
+};
+
+cdl_option CYGHWR_DEVS_FLASH_MXC_NAND {
+    inferred_value 1
+};
+
+cdl_option CYGIMP_HAL_COMMON_INTERRUPTS_USE_INTERRUPT_STACK {
+    inferred_value 0
+};
+
+cdl_option CYGNUM_HAL_COMMON_INTERRUPTS_STACK_SIZE {
+    user_value 4096
+};
+
+cdl_option CYGDBG_HAL_COMMON_INTERRUPTS_SAVE_MINIMUM_CONTEXT {
+    user_value 0
+};
+
+cdl_option CYGDBG_REDBOOT_TICK_GRANULARITY {
+    user_value 50
+};
+
+cdl_option CYGDBG_HAL_COMMON_CONTEXT_SAVE_MINIMUM {
+    inferred_value 0
+};
+
+cdl_option CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS {
+    inferred_value 1
+};
+
+cdl_option CYGSEM_HAL_ROM_MONITOR {
+    inferred_value 1
+};
+
+cdl_component CYGBLD_BUILD_REDBOOT {
+    user_value 1
+};
+
+cdl_option CYGBLD_REDBOOT_MIN_IMAGE_SIZE {
+    inferred_value 0x00040000
+};
+
+cdl_option CYGHWR_REDBOOT_ARM_LINUX_EXEC_ADDRESS_DEFAULT {
+    inferred_value 0x80008000
+};
+
+cdl_option CYGBLD_ISO_STRTOK_R_HEADER {
+    inferred_value 1 <cyg/libc/string/string.h>
+};
+
+cdl_option CYGBLD_ISO_STRING_LOCALE_FUNCS_HEADER {
+    inferred_value 1 <cyg/libc/string/string.h>
+};
+
+cdl_option CYGBLD_ISO_STRING_BSD_FUNCS_HEADER {
+    inferred_value 1 <cyg/libc/string/bsdstring.h>
+};
+
+cdl_option CYGBLD_ISO_STRING_MEMFUNCS_HEADER {
+    inferred_value 1 <cyg/libc/string/string.h>
+};
+
+cdl_option CYGBLD_ISO_STRING_STRFUNCS_HEADER {
+    inferred_value 1 <cyg/libc/string/string.h>
+};
+
+cdl_component CYG_HAL_STARTUP {
+    user_value ROMRAM
+};
+
+cdl_component CYGPRI_REDBOOT_ZLIB_FLASH_FORCE {
+    inferred_value 1
+};
+
+cdl_option CYGDAT_REDBOOT_CUSTOM_VERSION {
+    user_value 1 "FSL 200814"
+};
+
+cdl_option CYGNUM_REDBOOT_FIS_DIRECTORY_BLOCK {
+    inferred_value 4
+};
diff -urN -x CVS dummy/packages/hal/arm/mx31/3stack/current/src/board_diag.c ecos_mx31/packages/hal/arm/mx31/3stack/current/src/board_diag.c
--- dummy/packages/hal/arm/mx31/3stack/current/src/board_diag.c	1969-12-31 18:00:00.000000000 -0600
+++ ecos_mx31/packages/hal/arm/mx31/3stack/current/src/board_diag.c	2008-04-01 11:25:30.000000000 -0500
@@ -0,0 +1,647 @@
+/*=============================================================================
+//
+//      board_diag.c
+//
+//      HAL diagnostic output code
+//
+//=============================================================================
+//####ECOSGPLCOPYRIGHTBEGIN####
+// -------------------------------------------
+// This file is part of eCos, the Embedded Configurable Operating System.
+// Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+//
+// eCos is free software; you can redistribute it and/or modify it under
+// the terms of the GNU General Public License as published by the Free
+// Software Foundation; either version 2 or (at your option) any later version.
+//
+// eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with eCos; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+//
+// As a special exception, if other files instantiate templates or use macros
+// or inline functions from this file, or you compile this file and link it
+// with other works to produce a work based on this file, this file does not
+// by itself cause the resulting work to be covered by the GNU General Public
+// License. However the source code for this file must still be made available
+// in accordance with section (3) of the GNU General Public License.
+//
+// This exception does not invalidate any other reasons why a work based on
+// this file might be covered by the GNU General Public License.
+//
+// Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+// at http://sources.redhat.com/ecos/ecos-license/
+// -------------------------------------------
+//####ECOSGPLCOPYRIGHTEND####
+//===========================================================================*/
+
+#include <pkgconf/hal.h>
+
+#include <cyg/infra/cyg_type.h>         // base types
+#include <cyg/infra/cyg_trac.h>         // tracing macros
+#include <cyg/infra/cyg_ass.h>          // assertion macros
+
+#include <cyg/hal/hal_arch.h>           // basic machine info
+#include <cyg/hal/hal_intr.h>           // interrupt macros
+#include <cyg/hal/hal_io.h>             // IO macros
+#include <cyg/hal/hal_diag.h>
+#include <cyg/hal/hal_if.h>             // Calling-if API
+#include <cyg/hal/drv_api.h>            // driver API
+#include <cyg/hal/hal_misc.h>           // Helper functions
+#include <cyg/hal/hal_soc.h>            // Hardware definitions
+#include <cyg/hal/fsl_board.h>          // Platform specifics
+
+static void cyg_hal_plf_duart_init(void);
+extern void cyg_hal_plf_serial_init(void);
+
+#define DUART_WORKAROUND_DELAY(a)    hal_delay_us(a);
+
+
+void cyg_hal_plf_comms_init(void)
+{
+    static int initialized = 0;
+
+    if (initialized)
+        return;
+
+    initialized = 1;
+
+    /* Setup GPIO and enable transceiver for UARTs */
+    cyg_hal_plf_duart_init();
+    cyg_hal_plf_serial_init();
+}
+
+//=============================================================================
+// ST16552 DUART driver
+//=============================================================================
+
+//-----------------------------------------------------------------------------
+// There are two serial ports.
+#define CYG_DEV_SERIAL_BASE_A    (BOARD_CS_UART_BASE + 0x0000) // port A
+#define CYG_DEV_SERIAL_BASE_B    (BOARD_CS_UART_BASE + 0x8000) // port B
+
+//-----------------------------------------------------------------------------
+// Based on 14.7456 MHz xtal
+#if CYGNUM_HAL_VIRTUAL_VECTOR_CONSOLE_CHANNEL_BAUD==9600
+#define CYG_DEV_SERIAL_BAUD_MSB        0x00
+#define CYG_DEV_SERIAL_BAUD_LSB        0x60
+#endif
+#if CYGNUM_HAL_VIRTUAL_VECTOR_CONSOLE_CHANNEL_BAUD==19200
+#define CYG_DEV_SERIAL_BAUD_MSB        0x00
+#define CYG_DEV_SERIAL_BAUD_LSB        0x30
+#endif
+#if CYGNUM_HAL_VIRTUAL_VECTOR_CONSOLE_CHANNEL_BAUD==38400
+#define CYG_DEV_SERIAL_BAUD_MSB        0x00
+#define CYG_DEV_SERIAL_BAUD_LSB        0x18
+#endif
+#if CYGNUM_HAL_VIRTUAL_VECTOR_CONSOLE_CHANNEL_BAUD==57600
+#define CYG_DEV_SERIAL_BAUD_MSB        0x00
+#define CYG_DEV_SERIAL_BAUD_LSB        0x10
+#endif
+#if CYGNUM_HAL_VIRTUAL_VECTOR_CONSOLE_CHANNEL_BAUD==115200
+#define CYG_DEV_SERIAL_BAUD_MSB        0x00
+#define CYG_DEV_SERIAL_BAUD_LSB        0x08
+#endif
+
+#ifndef CYG_DEV_SERIAL_BAUD_MSB
+#error Missing/incorrect serial baud rate defined - CDL error?
+#endif
+
+//-----------------------------------------------------------------------------
+// Define the serial registers. The board is equipped with a 16552
+// serial chip.
+
+#ifdef EXT_UART_x16
+#define HAL_WRITE_UINT_UART HAL_WRITE_UINT16
+#define HAL_READ_UINT_UART HAL_READ_UINT16
+typedef cyg_uint16 uart_width;
+#else  //_x8
+typedef cyg_uint8 uart_width;
+#define HAL_WRITE_UINT_UART HAL_WRITE_UINT8
+#define HAL_READ_UINT_UART HAL_READ_UINT8
+#endif
+
+#define CYG_DEV_SERIAL_RHR   0x00 // receiver buffer register, read, dlab = 0
+#define CYG_DEV_SERIAL_THR   0x00 // transmitter holding register, write, dlab = 0
+#define CYG_DEV_SERIAL_DLL   0x00 // divisor latch (LS), read/write, dlab = 1
+#define CYG_DEV_SERIAL_IER   0x01 // interrupt enable register, read/write, dlab = 0
+#define CYG_DEV_SERIAL_DLM   0x01 // divisor latch (MS), read/write, dlab = 1
+#define CYG_DEV_SERIAL_IIR   0x02 // interrupt identification register, read, dlab = 0
+#define CYG_DEV_SERIAL_FCR   0x02 // fifo control register, write, dlab = 0
+#define CYG_DEV_SERIAL_AFR   0x02 // alternate function register, read/write, dlab = 1
+#define CYG_DEV_SERIAL_LCR   0x03 // line control register, read/write
+#define CYG_DEV_SERIAL_MCR   0x04
+#define CYG_DEV_SERIAL_MCR_A 0x04
+#define CYG_DEV_SERIAL_MCR_B 0x04
+#define CYG_DEV_SERIAL_LSR   0x05 // line status register, read
+#define CYG_DEV_SERIAL_MSR   0x06 // modem status register, read
+#define CYG_DEV_SERIAL_SCR   0x07 // scratch pad register
+
+// The interrupt enable register bits.
+#define SIO_IER_ERDAI   0x01            // enable received data available irq
+#define SIO_IER_ETHREI  0x02            // enable THR empty interrupt
+#define SIO_IER_ELSI    0x04            // enable receiver line status irq
+#define SIO_IER_EMSI    0x08            // enable modem status interrupt
+
+// The interrupt identification register bits.
+#define SIO_IIR_IP      0x01            // 0 if interrupt pending
+#define SIO_IIR_ID_MASK 0x0e            // mask for interrupt ID bits
+#define ISR_Tx          0x02
+#define ISR_Rx          0x04
+
+// The line status register bits.
+#define SIO_LSR_DR      0x01            // data ready
+#define SIO_LSR_OE      0x02            // overrun error
+#define SIO_LSR_PE      0x04            // parity error
+#define SIO_LSR_FE      0x08            // framing error
+#define SIO_LSR_BI      0x10            // break interrupt
+#define SIO_LSR_THRE    0x20            // transmitter holding register empty
+#define SIO_LSR_TEMT    0x40            // transmitter register empty
+#define SIO_LSR_ERR     0x80            // any error condition
+
+// The modem status register bits.
+#define SIO_MSR_DCTS    0x01            // delta clear to send
+#define SIO_MSR_DDSR    0x02            // delta data set ready
+#define SIO_MSR_TERI    0x04            // trailing edge ring indicator
+#define SIO_MSR_DDCD    0x08            // delta data carrier detect
+#define SIO_MSR_CTS     0x10            // clear to send
+#define SIO_MSR_DSR     0x20            // data set ready
+#define SIO_MSR_RI      0x40            // ring indicator
+#define SIO_MSR_DCD     0x80            // data carrier detect
+
+// The line control register bits.
+#define SIO_LCR_WLS0   0x01             // word length select bit 0
+#define SIO_LCR_WLS1   0x02             // word length select bit 1
+#define SIO_LCR_STB    0x04             // number of stop bits
+#define SIO_LCR_PEN    0x08             // parity enable
+#define SIO_LCR_EPS    0x10             // even parity select
+#define SIO_LCR_SP     0x20             // stick parity
+#define SIO_LCR_SB     0x40             // set break
+#define SIO_LCR_DLAB   0x80             // divisor latch access bit
+
+// The FIFO control register
+#define SIO_FCR_FCR0   0x01             // enable xmit and rcvr fifos
+#define SIO_FCR_FCR1   0x02             // clear RCVR FIFO
+#define SIO_FCR_FCR2   0x04             // clear XMIT FIFO
+
+//-----------------------------------------------------------------------------
+
+typedef struct {
+    uart_width* base;
+    cyg_int32 msec_timeout;
+    int isr_vector;
+} channel_data_t;
+
+static channel_data_t channels[] = {
+#if CYGHWR_HAL_ARM_DUART_UARTA != 0
+    {(uart_width*)CYG_DEV_SERIAL_BASE_A, 1000, 0},
+#endif
+#if CYGHWR_HAL_ARM_DUART_UARTB != 0
+    {(uart_width*)CYG_DEV_SERIAL_BASE_B, 1000, 0}
+#endif
+};
+
+//-----------------------------------------------------------------------------
+
+static void init_duart_channel(channel_data_t* __ch_data)
+{
+    uart_width* base = __ch_data->base;
+    uart_width lcr;
+
+    // 8-1-no parity.
+    HAL_WRITE_UINT_UART(base+CYG_DEV_SERIAL_LCR,
+                        SIO_LCR_WLS0 | SIO_LCR_WLS1);
+    DUART_WORKAROUND_DELAY(50);
+    HAL_READ_UINT_UART(base+CYG_DEV_SERIAL_LCR, lcr);
+    lcr |= SIO_LCR_DLAB;
+    DUART_WORKAROUND_DELAY(50);
+    HAL_WRITE_UINT_UART(base+CYG_DEV_SERIAL_LCR, lcr);
+    DUART_WORKAROUND_DELAY(50);
+    HAL_WRITE_UINT_UART(base+CYG_DEV_SERIAL_DLL, CYG_DEV_SERIAL_BAUD_LSB);
+    DUART_WORKAROUND_DELAY(50);
+    HAL_WRITE_UINT_UART(base+CYG_DEV_SERIAL_DLM, CYG_DEV_SERIAL_BAUD_MSB);
+    lcr &= ~SIO_LCR_DLAB;
+    DUART_WORKAROUND_DELAY(50);
+    HAL_WRITE_UINT_UART(base+CYG_DEV_SERIAL_LCR, lcr);
+    DUART_WORKAROUND_DELAY(50);
+    HAL_WRITE_UINT_UART(base+CYG_DEV_SERIAL_FCR, 0x07);  // Enable & clear FIFO
+}
+
+//#define x_debug_uart_log_buf
+#ifdef x_debug_uart_log_buf
+#define x_DIAG_BUFSIZE 2048
+static char __x_log_buf[x_DIAG_BUFSIZE];
+static int x_diag_bp = 0;
+#endif
+
+void cyg_hal_plf_duart_putc(void* __ch_data, cyg_uint8 c)
+{
+    uart_width* base = ((channel_data_t*)__ch_data)->base;
+    uart_width lsr;
+
+#ifdef x_debug_uart_log_buf
+    __x_log_buf[x_diag_bp++] = c;
+#endif
+    CYGARC_HAL_SAVE_GP();
+
+    do {
+        HAL_READ_UINT_UART(base+CYG_DEV_SERIAL_LSR, lsr);
+    } while ((lsr & SIO_LSR_THRE) == 0);
+
+    DUART_WORKAROUND_DELAY(50);
+    HAL_WRITE_UINT_UART(base+CYG_DEV_SERIAL_THR, c);
+
+    // Hang around until the character has been safely sent.
+    do {
+        HAL_READ_UINT_UART(base+CYG_DEV_SERIAL_LSR, lsr);
+    } while ((lsr & SIO_LSR_THRE) == 0);
+
+    CYGARC_HAL_RESTORE_GP();
+}
+
+static cyg_bool cyg_hal_plf_duart_getc_nonblock(void* __ch_data, cyg_uint8* ch)
+{
+    uart_width* base = ((channel_data_t*)__ch_data)->base;
+    uart_width lsr, ch16;
+
+    HAL_READ_UINT_UART(base+CYG_DEV_SERIAL_LSR, lsr);
+    if ((lsr & SIO_LSR_DR) == 0)
+        return false;
+
+    HAL_READ_UINT_UART(base+CYG_DEV_SERIAL_RHR, ch16);
+
+    *ch = (cyg_uint8) (ch16 & 0x00FF);
+
+    return true;
+}
+
+cyg_uint8 cyg_hal_plf_duart_getc(void* __ch_data)
+{
+    cyg_uint8 ch;
+
+    CYGARC_HAL_SAVE_GP();
+
+    while (!cyg_hal_plf_duart_getc_nonblock(__ch_data, &ch));
+
+    CYGARC_HAL_RESTORE_GP();
+    return ch;
+}
+
+static void cyg_hal_plf_duart_write(void* __ch_data, const cyg_uint8* __buf,
+                                    cyg_uint32 __len)
+{
+    CYGARC_HAL_SAVE_GP();
+
+    while (__len-- > 0)
+        cyg_hal_plf_duart_putc(__ch_data, *__buf++);
+
+    CYGARC_HAL_RESTORE_GP();
+}
+
+static void cyg_hal_plf_duart_read(void* __ch_data, cyg_uint8* __buf,
+                                   cyg_uint32 __len)
+{
+    CYGARC_HAL_SAVE_GP();
+
+    while (__len-- > 0)
+        *__buf++ = cyg_hal_plf_duart_getc(__ch_data);
+
+    CYGARC_HAL_RESTORE_GP();
+}
+
+cyg_bool cyg_hal_plf_duart_getc_timeout(void* __ch_data, cyg_uint8* ch)
+{
+    int delay_count;
+    channel_data_t* chan = (channel_data_t*)__ch_data;
+    cyg_bool res;
+
+    CYGARC_HAL_SAVE_GP();
+
+    delay_count = chan->msec_timeout * 10; // delay in .1 ms steps
+    for (;;) {
+        res = cyg_hal_plf_duart_getc_nonblock(__ch_data, ch);
+        if (res || 0 == delay_count--)
+            break;
+
+        CYGACC_CALL_IF_DELAY_US(100);
+    }
+
+    CYGARC_HAL_RESTORE_GP();
+    return res;
+}
+
+static int cyg_hal_plf_duart_control(void *__ch_data,
+                                     __comm_control_cmd_t __func, ...)
+{
+    static int irq_state = 0;
+    channel_data_t* chan = (channel_data_t*)__ch_data;
+    uart_width ier;
+    int ret = 0;
+
+    CYGARC_HAL_SAVE_GP();
+
+    switch (__func) {
+    case __COMMCTL_IRQ_ENABLE:
+        HAL_INTERRUPT_UNMASK(chan->isr_vector);
+        HAL_INTERRUPT_SET_LEVEL(chan->isr_vector, 1);
+        HAL_READ_UINT_UART(chan->base+CYG_DEV_SERIAL_IER, ier);
+        ier |= SIO_IER_ERDAI;
+        HAL_WRITE_UINT_UART(chan->base+CYG_DEV_SERIAL_IER, ier);
+        irq_state = 1;
+        break;
+    case __COMMCTL_IRQ_DISABLE:
+        ret = irq_state;
+        irq_state = 0;
+        HAL_INTERRUPT_MASK(chan->isr_vector);
+        HAL_READ_UINT_UART(chan->base+CYG_DEV_SERIAL_IER, ier);
+        ier &= ~SIO_IER_ERDAI;
+        HAL_WRITE_UINT_UART(chan->base+CYG_DEV_SERIAL_IER, ier);
+        break;
+    case __COMMCTL_DBG_ISR_VECTOR:
+        ret = chan->isr_vector;
+        break;
+    case __COMMCTL_SET_TIMEOUT:
+        {
+            va_list ap;
+
+            va_start(ap, __func);
+
+            ret = chan->msec_timeout;
+            chan->msec_timeout = va_arg(ap, cyg_uint32);
+
+            va_end(ap);
+        }
+        break;
+    default:
+        break;
+    }
+    CYGARC_HAL_RESTORE_GP();
+    return ret;
+}
+
+static int cyg_hal_plf_duart_isr(void *__ch_data, int* __ctrlc,
+                                 CYG_ADDRWORD __vector, CYG_ADDRWORD __data)
+{
+    channel_data_t* chan = (channel_data_t*)__ch_data;
+    uart_width _iir;
+    int res = 0;
+    CYGARC_HAL_SAVE_GP();
+
+    HAL_READ_UINT_UART(chan->base+CYG_DEV_SERIAL_IIR, _iir);
+    _iir &= SIO_IIR_ID_MASK;
+
+    *__ctrlc = 0;
+    if ( ISR_Rx == _iir ) {
+        uart_width c, lsr;
+        cyg_uint8 c8;
+        HAL_READ_UINT_UART(chan->base+CYG_DEV_SERIAL_LSR, lsr);
+        if (lsr & SIO_LSR_DR) {
+
+            HAL_READ_UINT_UART(chan->base+CYG_DEV_SERIAL_RHR, c);
+
+            c8 = (cyg_uint8) (c & 0x00FF);
+
+            if (cyg_hal_is_break( &c8 , 1 ))
+                *__ctrlc = 1;
+        }
+
+        // Acknowledge the interrupt
+        HAL_INTERRUPT_ACKNOWLEDGE(chan->isr_vector);
+        res = CYG_ISR_HANDLED;
+    }
+
+    CYGARC_HAL_RESTORE_GP();
+    return res;
+}
+
+static void cyg_hal_plf_duart_init(void)
+{
+    hal_virtual_comm_table_t* comm;
+    int cur = CYGACC_CALL_IF_SET_CONSOLE_COMM(CYGNUM_CALL_IF_SET_COMM_ID_QUERY_CURRENT);
+    int i;
+
+    // Init channels
+#define NUMOF(x) (sizeof(x)/sizeof(x[0]))
+    for (i = 0;  i < NUMOF(channels);  i++) {
+        HAL_INTERRUPT_MASK(channels[i].isr_vector);
+        init_duart_channel(&channels[i]);
+        CYGACC_CALL_IF_SET_CONSOLE_COMM(i);
+        comm = CYGACC_CALL_IF_CONSOLE_PROCS();
+        CYGACC_COMM_IF_CH_DATA_SET(*comm, &channels[i]);
+        CYGACC_COMM_IF_WRITE_SET(*comm, cyg_hal_plf_duart_write);
+        CYGACC_COMM_IF_READ_SET(*comm, cyg_hal_plf_duart_read);
+        CYGACC_COMM_IF_PUTC_SET(*comm, cyg_hal_plf_duart_putc);
+        CYGACC_COMM_IF_GETC_SET(*comm, cyg_hal_plf_duart_getc);
+        CYGACC_COMM_IF_CONTROL_SET(*comm, cyg_hal_plf_duart_control);
+        CYGACC_COMM_IF_DBG_ISR_SET(*comm, cyg_hal_plf_duart_isr);
+        CYGACC_COMM_IF_GETC_TIMEOUT_SET(*comm, cyg_hal_plf_duart_getc_timeout);
+    }
+
+    // Restore original console
+    CYGACC_CALL_IF_SET_CONSOLE_COMM(cur);
+}
+
+//=============================================================================
+// Compatibility with older stubs
+//=============================================================================
+
+//=============================================================================
+// Compatibility with older stubs
+//=============================================================================
+
+#ifndef CYGSEM_HAL_VIRTUAL_VECTOR_DIAG
+
+#include <cyg/hal/hal_stub.h>           // cyg_hal_gdb_interrupt
+
+#if (CYGNUM_HAL_VIRTUAL_VECTOR_CONSOLE_CHANNEL == 0)
+#define __BASE   CMA101_DUARTA
+#define _INT     CYGNUM_HAL_INTERRUPT_SERIAL_A
+#elif (CYGNUM_HAL_VIRTUAL_VECTOR_CONSOLE_CHANNEL == 1)
+#define __BASE   CMA101_DUARTB
+#define _INT     CYGNUM_HAL_INTERRUPT_SERIAL_B
+#endif
+
+#ifdef __BASE
+
+#ifdef CYGSEM_HAL_ROM_MONITOR
+#define CYG_HAL_STARTUP_ROM
+#define CYG_HAL_STARTUP_ROMRAM
+#undef CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS
+#endif
+
+#if (defined(CYG_HAL_STARTUP_ROM) || defined(CYG_HAL_STARTUP_ROMRAM)) && !defined(CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS)
+#define HAL_DIAG_USES_HARDWARE
+#elif !defined(CYGDBG_HAL_DIAG_TO_DEBUG_CHAN)
+#define HAL_DIAG_USES_HARDWARE
+#elif CYGNUM_HAL_VIRTUAL_VECTOR_CONSOLE_CHANNEL != CYGNUM_HAL_VIRTUAL_VECTOR_DEBUG_CHANNEL
+#define HAL_DIAG_USES_HARDWARE
+#endif
+
+static channel_data_t channel = {
+    (uart_width*) _BASE, 0, 0
+};
+
+#ifdef HAL_DIAG_USES_HARDWARE
+
+void hal_diag_init(void)
+{
+    static int init = 0;
+    char *msg = "\n\rARM eCos\n\r";
+    uart_width lcr;
+
+    if (init++) return;
+
+    init_duart_channel(&channel);
+
+    while (*msg) hal_diag_write_char(*msg++);
+}
+
+#ifdef DEBUG_DIAG
+#if defined(CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS)
+#define DIAG_BUFSIZE 32
+#else
+#define DIAG_BUFSIZE 2048
+#endif
+static char diag_buffer[DIAG_BUFSIZE];
+static int diag_bp = 0;
+#endif
+
+void hal_diag_write_char(char c)
+{
+    uart_width lsr;
+
+    hal_diag_init();
+
+    cyg_hal_plf_duart_putc(&channel, c)
+
+#ifdef DEBUG_DIAG
+    diag_buffer[diag_bp++] = c;
+    if (diag_bp == DIAG_BUFSIZE) {
+        while (1) ;
+        diag_bp = 0;
+    }
+#endif
+}
+
+void hal_diag_read_char(char *c)
+{
+    *c = cyg_hal_plf_duart_getc(&channel);
+}
+
+#else // HAL_DIAG relies on GDB
+
+// Initialize diag port - assume GDB channel is already set up
+void hal_diag_init(void)
+{
+    if (0) init_duart_channel(&channel); // avoid warning
+}
+
+// Actually send character down the wire
+static void hal_diag_write_char_serial(char c)
+{
+    cyg_hal_plf_duart_putc(&channel, c);
+}
+
+static bool hal_diag_read_serial(char *c)
+{
+    long timeout = 1000000000;  // A long time...
+
+    while (!cyg_hal_plf_duart_getc_nonblock(&channel, c))
+        if (0 == --timeout) return false;
+
+    return true;
+}
+
+void hal_diag_read_char(char *c)
+{
+    while (!hal_diag_read_serial(c)) ;
+}
+
+void hal_diag_write_char(char c)
+{
+    static char line[100];
+    static int pos = 0;
+
+    // No need to send CRs
+    if (c == '\r') return;
+
+    line[pos++] = c;
+
+    if (c == '\n' || pos == sizeof(line)) {
+        CYG_INTERRUPT_STATE old;
+
+        // Disable interrupts. This prevents GDB trying to interrupt us
+        // while we are in the middle of sending a packet. The serial
+        // receive interrupt will be seen when we re-enable interrupts
+        // later.
+
+#ifdef CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS
+        CYG_HAL_GDB_ENTER_CRITICAL_IO_REGION(old);
+#else
+        HAL_DISABLE_INTERRUPTS(old);
+#endif
+
+        while (1) {
+            static char hex[] = "0123456789ABCDEF";
+            cyg_uint8 csum = 0;
+            int i;
+            char c1;
+
+            hal_diag_write_char_serial('$');
+            hal_diag_write_char_serial('O');
+            csum += 'O';
+            for (i = 0; i < pos; i++) {
+                char ch = line[i];
+                char h = hex[(ch>>4)&0xF];
+                char l = hex[ch&0xF];
+                hal_diag_write_char_serial(h);
+                hal_diag_write_char_serial(l);
+                csum += h;
+                csum += l;
+            }
+            hal_diag_write_char_serial('#');
+            hal_diag_write_char_serial(hex[(csum>>4)&0xF]);
+            hal_diag_write_char_serial(hex[csum&0xF]);
+
+            // Wait for the ACK character '+' from GDB here and handle
+            // receiving a ^C instead.  This is the reason for this clause
+            // being a loop.
+            if (!hal_diag_read_serial(&c1))
+                continue;   // No response - try sending packet again
+
+            if ( c1 == '+' )
+                break;          // a good acknowledge
+
+#ifdef CYGDBG_HAL_DEBUG_GDB_BREAK_SUPPORT
+            cyg_drv_interrupt_acknowledge(CYG_DEV_SERIAL_INT);
+            if ( c1 == 3 ) {
+                // Ctrl-C: breakpoint.
+                cyg_hal_gdb_interrupt (__builtin_return_address(0));
+                break;
+            }
+#endif
+            // otherwise, loop round again
+        }
+
+        pos = 0;
+
+        // And re-enable interrupts
+#ifdef CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS
+        CYG_HAL_GDB_LEAVE_CRITICAL_IO_REGION(old);
+#else
+        HAL_RESTORE_INTERRUPTS(old);
+#endif
+
+    }
+}
+#endif
+
+#endif // __BASE
+
+#endif // CYGSEM_HAL_VIRTUAL_VECTOR_DIAG
+
+/*---------------------------------------------------------------------------*/
diff -urN -x CVS dummy/packages/hal/arm/mx31/3stack/current/src/board_misc.c ecos_mx31/packages/hal/arm/mx31/3stack/current/src/board_misc.c
--- dummy/packages/hal/arm/mx31/3stack/current/src/board_misc.c	1969-12-31 18:00:00.000000000 -0600
+++ ecos_mx31/packages/hal/arm/mx31/3stack/current/src/board_misc.c	2008-04-02 14:36:04.000000000 -0500
@@ -0,0 +1,160 @@
+//==========================================================================
+//
+//      board_misc.c
+//
+//      HAL misc board support code for the board
+//
+//==========================================================================
+//####ECOSGPLCOPYRIGHTBEGIN####
+// -------------------------------------------
+// This file is part of eCos, the Embedded Configurable Operating System.
+// Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+//
+// eCos is free software; you can redistribute it and/or modify it under
+// the terms of the GNU General Public License as published by the Free
+// Software Foundation; either version 2 or (at your option) any later version.
+//
+// eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with eCos; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+//
+// As a special exception, if other files instantiate templates or use macros
+// or inline functions from this file, or you compile this file and link it
+// with other works to produce a work based on this file, this file does not
+// by itself cause the resulting work to be covered by the GNU General Public
+// License. However the source code for this file must still be made available
+// in accordance with section (3) of the GNU General Public License.
+//
+// This exception does not invalidate any other reasons why a work based on
+// this file might be covered by the GNU General Public License.
+//
+// Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+// at http://sources.redhat.com/ecos/ecos-license/
+// -------------------------------------------
+//####ECOSGPLCOPYRIGHTEND####
+//========================================================================*/
+
+#include <pkgconf/hal.h>
+#include <pkgconf/system.h>
+#include <redboot.h>
+#include CYGBLD_HAL_PLATFORM_H
+
+#include <cyg/infra/cyg_type.h>         // base types
+#include <cyg/infra/cyg_trac.h>         // tracing macros
+#include <cyg/infra/cyg_ass.h>          // assertion macros
+
+#include <cyg/hal/hal_io.h>             // IO macros
+#include <cyg/hal/hal_arch.h>           // Register state info
+#include <cyg/hal/hal_diag.h>
+#include <cyg/hal/hal_intr.h>           // Interrupt names
+#include <cyg/hal/hal_cache.h>
+#include <cyg/hal/hal_soc.h>            // Hardware definitions
+#include <cyg/hal/fsl_board.h>          // Platform specifics
+
+#include <cyg/infra/diag.h>             // diag_printf
+
+// All the MM table layout is here:
+#include <cyg/hal/hal_mm.h>
+
+externC void* memset(void *, int, size_t);
+
+void hal_mmu_init(void)
+{
+    unsigned long ttb_base = RAM_BANK0_BASE + 0x4000;
+    unsigned long i;
+
+    /*
+     * Set the TTB register
+     */
+    asm volatile ("mcr  p15,0,%0,c2,c0,0" : : "r"(ttb_base) /*:*/);
+
+    /*
+     * Set the Domain Access Control Register
+     */
+    i = ARM_ACCESS_DACR_DEFAULT;
+    asm volatile ("mcr  p15,0,%0,c3,c0,0" : : "r"(i) /*:*/);
+
+    /*
+     * First clear all TT entries - ie Set them to Faulting
+     */
+    memset((void *)ttb_base, 0, ARM_FIRST_LEVEL_PAGE_TABLE_SIZE);
+
+    /*              Actual   Virtual  Size   Attributes                                                    Function  */
+    /*              Base     Base     MB     cached?           buffered?        access permissions                 */
+    /*              xxx00000 xxx00000                                                                                */
+    X_ARM_MMU_SECTION(0x000, 0xF00,   0x1,   ARM_UNCACHEABLE, ARM_UNBUFFERABLE, ARM_ACCESS_PERM_RW_RW); /* ROM */
+    X_ARM_MMU_SECTION(0x300, 0x300,   0x1,   ARM_UNCACHEABLE, ARM_UNBUFFERABLE, ARM_ACCESS_PERM_RW_RW); /* L2CC */
+    X_ARM_MMU_SECTION(0x43F, 0x43F,   0x3C1, ARM_UNCACHEABLE, ARM_UNBUFFERABLE, ARM_ACCESS_PERM_RW_RW); /* Internal Regsisters upto SDRAM*/
+    X_ARM_MMU_SECTION(0x800, 0x000,   0x80,  ARM_CACHEABLE,   ARM_BUFFERABLE,   ARM_ACCESS_PERM_RW_RW); /* SDRAM */
+    X_ARM_MMU_SECTION(0x800, 0x800,   0x80,  ARM_CACHEABLE,   ARM_BUFFERABLE,   ARM_ACCESS_PERM_RW_RW); /* SDRAM */
+    X_ARM_MMU_SECTION(0xA00, 0xA00,   0x20,  ARM_CACHEABLE,   ARM_BUFFERABLE,   ARM_ACCESS_PERM_RW_RW); /* Flash */
+    X_ARM_MMU_SECTION(0xB40, 0xB40,   0x10,  ARM_UNCACHEABLE, ARM_UNBUFFERABLE, ARM_ACCESS_PERM_RW_RW); /* External I/O */
+    X_ARM_MMU_SECTION(0xB50, 0xB50,   0x8,   ARM_CACHEABLE,   ARM_BUFFERABLE,   ARM_ACCESS_PERM_RW_RW); /* PSRAM */
+    X_ARM_MMU_SECTION(0xB60, 0xB60,   0x10,  ARM_UNCACHEABLE, ARM_UNBUFFERABLE, ARM_ACCESS_PERM_RW_RW); /* External I/O */
+    X_ARM_MMU_SECTION(0xB80, 0xB80,   0x10,  ARM_UNCACHEABLE, ARM_UNBUFFERABLE, ARM_ACCESS_PERM_RW_RW); /* EIM control*/
+}
+
+//
+// Platform specific initialization
+//
+
+unsigned int g_clock_src;
+extern int g_board_type;
+
+void plf_hardware_init(void)
+{
+    unsigned long val = readl(CCM_BASE_ADDR + CLKCTL_CCMR);
+
+    if ((val & 0x6) == 0x4) {
+        g_clock_src = FREQ_26MHZ;
+    } else if ((val & 0x6) == 0x2) {
+        g_clock_src = FREQ_32768HZ;
+    }
+
+    /* Reset interrupt status reg */
+    writew(0x1F, PBC_INT_REST);
+    writew(0x00, PBC_INT_REST);
+    writew(0xFFFF, PBC_INT_MASK);
+    // UART1
+    writel(0x1210, IOMUXC_BASE_ADDR + 0x80);
+
+    g_board_type = BOARD_TYPE_3STACK;
+}
+
+#include CYGHWR_MEMORY_LAYOUT_H
+
+typedef void code_fun(void);
+
+void board_program_new_stack(void *func)
+{
+    register CYG_ADDRESS stack_ptr asm("sp");
+    register CYG_ADDRESS old_stack asm("r4");
+    register code_fun *new_func asm("r0");
+    old_stack = stack_ptr;
+    stack_ptr = CYGMEM_REGION_ram + CYGMEM_REGION_ram_SIZE - sizeof(CYG_ADDRESS);
+    new_func = (code_fun*)func;
+    new_func();
+    stack_ptr = old_stack;
+}
+
+static void display_clock_src(void)
+{
+    diag_printf("\n");
+    if (g_clock_src == FREQ_27MHZ) {
+        diag_printf("Clock input is 27 MHz");
+    } else if (g_clock_src == FREQ_26MHZ) {
+        diag_printf("Clock input is 26 MHz");
+    } else if (g_clock_src == FREQ_32768HZ) {
+        diag_printf("Clock input is 32KHz");
+    } else {
+        diag_printf("Unknown clock input source. Something is wrong!");
+    }
+}
+RedBoot_init(display_clock_src, RedBoot_INIT_LAST);
+
+// ------------------------------------------------------------------------
diff -urN -x CVS dummy/packages/hal/arm/mx31/3stack/current/src/redboot_cmds.c ecos_mx31/packages/hal/arm/mx31/3stack/current/src/redboot_cmds.c
--- dummy/packages/hal/arm/mx31/3stack/current/src/redboot_cmds.c	1969-12-31 18:00:00.000000000 -0600
+++ ecos_mx31/packages/hal/arm/mx31/3stack/current/src/redboot_cmds.c	2008-04-01 11:25:30.000000000 -0500
@@ -0,0 +1,193 @@
+//==========================================================================
+//
+//      redboot_cmds.c
+//
+//      Board [platform] specific RedBoot commands
+//
+//==========================================================================
+//####ECOSGPLCOPYRIGHTBEGIN####
+// -------------------------------------------
+// This file is part of eCos, the Embedded Configurable Operating System.
+// Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+//
+// eCos is free software; you can redistribute it and/or modify it under
+// the terms of the GNU General Public License as published by the Free
+// Software Foundation; either version 2 or (at your option) any later version.
+//
+// eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with eCos; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+//
+// As a special exception, if other files instantiate templates or use macros
+// or inline functions from this file, or you compile this file and link it
+// with other works to produce a work based on this file, this file does not
+// by itself cause the resulting work to be covered by the GNU General Public
+// License. However the source code for this file must still be made available
+// in accordance with section (3) of the GNU General Public License.
+//
+// This exception does not invalidate any other reasons why a work based on
+// this file might be covered by the GNU General Public License.
+//
+// Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+// at http://sources.redhat.com/ecos/ecos-license/
+// -------------------------------------------
+//####ECOSGPLCOPYRIGHTEND####
+//==========================================================================
+#include <redboot.h>
+#include <cyg/hal/hal_intr.h>
+#include <cyg/hal/hal_cache.h>
+#include <cyg/hal/plf_mmap.h>
+#include <cyg/hal/fsl_board.h>          // Platform specific hardware definitions
+
+#ifdef CYGSEM_REDBOOT_FLASH_CONFIG
+#include <flash_config.h>
+
+#if (REDBOOT_IMAGE_SIZE != CYGBLD_REDBOOT_MIN_IMAGE_SIZE)
+#error REDBOOT_IMAGE_SIZE != CYGBLD_REDBOOT_MIN_IMAGE_SIZE
+#endif
+
+RedBoot_config_option("Board specifics",
+                      brd_specs,
+                      ALWAYS_ENABLED,
+                      true,
+                      CONFIG_INT,
+                      0
+                     );
+#endif  //CYGSEM_REDBOOT_FLASH_CONFIG
+
+char HAL_PLATFORM_EXTRA[60] = "MX31 3-Stack (Freescale i.MX31 based) PASS 1.0 [x32 DDR]";
+
+static void runImg(int argc, char *argv[]);
+
+RedBoot_cmd("run",
+            "Run an image at a location with MMU off",
+            "[<virtual addr>]",
+            runImg
+           );
+
+void launchRunImg(unsigned long addr)
+{
+    asm volatile ("mov r12, r0;");
+    HAL_CLEAN_INVALIDATE_L2();
+    HAL_DISABLE_L2();
+    HAL_MMU_OFF();
+    asm volatile (
+                 "mov r0, #0;"
+                 "mov r1, r12;"
+                 "mov r11, #0;"
+                 "mov r12, #0;"
+                 "mrs r10, cpsr;"
+                 "bic r10, r10, #0xF0000000;"
+                 "msr cpsr_f, r10;"
+                 "mov pc, r1"
+                 );
+}
+
+extern unsigned long entry_address;
+
+static void runImg(int argc,char *argv[])
+{
+    unsigned int virt_addr, phys_addr;
+
+    // Default physical entry point for Symbian
+    if (entry_address == 0xFFFFFFFF)
+        virt_addr = 0x800000;
+    else
+    virt_addr = entry_address;
+
+    if (!scan_opts(argc,argv,1,0,0,(void*)&virt_addr,
+                   OPTION_ARG_TYPE_NUM, "virtual address"))
+        return;
+
+    if (entry_address != 0xFFFFFFFF)
+        diag_printf("load entry_address=0x%lx\n", entry_address);
+    HAL_VIRT_TO_PHYS_ADDRESS(virt_addr, phys_addr);
+
+    diag_printf("virt_addr=0x%x\n",virt_addr);
+    diag_printf("phys_addr=0x%x\n",phys_addr);
+
+    launchRunImg(phys_addr);
+}
+
+#if defined(CYGSEM_REDBOOT_FLASH_CONFIG) && defined(CYG_HAL_STARTUP_ROMRAM)
+
+RedBoot_cmd("romupdate",
+            "Update Redboot with currently running image",
+            "",
+            romupdate
+           );
+
+extern int flash_program(void *_addr, void *_data, int len, void **err_addr);
+extern int flash_erase(void *addr, int len, void **err_addr);
+extern char *flash_errmsg(int err);
+extern unsigned char *ram_end; //ram end is where the redboot starts FIXME: use PC value
+
+#ifdef CYGPKG_IO_FLASH
+void romupdate(int argc, char *argv[])
+{
+    void *err_addr, *base_addr;
+    int stat;
+
+    base_addr = (void*)0;
+    diag_printf("Updating ROM in NAND flash\n");
+
+    // Erase area to be programmed
+    if ((stat = flash_erase((void *)base_addr,
+                            CYGBLD_REDBOOT_MIN_IMAGE_SIZE,
+                            (void **)&err_addr)) != 0) {
+        diag_printf("Can't erase region at %p: %s\n",
+                    err_addr, flash_errmsg(stat));
+        return;
+    }
+    // Now program it
+    if ((stat = flash_program((void *)base_addr, (void *)ram_end,
+                              CYGBLD_REDBOOT_MIN_IMAGE_SIZE,
+                              (void **)&err_addr)) != 0) {
+        diag_printf("Can't program region at %p: %s\n",
+                    err_addr, flash_errmsg(stat));
+    }
+}
+RedBoot_cmd("factive",
+            "Enable one flash media for Redboot",
+            "[NOR | NAND]",
+            factive
+           );
+
+void factive(int argc, char *argv[])
+{
+    unsigned long phys_addr;
+
+    if (argc != 2) {
+        diag_printf("Invalid factive cmd\n");
+        return;
+    }
+
+    if (strcasecmp(argv[1], "NOR") == 0) {
+#ifndef MXCFLASH_SELECT_NOR
+        diag_printf("Not supported\n");
+        return;
+#else
+        MXC_ASSERT_NOR_BOOT();
+#endif
+    } else if (strcasecmp(argv[1], "NAND") == 0) {
+#ifndef MXCFLASH_SELECT_NAND
+        diag_printf("Not supported\n");
+        return;
+#else
+        MXC_ASSERT_NAND_BOOT();
+#endif
+    } else {
+        diag_printf("Invalid command: %s\n", argv[1]);
+        return;
+    }
+    HAL_VIRT_TO_PHYS_ADDRESS(ram_end, phys_addr);
+
+    launchRunImg(phys_addr);
+}
+#endif //CYGPKG_IO_FLASH
+#endif /* CYG_HAL_STARTUP_ROMRAM */
diff -urN -x CVS dummy/packages/hal/arm/mx31/ads/current/cdl/hal_arm_board.cdl ecos_mx31/packages/hal/arm/mx31/ads/current/cdl/hal_arm_board.cdl
--- dummy/packages/hal/arm/mx31/ads/current/cdl/hal_arm_board.cdl	1969-12-31 18:00:00.000000000 -0600
+++ ecos_mx31/packages/hal/arm/mx31/ads/current/cdl/hal_arm_board.cdl	2007-05-04 11:13:59.000000000 -0500
@@ -0,0 +1,367 @@
+# ====================================================================
+#
+#      hal_arm_board.cdl
+#
+# ====================================================================
+#####ECOSGPLCOPYRIGHTBEGIN####
+## -------------------------------------------
+## This file is part of eCos, the Embedded Configurable Operating System.
+## Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+##
+## eCos is free software; you can redistribute it and/or modify it under
+## the terms of the GNU General Public License as published by the Free
+## Software Foundation; either version 2 or (at your option) any later version.
+##
+## eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+## WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+## for more details.
+##
+## You should have received a copy of the GNU General Public License along
+## with eCos; if not, write to the Free Software Foundation, Inc.,
+## 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+##
+## As a special exception, if other files instantiate templates or use macros
+## or inline functions from this file, or you compile this file and link it
+## with other works to produce a work based on this file, this file does not
+## by itself cause the resulting work to be covered by the GNU General Public
+## License. However the source code for this file must still be made available
+## in accordance with section (3) of the GNU General Public License.
+##
+## This exception does not invalidate any other reasons why a work based on
+## this file might be covered by the GNU General Public License.
+##
+## Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+## at http://sources.redhat.com/ecos/ecos-license/
+## -------------------------------------------
+#####ECOSGPLCOPYRIGHTEND####
+
+cdl_package CYGPKG_HAL_ARM_MX31ADS {
+    display       "Freescale board"
+    parent        CYGPKG_HAL_ARM_MX31
+    hardware
+    include_dir   cyg/hal
+    define_header hal_arm_board.h
+    description   "
+        This HAL platform package provides generic
+        support for the Freescale MXC Board."
+
+    compile       board_misc.c board_diag.c
+    implements    CYGINT_HAL_DEBUG_GDB_STUBS
+    implements    CYGINT_HAL_DEBUG_GDB_STUBS_BREAK
+    implements    CYGINT_HAL_VIRTUAL_VECTOR_SUPPORT
+
+    implements    CYGHWR_HAL_ARM_DUART_UARTA
+    implements    CYGHWR_HAL_ARM_SOC_UART1
+    #implements    CYGHWR_HAL_ARM_SOC_UART2
+    #implements    CYGHWR_HAL_ARM_SOC_UART3
+
+    define_proc {
+        puts $::cdl_system_header "#define CYGBLD_HAL_TARGET_H   <pkgconf/hal_arm.h>"
+        puts $::cdl_system_header "#define CYGBLD_HAL_VARIANT_H  <pkgconf/hal_arm_soc.h>"
+        puts $::cdl_system_header "#define CYGBLD_HAL_PLATFORM_H <pkgconf/hal_arm_board.h>"
+	puts $::cdl_header "#define HAL_PLATFORM_CPU    \"i.MX\""
+        puts $::cdl_header "#define HAL_PLATFORM_BOARD  \"Freescale\""
+        puts $::cdl_header "#define HAL_PLATFORM_MACHINE_TYPE  0x1BF"
+        puts $::cdl_header "#define HAL_ARCH_PROGRAM_NEW_STACK board_program_new_stack"
+    }
+
+    cdl_component CYG_HAL_STARTUP {
+        display       "Startup type"
+        flavor        data
+        default_value {"ROM"}
+        legal_values  {"RAM" "ROM" "ROMRAM"}
+	no_define
+	define -file system.h CYG_HAL_STARTUP
+        description   "
+           When targetting the eval board it is possible to build
+           the system for either RAM bootstrap or ROM bootstrap(s). Select
+           'ram' when building programs to load into RAM using eCos GDB
+           stubs.  Select 'rom' when building a stand-alone application
+           which will be put into ROM, or for the special case of
+           building the eCos GDB stubs themselves. Using ROMRAM will allow
+           the program to exist in ROM, but be copied to RAM during startup."
+    }
+
+    cdl_interface     CYGHWR_HAL_ARM_DUART_UARTA {
+        display   "ST16552 UARTA available as diagnostic/debug channel"
+        description "
+	  The board has a ST16552 DUART chip. This
+          interface allows a platform to indicate that the specified
+          serial port can be used as a diagnostic and/or debug channel."
+    }
+
+    cdl_interface     CYGHWR_HAL_ARM_DUART_UARTB {
+        display   "ST16552 UARTB available as diagnostic/debug channel"
+        description "
+	  The board has a ST16552 DUART chip. This
+          interface allows a platform to indicate that the specified
+          serial port can be used as a diagnostic and/or debug channel."
+    }
+
+    cdl_option CYGNUM_HAL_VIRTUAL_VECTOR_CONSOLE_CHANNEL_BAUD {
+        display       "Diagnostic serial port baud rate"
+        flavor        data
+        legal_values  9600 19200 38400 57600 115200
+        default_value 115200
+        description   "
+            This option selects the baud rate used for the console port.
+            Note: this should match the value chosen for the GDB port if the
+            console and GDB port are the same."
+    }
+
+    cdl_option CYGNUM_HAL_VIRTUAL_VECTOR_DEBUG_CHANNEL_BAUD {
+        display       "GDB serial port baud rate"
+        flavor        data
+        legal_values  9600 19200 38400 57600 115200
+        default_value 115200
+        description   "
+            This option selects the baud rate used for the GDB port.
+            Note: this should match the value chosen for the console port if the
+            console and GDB port are the same."
+    }
+
+    cdl_option CYGNUM_HAL_VIRTUAL_VECTOR_COMM_CHANNELS {
+        display      "Number of communication channels on the board"
+        flavor       data
+        calculated   6
+    }
+
+    cdl_option CYGNUM_HAL_VIRTUAL_VECTOR_DEBUG_CHANNEL {
+        display          "Debug serial port"
+        active_if        CYGPRI_HAL_VIRTUAL_VECTOR_DEBUG_CHANNEL_CONFIGURABLE
+        flavor data
+        legal_values     0 to CYGNUM_HAL_VIRTUAL_VECTOR_COMM_CHANNELS-1
+        default_value    0
+        description      "
+            The board has three serial ports. This option
+            chooses which port will be used to connect to a host
+            running GDB."
+     }
+
+     cdl_option CYGNUM_HAL_VIRTUAL_VECTOR_CONSOLE_CHANNEL_DEFAULT {
+         display      "Default console channel."
+         flavor       data
+         legal_values     0 to CYGNUM_HAL_VIRTUAL_VECTOR_COMM_CHANNELS-1
+         calculated   0
+     }
+
+     cdl_option CYGNUM_HAL_VIRTUAL_VECTOR_CONSOLE_CHANNEL {
+         display          "Console serial port"
+         active_if        CYGPRI_HAL_VIRTUAL_VECTOR_CONSOLE_CHANNEL_CONFIGURABLE
+         flavor data
+         legal_values     0 to CYGNUM_HAL_VIRTUAL_VECTOR_COMM_CHANNELS-1
+         default_value    CYGNUM_HAL_VIRTUAL_VECTOR_CONSOLE_CHANNEL_DEFAULT
+         description      "
+            The board has only three serial ports.  This option
+            chooses which port will be used for console output."
+     }
+
+    cdl_component CYGBLD_GLOBAL_OPTIONS {
+        display "Global build options"
+        flavor  none
+        no_define
+        description   "
+	    Global build options including control over
+	    compiler flags, linker flags and choice of toolchain."
+
+
+        parent  CYGPKG_NONE
+
+        cdl_option CYGBLD_GLOBAL_COMMAND_PREFIX {
+            display "Global command prefix"
+            flavor  data
+            no_define
+            default_value { "arm-elf" }
+            description "
+                This option specifies the command prefix used when
+                invoking the build tools."
+        }
+
+        cdl_option CYGBLD_GLOBAL_CFLAGS {
+            display "Global compiler flags"
+            flavor  data
+            no_define
+            default_value { "-mcpu=arm9 -Wall -Wpointer-arith -Wstrict-prototypes -Winline -Wundef -Woverloaded-virtual -g -O2 -ffunction-sections -fdata-sections -fno-rtti -fno-exceptions -fvtable-gc -finit-priority" }
+            description   "
+                This option controls the global compiler flags which are used to
+                compile all packages by default. Individual packages may define
+                options which override these global flags."
+        }
+
+        cdl_option CYGBLD_GLOBAL_LDFLAGS {
+            display "Global linker flags"
+            flavor  data
+            no_define
+            default_value { "-Wl,--gc-sections -Wl,-static -g -O2 -nostdlib" }
+            description   "
+                This option controls the global linker flags. Individual
+                packages may define options which override these global flags."
+        }
+
+        cdl_option CYGBLD_BUILD_GDB_STUBS {
+            display "Build GDB stub ROM image"
+            default_value 0
+            requires { CYG_HAL_STARTUP == "ROM" }
+            requires CYGSEM_HAL_ROM_MONITOR
+            requires CYGBLD_BUILD_COMMON_GDB_STUBS
+            requires CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS
+            requires CYGDBG_HAL_DEBUG_GDB_BREAK_SUPPORT
+            requires CYGDBG_HAL_DEBUG_GDB_THREAD_SUPPORT
+            requires ! CYGDBG_HAL_COMMON_INTERRUPTS_SAVE_MINIMUM_CONTEXT
+            requires ! CYGDBG_HAL_COMMON_CONTEXT_SAVE_MINIMUM
+            no_define
+            description "
+                This option enables the building of the GDB stubs for the
+                board. The common HAL controls takes care of most of the
+                build process, but the final conversion from ELF image to
+                binary data is handled by the platform CDL, allowing
+                relocation of the data if necessary."
+
+            make -priority 320 {
+                <PREFIX>/bin/gdb_module.bin : <PREFIX>/bin/gdb_module.img
+                $(OBJCOPY) --remove-section=.fixed_vectors -O binary $< $@
+            }
+        }
+    }
+
+    cdl_component CYGPKG_HAL_ARM_BOARD_OPTIONS {
+        display "Freescale MXC Board build options"
+        flavor  none
+        no_define
+        description   "
+	    Package specific build options including control over
+	    compiler flags used only in building this package,
+	    and details of which tests are built."
+
+        cdl_option CYGPKG_HAL_ARM_BOARD_CFLAGS_ADD {
+            display "Additional compiler flags"
+            flavor  data
+            no_define
+            default_value { "" }
+            description   "
+                This option modifies the set of compiler flags for
+                building the board HAL. These flags are used in addition
+                to the set of global flags."
+        }
+
+        cdl_option CYGPKG_HAL_ARM_BOARD_CFLAGS_REMOVE {
+            display "Suppressed compiler flags"
+            flavor  data
+            no_define
+            default_value { "" }
+            description   "
+                This option modifies the set of compiler flags for
+                building the board HAL. These flags are removed from
+                the set of global flags if present."
+        }
+
+    }
+
+    cdl_component CYGHWR_MEMORY_LAYOUT {
+        display "Memory layout"
+        flavor data
+        no_define
+        calculated { (CYG_HAL_STARTUP == "RAM")    ? "arm_board_ram" :
+                     (CYG_HAL_STARTUP == "ROMRAM") ? "arm_board_romram" :
+	                                             "arm_board_rom" }
+
+        cdl_option CYGHWR_MEMORY_LAYOUT_LDI {
+            display "Memory layout linker script fragment"
+            flavor data
+            no_define
+            define -file system.h CYGHWR_MEMORY_LAYOUT_LDI
+            calculated { (CYG_HAL_STARTUP == "RAM") ?    "<pkgconf/mlt_arm_board_ram.ldi>" :
+                         (CYG_HAL_STARTUP == "ROMRAM") ? "<pkgconf/mlt_arm_board_romram.ldi>" :
+                                                         "<pkgconf/mlt_arm_board_rom.ldi>" }
+        }
+
+        cdl_option CYGHWR_MEMORY_LAYOUT_H {
+            display "Memory layout header file"
+            flavor data
+            no_define
+            define -file system.h CYGHWR_MEMORY_LAYOUT_H
+            calculated { (CYG_HAL_STARTUP == "RAM")    ? "<pkgconf/mlt_arm_board_ram.h>" :
+                         (CYG_HAL_STARTUP == "ROMRAM") ? "<pkgconf/mlt_arm_board_romram.h>" :
+                                                         "<pkgconf/mlt_arm_board_rom.h>" }
+        }
+    }
+
+    cdl_option CYGSEM_HAL_ROM_MONITOR {
+        display       "Behave as a ROM monitor"
+        flavor        bool
+        default_value 0
+        parent        CYGPKG_HAL_ROM_MONITOR
+        requires      { CYG_HAL_STARTUP == "ROM" || CYG_HAL_STARTUP == "ROMRAM" }
+        description   "
+            Enable this option if this program is to be used as a ROM monitor,
+            i.e. applications will be loaded into RAM on the board, and this
+            ROM monitor may process exceptions or interrupts generated from the
+            application. This enables features such as utilizing a separate
+            interrupt stack when exceptions are generated."
+    }
+
+    cdl_option CYGSEM_HAL_USE_ROM_MONITOR {
+         display       "Work with a ROM monitor"
+         flavor        booldata
+         legal_values  { "Generic" "GDB_stubs" }
+         default_value { CYG_HAL_STARTUP == "RAM" ? "GDB_stubs" : 0 }
+         parent        CYGPKG_HAL_ROM_MONITOR
+         requires      { CYG_HAL_STARTUP == "RAM" }
+         description   "
+             Support can be enabled for different varieties of ROM monitor.
+             This support changes various eCos semantics such as the encoding
+             of diagnostic output, or the overriding of hardware interrupt
+             vectors.
+             Firstly there is \"Generic\" support which prevents the HAL
+             from overriding the hardware vectors that it does not use, to
+             instead allow an installed ROM monitor to handle them. This is
+             the most basic support which is likely to be common to most
+             implementations of ROM monitor.
+             \"GDB_stubs\" provides support when GDB stubs are included in
+             the ROM monitor or boot ROM."
+     }
+
+    cdl_component CYGPKG_REDBOOT_HAL_OPTIONS {
+        display       "Redboot HAL options"
+        flavor        none
+        no_define
+        parent        CYGPKG_REDBOOT
+        active_if     CYGPKG_REDBOOT
+        description   "
+            This option lists the target's requirements for a valid Redboot
+            configuration."
+
+            compile -library=libextras.a redboot_cmds.c
+
+        cdl_option CYGBLD_BUILD_REDBOOT_BIN {
+            display       "Build Redboot ROM binary image"
+            active_if     CYGBLD_BUILD_REDBOOT
+            default_value 1
+            no_define
+            description "This option enables the conversion of the Redboot ELF
+                         image to a binary image suitable for ROM programming."
+
+            make -priority 325 {
+                <PREFIX>/bin/redboot.bin : <PREFIX>/bin/redboot.elf
+                $(OBJCOPY) --strip-debug $< $(@:.bin=.img)
+                $(OBJCOPY) -O srec $< $(@:.bin=.srec)
+                $(OBJCOPY) -O binary $< $@
+            }
+        }
+    }
+
+    cdl_component CYGPKG_REDBOOT_HAL_BOARD_OPTIONS {
+        display       "Redboot HAL variant options"
+        flavor        none
+        no_define
+        parent        CYGPKG_REDBOOT
+        active_if     CYGPKG_REDBOOT
+
+        # RedBoot details
+        requires { CYGHWR_REDBOOT_ARM_LINUX_EXEC_ADDRESS_DEFAULT == 0x80008000 }
+        define_proc {
+            puts $::cdl_header "#define CYGHWR_REDBOOT_ARM_TRAMPOLINE_ADDRESS 0x00001f00"
+        }
+    }
+}
diff -urN -x CVS dummy/packages/hal/arm/mx31/ads/current/include/fsl_board.h ecos_mx31/packages/hal/arm/mx31/ads/current/include/fsl_board.h
--- dummy/packages/hal/arm/mx31/ads/current/include/fsl_board.h	1969-12-31 18:00:00.000000000 -0600
+++ ecos_mx31/packages/hal/arm/mx31/ads/current/include/fsl_board.h	2007-10-11 15:17:23.000000000 -0500
@@ -0,0 +1,105 @@
+#ifndef CYGONCE_FSL_BOARD_H
+#define CYGONCE_FSL_BOARD_H
+
+//=============================================================================
+//
+//      Platform specific support (register layout, etc)
+//
+//=============================================================================
+//####ECOSGPLCOPYRIGHTBEGIN####
+// -------------------------------------------
+// This file is part of eCos, the Embedded Configurable Operating System.
+// Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+//
+// eCos is free software; you can redistribute it and/or modify it under
+// the terms of the GNU General Public License as published by the Free
+// Software Foundation; either version 2 or (at your option) any later version.
+//
+// eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with eCos; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+//
+// As a special exception, if other files instantiate templates or use macros
+// or inline functions from this file, or you compile this file and link it
+// with other works to produce a work based on this file, this file does not
+// by itself cause the resulting work to be covered by the GNU General Public
+// License. However the source code for this file must still be made available
+// in accordance with section (3) of the GNU General Public License.
+//
+// This exception does not invalidate any other reasons why a work based on
+// this file might be covered by the GNU General Public License.
+//
+// Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+// at http://sources.redhat.com/ecos/ecos-license/
+// -------------------------------------------
+//####ECOSGPLCOPYRIGHTEND####
+//===========================================================================
+
+#include <cyg/hal/hal_soc.h>        // Hardware definitions
+
+#define PMIC_SPI_BASE            CSPI2_BASE_ADDR
+#define PMIC_SPI_CHIP_SELECT_NO  SPI_CTRL_CS0
+
+#define PBC_BASE                    CS4_BASE_ADDR    /* Peripheral Bus Controller */
+#define PBC_VERSION                 0x0
+#define PBC_BSTAT2                  0x2
+#define PBC_BCTRL1                  0x4
+#define PBC_BCTRL1_CLR              0x6
+#define PBC_BCTRL2                  0x8
+#define PBC_BCTRL2_CLR              0xA
+#define PBC_BCTRL3                  0xC
+#define PBC_BCTRL3_CLR              0xE
+#define PBC_BCTRL4                  0x10
+#define PBC_BCTRL4_CLR              0x12
+#define PBC_BSTAT1                  0x14
+#define BOARD_CS_LAN_BASE           (CS4_BASE_ADDR + 0x00020000 + 0x300)
+#define BOARD_CS_UART_BASE          (CS4_BASE_ADDR + 0x00010000)
+
+#define BOARD_FLASH_START	        CS0_BASE_ADDR
+#define REDBOOT_IMAGE_SIZE          0x40000
+
+/* MX31 ADS SDRAM is from 0x80000000, 128M */
+#define SDRAM_BASE_ADDR             CSD0_BASE_ADDR
+#define SDRAM_SIZE                  0x08000000
+#define RAM_BANK0_BASE              SDRAM_BASE_ADDR
+
+#define LED_MAX_NUM	2
+#define LED_IS_ON(n)    (readw(PBC_BASE+PBC_BCTRL1_CLR) & (1 << (n+6)))
+#define TURN_LED_ON(n)  writew((readw(PBC_BASE+PBC_BCTRL1_CLR) | (1 << (n+6))), PBC_BASE+PBC_BCTRL1)
+#define TURN_LED_OFF(n) writew((1<<(n+6)), PBC_BASE+PBC_BCTRL1_CLR)
+
+
+#define BOARD_DEBUG_LED(n) 			\
+    CYG_MACRO_START				\
+        if (n >= 0 && n < LED_MAX_NUM) { 	\
+		if (LED_IS_ON(n)) 		\
+			TURN_LED_OFF(n); 	\
+		else 				\
+			TURN_LED_ON(n);		\
+	}					\
+    CYG_MACRO_END
+
+#define BOARD_PBC_VERSION       ((*(volatile unsigned short*)(PBC_BASE + PBC_VERSION)) >> 8)
+
+#define DEBUG_SWITCH_1          (1 << 7)
+#define DEBUG_SWITCH_2          (1 << 6)
+#define DEBUG_SWITCH_3          (1 << 5)
+#define DEBUG_SWITCH_4          (1 << 4)
+#define DEBUG_SWITCH_5          (1 << 3)
+#define DEBUG_SWITCH_6          (1 << 2)
+#define DEBUG_SWITCH_7          (1 << 1)
+#define DEBUG_SWITCH_8          (1 << 0)
+#define CLK_INPUT_27MHZ_SET     DEBUG_SWITCH_4
+
+#define DEBUG_SWITCH_IS_ON(n)   (((*(volatile unsigned short*)(PBC_BASE + PBC_BSTAT2)) & n) == 0)
+#if 0
+    while (DEBUG_SWITCH_IS_ON(DEBUG_SWITCH_1)) {
+        hal_delay_us(100);
+    }
+#endif
+#endif /* CYGONCE_FSL_BOARD_H */
diff -urN -x CVS dummy/packages/hal/arm/mx31/ads/current/include/hal_platform_setup.h ecos_mx31/packages/hal/arm/mx31/ads/current/include/hal_platform_setup.h
--- dummy/packages/hal/arm/mx31/ads/current/include/hal_platform_setup.h	1969-12-31 18:00:00.000000000 -0600
+++ ecos_mx31/packages/hal/arm/mx31/ads/current/include/hal_platform_setup.h	2008-02-27 19:15:06.000000000 -0600
@@ -0,0 +1,874 @@
+#ifndef CYGONCE_HAL_PLATFORM_SETUP_H
+#define CYGONCE_HAL_PLATFORM_SETUP_H
+
+//=============================================================================
+//
+//      hal_platform_setup.h
+//
+//      Platform specific support for HAL (assembly code)
+//
+//=============================================================================
+//####ECOSGPLCOPYRIGHTBEGIN####
+// -------------------------------------------
+// This file is part of eCos, the Embedded Configurable Operating System.
+// Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+//
+// eCos is free software; you can redistribute it and/or modify it under
+// the terms of the GNU General Public License as published by the Free
+// Software Foundation; either version 2 or (at your option) any later version.
+//
+// eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with eCos; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+//
+// As a special exception, if other files instantiate templates or use macros
+// or inline functions from this file, or you compile this file and link it
+// with other works to produce a work based on this file, this file does not
+// by itself cause the resulting work to be covered by the GNU General Public
+// License. However the source code for this file must still be made available
+// in accordance with section (3) of the GNU General Public License.
+//
+// This exception does not invalidate any other reasons why a work based on
+// this file might be covered by the GNU General Public License.
+//
+// Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+// at http://sources.redhat.com/ecos/ecos-license/
+// -------------------------------------------
+//####ECOSGPLCOPYRIGHTEND####
+//===========================================================================
+
+#include <pkgconf/system.h>             // System-wide configuration info
+#include CYGBLD_HAL_VARIANT_H           // Variant specific configuration
+#include CYGBLD_HAL_PLATFORM_H          // Platform specific configuration
+#include <cyg/hal/hal_soc.h>            // Variant specific hardware definitions
+#include <cyg/hal/hal_mmu.h>            // MMU definitions
+#include <cyg/hal/fsl_board.h>          // Platform specific hardware definitions
+
+#if defined(CYG_HAL_STARTUP_ROM) || defined(CYG_HAL_STARTUP_ROMRAM)
+#define PLATFORM_SETUP1 _platform_setup1
+#define CYGHWR_HAL_ARM_HAS_MMU
+
+#ifdef CYG_HAL_STARTUP_ROMRAM
+#define CYGSEM_HAL_ROM_RESET_USES_JUMP
+#endif
+
+//#define ARM_399MHZ
+#define ARM_532MHZ
+
+#define SDRAM_FULL_PAGE_BIT     0x100
+#define SDRAM_FULL_PAGE_MODE    0x37
+#define SDRAM_BURST_MODE        0x33
+
+#define CYGHWR_HAL_ROM_VADDR    0x0
+
+#if 0
+#define UNALIGNED_ACCESS_ENABLE
+#define SET_T_BIT_DISABLE
+#define BRANCH_PREDICTION_ENABLE
+#endif
+
+//#define TURN_OFF_IMPRECISE_ABORT
+
+// This macro represents the initial startup code for the platform
+// r11 is reserved to contain chip rev info in this file
+    .macro  _platform_setup1
+FSL_BOARD_SETUP_START:
+/*
+ *       ARM1136 init
+ *       - invalidate I/D cache/TLB and drain write buffer;
+ *       - invalidate L2 cache
+ *       - unaligned access
+ *       - branch predictions
+ */
+#ifdef TURN_OFF_IMPRECISE_ABORT
+    mrs r0, cpsr
+    bic r0, r0, #0x100
+    msr cpsr, r0
+#endif
+
+    mov r0, #0
+    mcr 15, 0, r0, c7, c7, 0        /* invalidate I cache and D cache */
+    mcr 15, 0, r0, c8, c7, 0        /* invalidate TLBs */
+    mcr 15, 0, r0, c7, c10, 4       /* Drain the write buffer */
+
+    /* Also setup the Peripheral Port Remap register inside the core */
+    ldr r0, ARM_PPMRR        /* start from AIPS 2GB region */
+    mcr p15, 0, r0, c15, c2, 4
+
+    /* Reload data from spare area to 0x400 of main area if booting from NAND */
+    mov r0, #NFC_BASE
+    add r1, r0, #0x400
+    cmp pc, r0
+    blo 1f
+    cmp pc, r1
+    bhi 1f
+
+1:
+    /*** L2 Cache setup/invalidation/disable ***/
+    /* Disable L2 cache first */
+    mov r0, #L2CC_BASE_ADDR
+    ldr r2, [r0, #L2_CACHE_CTL_REG]
+    bic r2, r2, #0x1
+    str r2, [r0, #L2_CACHE_CTL_REG]
+    /*
+     * Configure L2 Cache:
+     * - 128k size(16k way)
+     * - 8-way associativity
+     * - 0 ws TAG/VALID/DIRTY
+     * - 4 ws DATA R/W
+     */
+    ldr r1, [r0, #L2_CACHE_AUX_CTL_REG]
+    and r1, r1, #0xFE000000
+    ldr r2, L2CACHE_PARAM
+    orr r1, r1, r2
+    str r1, [r0, #L2_CACHE_AUX_CTL_REG]
+
+    /* Invalidate L2 */
+    mov r1, #0x000000FF
+    str r1, [r0, #L2_CACHE_INV_WAY_REG]
+L2_loop:
+    /* Poll Invalidate By Way register */
+    ldr r2, [r0, #L2_CACHE_INV_WAY_REG]
+    cmp r2, #0
+    bne L2_loop
+    /*** End of L2 operations ***/
+
+    mov r0, #SDRAM_NON_FLASH_BOOT
+    ldr r1, AVIC_VECTOR0_ADDR_W
+    str r0, [r1] // for checking boot source from nand, nor or sdram
+/*
+ * End of ARM1136 init
+ */
+init_spba_start:
+    init_spba
+init_aips_start:
+    init_aips
+init_max_start:
+    init_max
+init_m3if_start:
+    init_m3if
+
+    ldr r11, =CHIP_REV_1_0
+    ldr r0, IIM_SREV_REG_VAL
+    ldr r1, [r0, #0x0]
+    cmp r1, #0x0
+    ldrne r11, =CHIP_REV_1_1
+    init_drive_strength
+init_cs0_async_start:
+//    init_cs0_async
+
+    /* If SDRAM has been setup, bypass clock/WEIM setup */
+    cmp pc, #SDRAM_BASE_ADDR
+    blo init_clock_start
+    cmp pc, #(SDRAM_BASE_ADDR + SDRAM_SIZE)
+    blo HWInitialise_skip_SDRAM_setup
+
+    mov r0, #NOR_FLASH_BOOT
+    ldr r1, AVIC_VECTOR0_ADDR_W
+    str r0, [r1]
+
+init_cs4_start:
+    init_cs4
+
+init_clock_start:
+    init_clock
+
+    /* Based on chip rev, setup params for SDRAM controller */
+    ldr r10, =0
+    mov r4, #SDRAM_BURST_MODE
+
+init_sdram_start:
+
+    /* Assuming DDR memory first */
+    setup_sdram ddr X32 DDR 0
+#if 0
+    beq HWInitialise_skip_SDRAM_setup
+    setup_sdram ddr X16 DDR 0
+    beq HWInitialise_skip_SDRAM_setup
+    setup_sdram sdr X32 SDR 0
+    beq HWInitialise_skip_SDRAM_setup
+    setup_sdram sdr X16 SDR 0
+    beq HWInitialise_skip_SDRAM_setup
+
+    /* Reach hear means memory setup problem. Try to 
+     * increase the HCLK divider */
+    ldr r0, CCM_BASE_ADDR_W
+    ldr r1, [r0, #CLKCTL_PDR0]
+    and r2, r1, #0x38
+    cmp r2, #0x38
+    beq loop_forever
+    add r1, r1, #0x8
+    str r1, [r0, #CLKCTL_PDR0]
+    b init_sdram_start
+
+loop_forever:
+    b loop_forever  /* shouldn't get here */
+#endif
+
+HWInitialise_skip_SDRAM_setup:
+
+    mov r0, #NFC_BASE
+    add r2, r0, #0x800      // 2K window
+    cmp pc, r0
+    blo Normal_Boot_Continue
+    cmp pc, r2
+    bhi Normal_Boot_Continue
+NAND_Boot_Start:
+    /* Copy image from flash to SDRAM first */
+    ldr r1, MXC_REDBOOT_ROM_START
+
+1:  ldmia r0!, {r3-r10}
+    stmia r1!, {r3-r10}
+    cmp r0, r2
+    blo 1b
+    /* Jump to SDRAM */
+    ldr r1, CONST_0x0FFF
+    and r0, pc, r1     /* offset of pc */
+    ldr r1, MXC_REDBOOT_ROM_START
+    add r1, r1, #0x10
+    add pc, r0, r1
+    nop
+    nop
+    nop
+    nop
+NAND_Copy_Main:
+    // Check if x16/2kb page
+    ldr r7, CCM_BASE_ADDR_W
+    ldr r7, [r7, #0xC]
+    ands r7, r7, #(1 << 30)
+
+    mov r0, #NAND_FLASH_BOOT
+    ldr r1, AVIC_VECTOR0_ADDR_W
+    str r0, [r1]
+    mov r0, #MXCFIS_NAND
+    ldr r1, AVIC_VECTOR1_ADDR_W
+    str r0, [r1]
+
+    mov r0, #NFC_BASE;   //r0: nfc base. Reloaded after each page copying
+    mov r1, #0x800       //r1: starting flash addr to be copied. Updated constantly
+    add r2, r0, #0x800   //r2: end of 3rd RAM buf. Doesn't change
+    addeq r2, r0, #0x200   //r2: end of 1st RAM buf. Doesn't change
+    add r12, r0, #0xE00  //r12: NFC register base. Doesn't change
+    ldr r11, MXC_REDBOOT_ROM_START
+    add r13, r11, #REDBOOT_IMAGE_SIZE //r13: end of SDRAM address for copying. Doesn't change
+    add r11, r11, r1     //r11: starting SDRAM address for copying. Updated constantly
+
+    //unlock internal buffer
+    mov r3, #0x2
+    strh r3, [r12, #0xA]
+
+Nfc_Read_Page:
+//  NFC_CMD_INPUT(FLASH_Read_Mode1);
+    mov r3, #0x0
+    nfc_cmd_input
+
+    // Check if x16/2kb page
+    ldr r7, CCM_BASE_ADDR_W
+    ldr r7, [r7, #0xC]
+    ands r7, r7, #(1 << 30)
+    bne nfc_addr_ops_2kb
+//    start_nfc_addr_ops(ADDRESS_INPUT_READ_PAGE, addr, nflash_dev_info->base_mask);
+    mov r3, r1
+    do_addr_input       //1st addr cycle
+    mov r3, r1, lsr #9
+    do_addr_input       //2nd addr cycle
+    mov r3, r1, lsr #17
+    do_addr_input       //3rd addr cycle
+    mov r3, r1, lsr #25
+    do_addr_input       //4th addr cycle
+    b end_of_nfc_addr_ops
+
+nfc_addr_ops_2kb:
+//    start_nfc_addr_ops(ADDRESS_INPUT_READ_PAGE, addr, nflash_dev_info->base_mask);
+    mov r3, #0
+    do_addr_input       //1st addr cycle
+    mov r3, #0
+    do_addr_input       //2nd addr cycle
+    mov r3, r1, lsr #11
+    do_addr_input       //3rd addr cycle
+    mov r3, r1, lsr #19
+    do_addr_input       //4th addr cycle
+
+//    NFC_CMD_INPUT(FLASH_Read_Mode1_2K);
+    mov r3, #0x30
+    nfc_cmd_input
+
+end_of_nfc_addr_ops:
+//    NFC_DATA_OUTPUT(buf, FDO_PAGE_SPARE_VAL);
+//        writew(NAND_FLASH_CONFIG1_INT_MSK | NAND_FLASH_CONFIG1_ECC_EN,
+//               NAND_FLASH_CONFIG1_REG);
+    mov r8, #0
+    bl nfc_data_output
+    bl do_wait_op_done
+    // Check if x16/2kb page
+    ldr r7, CCM_BASE_ADDR_W
+    ldr r7, [r7, #0xC]
+    ands r7, r7, #(1 << 30)
+    beq nfc_addr_data_output_done_512
+
+// For 2K page - 2nd 512
+    mov r8, #1
+    bl nfc_data_output
+    bl do_wait_op_done
+
+// 3rd 512
+    mov r8, #2
+    bl nfc_data_output
+    bl do_wait_op_done
+
+// 4th 512
+    mov r8, #3
+    bl nfc_data_output
+    bl do_wait_op_done
+// end of 4th
+    // check for bad block
+    mov r3, r1, lsl #(32-17)    // get rid of block number
+    cmp r3, #(0x800 << (32-17)) // check if not page 0 or 1
+    b nfc_addr_data_output_done
+
+nfc_addr_data_output_done_512:
+    // check for bad block
+    mov r3, r1, lsl #(32-5-9)    // get rid of block number
+    cmp r3, #(512 << (32-5-9))   // check if not page 0 or 1
+
+nfc_addr_data_output_done:
+    bhi Copy_Good_Blk
+    add r4, r0, #0x800  //r3 -> spare area buf 0
+    ldrh r4, [r4, #0x4]
+    and r4, r4, #0xFF00
+    cmp r4, #0xFF00
+    beq Copy_Good_Blk
+    // really sucks. Bad block!!!!
+    cmp r3, #0x0
+    beq Skip_bad_block
+    // even suckier since we already read the first page!
+    // Check if x16/2kb page
+    ldr r7, CCM_BASE_ADDR_W
+    ldr r7, [r7, #0xC]
+    ands r7, r7, #(1 << 30)
+
+    subeq r11, r11, #512  //rewind 1 page for the sdram pointer
+    subeq r1, r1, #512    //rewind 1 page for the flash pointer
+
+    // for 2k page
+    subne r11, r11, #0x800  //rewind 1 page for the sdram pointer
+    subne r1, r1, #0x800    //rewind 1 page for the flash pointer
+
+Skip_bad_block:
+    // Check if x16/2kb page
+    ldr r7, CCM_BASE_ADDR_W
+    ldr r7, [r7, #0xC]
+    ands r7, r7, #(1 << 30)
+
+    addeq r1, r1, #(32*512)
+    addne r1, r1, #(64*2048)
+
+    b Nfc_Read_Page
+Copy_Good_Blk:
+    //copying page
+1:  ldmia r0!, {r3-r10}
+    stmia r11!, {r3-r10}
+    cmp r0, r2
+    blo 1b
+    cmp r11, r13
+    bge NAND_Copy_Main_done
+    // Check if x16/2kb page
+    ldr r7, CCM_BASE_ADDR_W
+    ldr r7, [r7, #0xC]
+    ands r7, r7, #(1 << 30)
+    addeq r1, r1, #0x200
+    addne r1, r1, #0x800
+    mov r0, #NFC_BASE
+    b Nfc_Read_Page
+
+NAND_Copy_Main_done:
+
+Normal_Boot_Continue:
+
+#ifdef CYG_HAL_STARTUP_ROMRAM     /* enable running from RAM */
+    /* Copy image from flash to SDRAM first */
+    ldr r0, =0xFFFFF000
+    and r0, r0, pc
+    ldr r1, MXC_REDBOOT_ROM_START
+    cmp r0, r1
+    beq HWInitialise_skip_SDRAM_copy
+
+    add r2, r0, #REDBOOT_IMAGE_SIZE
+
+1:  ldmia r0!, {r3-r10}
+    stmia r1!, {r3-r10}
+    cmp r0, r2
+    ble 1b
+    /* Jump to SDRAM */
+    ldr r1, =0xFFFF
+    and r0, pc, r1         /* offset of pc */
+    ldr r1, =(SDRAM_BASE_ADDR + SDRAM_SIZE - 0x100000 + 0x8)
+    add pc, r0, r1
+    nop
+    nop
+    nop
+    nop
+#endif /* CYG_HAL_STARTUP_ROMRAM */
+
+HWInitialise_skip_SDRAM_copy:
+    init_cs0_sync
+
+NAND_ClockSetup:
+
+/*
+ * Note:
+ *     IOMUX/PBC setup is done in C function plf_hardware_init() for simplicity
+ */
+
+STACK_Setup:
+    // Set up a stack [for calling C code]
+    ldr r1, =__startup_stack
+    ldr r2, =RAM_BANK0_BASE
+    orr sp, r1, r2
+
+    // Create MMU tables
+    bl hal_mmu_init
+
+    // Enable MMU
+    ldr r2, =10f
+    mrc MMU_CP, 0, r1, MMU_Control, c0      // get c1 value to r1 first
+    orr r1, r1, #7                          // enable MMU bit
+    mcr MMU_CP, 0, r1, MMU_Control, c0
+    mov pc,r2    /* Change address spaces */
+    nop
+    nop
+    nop
+10:
+
+    // Save shadow copy of BCR, also hardware configuration
+    ldr r1, =_board_BCR
+    str r2, [r1]
+    ldr r1, =_board_CFG
+    str r9, [r1]                // Saved far above...
+
+    .endm                       // _platform_setup1
+
+do_wait_op_done:
+    1:
+        ldrh r3, [r12, #NAND_FLASH_CONFIG2_REG_OFF]
+        ands r3, r3, #NAND_FLASH_CONFIG2_INT_DONE
+        beq 1b
+    bx lr     // do_wait_op_done
+
+nfc_data_output:
+    mov r3, #(NAND_FLASH_CONFIG1_INT_MSK | NAND_FLASH_CONFIG1_ECC_EN)
+    strh r3, [r12, #NAND_FLASH_CONFIG1_REG_OFF]
+
+    // writew(buf_no, RAM_BUFFER_ADDRESS_REG);
+    strh r8, [r12, #RAM_BUFFER_ADDRESS_REG_OFF]
+    // writew(FDO_PAGE_SPARE_VAL & 0xFF, NAND_FLASH_CONFIG2_REG);
+    mov r3, #FDO_PAGE_SPARE_VAL
+    strh r3, [r12, #NAND_FLASH_CONFIG2_REG_OFF]
+    bx lr
+
+#else // defined(CYG_HAL_STARTUP_ROM) || defined(CYG_HAL_STARTUP_ROMRAM)
+#define PLATFORM_SETUP1
+#endif
+
+    /* Do nothing */
+    .macro  init_spba
+    .endm  /* init_spba */
+
+    /* AIPS setup - Only setup MPROTx registers. The PACR default values are good.*/
+    .macro init_aips
+        /*
+         * Set all MPROTx to be non-bufferable, trusted for R/W,
+         * not forced to user-mode.
+         */
+        ldr r0, AIPS1_CTRL_BASE_ADDR_W
+        ldr r1, AIPS1_PARAM_W
+        str r1, [r0, #0x00]
+        str r1, [r0, #0x04]
+        ldr r0, AIPS2_CTRL_BASE_ADDR_W
+        str r1, [r0, #0x00]
+        str r1, [r0, #0x04]
+
+        /*
+         * Clear the on and off peripheral modules Supervisor Protect bit
+         * for SDMA to access them. Did not change the AIPS control registers
+         * (offset 0x20) access type
+         */
+        ldr r0, AIPS1_CTRL_BASE_ADDR_W
+        ldr r1, =0x0
+        str r1, [r0, #0x40]
+        str r1, [r0, #0x44]
+        str r1, [r0, #0x48]
+        str r1, [r0, #0x4C]
+        ldr r1, [r0, #0x50]
+        and r1, r1, #0x00FFFFFF
+        str r1, [r0, #0x50]
+
+        ldr r0, AIPS2_CTRL_BASE_ADDR_W
+        ldr r1, =0x0
+        str r1, [r0, #0x40]
+        str r1, [r0, #0x44]
+        str r1, [r0, #0x48]
+        str r1, [r0, #0x4C]
+        ldr r1, [r0, #0x50]
+        and r1, r1, #0x00FFFFFF
+        str r1, [r0, #0x50]
+    .endm /* init_aips */
+
+    /* MAX (Multi-Layer AHB Crossbar Switch) setup */
+    .macro init_max
+        ldr r0, MAX_BASE_ADDR_W
+        /* MPR - priority is M4 > M2 > M3 > M5 > M0 > M1 */
+        ldr r1, MAX_PARAM1
+        str r1, [r0, #0x000]        /* for S0 */
+        str r1, [r0, #0x100]        /* for S1 */
+        str r1, [r0, #0x200]        /* for S2 */
+        str r1, [r0, #0x300]        /* for S3 */
+        str r1, [r0, #0x400]        /* for S4 */
+        /* SGPCR - always park on last master */
+        ldr r1, =0x10
+        str r1, [r0, #0x010]        /* for S0 */
+        str r1, [r0, #0x110]        /* for S1 */
+        str r1, [r0, #0x210]        /* for S2 */
+        str r1, [r0, #0x310]        /* for S3 */
+        str r1, [r0, #0x410]        /* for S4 */
+        /* MGPCR - restore default values */
+        ldr r1, =0x0
+        str r1, [r0, #0x800]        /* for M0 */
+        str r1, [r0, #0x900]        /* for M1 */
+        str r1, [r0, #0xA00]        /* for M2 */
+        str r1, [r0, #0xB00]        /* for M3 */
+        str r1, [r0, #0xC00]        /* for M4 */
+        str r1, [r0, #0xD00]        /* for M5 */
+    .endm /* init_max */
+
+    /* Clock setup */
+    .macro    init_clock
+        ldr r0, IPU_CTRL_BASE_ADDR_W
+        ldr r1, =0x40
+        str r1, [r0]
+
+        ldr r0, CCM_BASE_ADDR_W
+        ldr r2, CCM_CCMR_0x074B0BF5
+        ldr r3, CCM_CCMR_0x074B0BFD
+        ldr r4, CCM_CCMR_0x074B0B7D
+
+        // Make sure to use CKIH
+        ldr r1, [r0, #CLKCTL_CCMR]
+        bic r1, r1, #0x8            // disable PLL first
+        str r1, [r0, #CLKCTL_CCMR]
+        str r2, [r0, #CLKCTL_CCMR]  // select CKIH (26MHz) as PLL ref clock
+        ldr r1, =0x1000
+    1:
+        subs r1, r1, #0x1
+        bne 1b
+        str r3, [r0, #CLKCTL_CCMR]  // enable PLL
+        str r4, [r0, #CLKCTL_CCMR]  // switch to PLL (SPLL for FIR)
+
+        mov r1, #PBC_BASE
+        ldrh r1, [r1, #PBC_BSTAT2]
+        ands r1, r1, #CLK_INPUT_27MHZ_SET
+
+        // 532-133-66.5
+        ldr r1, CCM_PDR0_W
+        str r1, [r0, #CLKCTL_PDR0]
+        ldr r1, MPCTL_PARAM_W
+        ldrne r1, MPCTL_PARAM_532_27_W
+        str r1, [r0, #CLKCTL_MPCTL]
+
+        /* Set UPLL=240MHz, USB=60MHz */
+        ldr r1, CCM_PDR1_0x49FCFE7F
+        str r1, [r0, #CLKCTL_PDR1]
+        ldr r1, CCM_UPCTL_PARAM_240
+        ldrne r1, CCM_UPCTL_PARAM_240_27
+        str r1, [r0, #CLKCTL_UPCTL]
+        // default CLKO to 1/8 of the ARM core
+        mov r1, #0x000002C0
+        add r1, r1, #0x00000006
+        str r1, [r0, #CLKCTL_COSR]
+    .endm /* init_clock */
+
+    /* M3IF setup */
+    .macro init_m3if
+        /* Configure M3IF registers */
+        ldr r1, M3IF_BASE_W
+        /*
+        * M3IF Control Register (M3IFCTL)
+        * MRRP[0] = L2CC0 not on priority list (0 << 0)        = 0x00000000
+        * MRRP[1] = L2CC1 not on priority list (0 << 0)        = 0x00000000
+        * MRRP[2] = MBX not on priority list (0 << 0)        = 0x00000000
+        * MRRP[3] = MAX1 not on priority list (0 << 0)        = 0x00000000
+        * MRRP[4] = SDMA not on priority list (0 << 0)        = 0x00000000
+        * MRRP[5] = MPEG4 not on priority list (0 << 0)       = 0x00000000
+        * MRRP[6] = IPU1 on priority list (1 << 6)             = 0x00000040
+        * MRRP[7] = IPU2 not on priority list (0 << 0)   = 0x00000000
+        *                                                       ------------
+        *                                                       0x00000040
+        */
+        ldr r0, =0x00000040
+        str r0, [r1]  /* M3IF control reg */
+    .endm /* init_m3if */
+
+    /* CS0 sync mode setup */
+    .macro init_cs0_sync
+        /*
+         * Sync mode (AHB Clk = 133MHz ; BCLK = 44.3MHz):
+         */
+        /* Flash reset command */
+        ldr     r0, =CS0_BASE_ADDR
+        ldr     r1, =0xF0F0
+        strh    r1, [r0]
+        /* 1st command */
+        ldr     r2, =0xAAA
+        add     r2, r2, r0
+        ldr     r1, =0xAAAA
+        strh    r1, [r2]
+        /* 2nd command */
+        ldr     r2, =0x554
+        add     r2, r2, r0
+        ldr     r1, =0x5555
+        strh    r1, [r2]
+        /* 3rd command */
+        ldr     r2, =0xAAA
+        add     r2, r2, r0
+        ldr     r1, =0xD0D0
+        strh    r1, [r2]
+        /* Write flash config register */
+        ldr     r1, =0x56CA
+        strh    r1, [r2]
+        /* Flash reset command */
+        ldr     r1, =0xF0F0
+        strh    r1, [r0]
+
+        ldr r0, WEIM_CTRL_CS0_W
+        ldr r1, =0x23524E80
+        str r1, [r0, #CSCRU]
+        ldr r1, =0x10000D03
+        str r1, [r0, #CSCRL]
+        ldr r1, =0x00720900
+        str r1, [r0, #CSCRA]
+    .endm /* init_cs0_sync */
+
+    /* CS0 async mode setup */
+    .macro init_cs0_async
+        /* Async flash mode */
+        ldr r0, WEIM_CTRL_CS0_W
+        ldr r1, CS0_CSCRU_0x11414C80
+        str r1, [r0, #CSCRU]
+        ldr r1, CS0_CSCRL_0x30000D03
+        str r1, [r0, #CSCRL]
+        ldr r1, CS0_CSCRA_0x00310800
+        str r1, [r0, #CSCRA]
+    .endm /* init_cs0_async */
+
+    /* CPLD on CS4 setup */
+    .macro init_cs4
+        ldr r0, WEIM_CTRL_CS4_W
+        ldr r1, CS4_0x0000D843
+        str r1, [r0, #CSCRU]
+        ldr r1, CS4_0x22252521
+        str r1, [r0, #CSCRL]
+        ldr r1, CS4_0x22220A00
+        str r1, [r0, #CSCRA]
+    .endm /* init_cs4 */
+
+    .macro setup_sdram, name, bus_width, mode, full_page
+        /* It sets the "Z" flag in the CPSR at the end of the macro */
+        ldr r0, ESDCTL_BASE_W
+        mov r2, #SDRAM_BASE_ADDR
+        ldr r1, SDRAM_0x0075E73A
+        str r1, [r0, #0x4]
+        ldr r1, =0x2            // reset
+        str r1, [r0, #0x10]
+        ldr r1, SDRAM_PARAM1_\mode
+        str r1, [r0, #0x10]
+        // Hold for more than 200ns
+        ldr r1, =0x10000
+1:
+        subs r1, r1, #0x1
+        bne 1b
+
+        ldr r1, SDRAM_0x92100000
+        str r1, [r0]
+        ldr r1, =0x0
+        ldr r12, SDRAM_PARAM2_\mode
+        str r1, [r12]
+        ldr r1, SDRAM_0xA2100000
+        str r1, [r0]
+        ldr r1, =0x0
+        str r1, [r2]
+        ldr r1, SDRAM_0xB2100000
+        str r1, [r0]
+
+        ldr r1, =0x0
+        .if \full_page
+        strb r1, [r2, #SDRAM_FULL_PAGE_MODE]
+        .else
+        strb r1, [r2, #SDRAM_BURST_MODE]
+        .endif
+                
+        ldr r1, =0xFF
+        ldr r12, =0x81000000
+        strb r1, [r12]
+        ldr r3, SDRAM_0x82116080
+        ldr r4, SDRAM_PARAM3_\mode
+        add r3, r3, r4
+        ldr r4, SDRAM_PARAM4_\bus_width
+        add r3, r3, r4
+        .if \full_page
+        add r3, r3, #0x100   /* Force to full page mode */
+        .endif
+
+        str r3, [r0]
+        ldr r1, =0x0
+        str r1, [r2]
+        /* Below only for DDR */
+        ldr r1, [r0, #0x10]
+        ands r1, r1, #0x4
+        ldrne r1, =0x0000000C
+        strne r1, [r0, #0x10]
+        /* Testing if it is truly DDR */
+        ldr r1, SDRAM_0x55555555
+        ldr r0, =SDRAM_BASE_ADDR
+        str r1, [r0]
+        ldr r2, SDRAM_0xAAAAAAAA
+        str r2, [r0, #0x4]
+        ldr r2, [r0]
+        cmp r1, r2
+    .endm
+
+    .macro nfc_cmd_input
+        strh r3, [r12, #NAND_FLASH_CMD_REG_OFF]
+        mov r3, #NAND_FLASH_CONFIG2_FCMD_EN;
+        strh r3, [r12, #NAND_FLASH_CONFIG2_REG_OFF]
+        bl do_wait_op_done
+    .endm   // nfc_cmd_input
+
+    .macro do_addr_input
+        and r3, r3, #0xFF
+        strh r3, [r12, #NAND_FLASH_ADD_REG_OFF]
+        mov r3, #NAND_FLASH_CONFIG2_FADD_EN
+        strh r3, [r12, #NAND_FLASH_CONFIG2_REG_OFF]
+        bl do_wait_op_done
+    .endm   // do_addr_input
+
+    /* To support 133MHz DDR */
+    .macro  init_drive_strength
+        /*
+         * Disable maximum drive strength SDRAM/DDR lines by clearing DSE1 bits
+         * in SW_PAD_CTL registers
+         */
+
+        // SDCLK
+        ldr r1, IOMUXC_BASE_ADDR_W
+        add r1, r1, #0x200
+        // Now r1 = (IOMUX_BASE_ADDR + 0x200)
+        ldr r0, [r1, #0x6C]
+        bic r0, r0, #(1 << 12)
+        str r0, [r1, #0x6C]
+        
+        // CAS
+        ldr r0, [r1, #0x70]
+        bic r0, r0, #(1 << 22)
+        str r0, [r1, #0x70]
+        
+        // RAS
+        ldr r0, [r1, #0x74]
+        bic r0, r0, #(1 << 2)
+        str r0, [r1, #0x74]
+        
+        // CS2 (CSD0)
+        ldr r0, [r1, #0x7C]
+        bic r0, r0, #(1 << 22)
+        str r0, [r1, #0x7C]
+        
+        // DQM3
+        ldr r0, [r1, #0x84]
+        bic r0, r0, #(1 << 22)
+        str r0, [r1, #0x84]
+        
+        // DQM2, DQM1, DQM0, SD31-SD0, A25-A0, MA10 (0x288..0x2DC)
+        ldr r2, =22     // (0x2E0 - 0x288) / 4 = 22
+pad_loop:
+        ldr r0, [r1, #0x88]
+        bic r0, r0, #(1 << 22)
+        bic r0, r0, #(1 << 12)
+        bic r0, r0, #(1 << 2)
+        str r0, [r1, #0x88]
+        add r1, r1, #4
+        subs r2, r2, #0x1
+        bne pad_loop
+    .endm /* init_drive_strength */
+
+#define PLATFORM_VECTORS         _platform_vectors
+    .macro  _platform_vectors
+        .globl  _board_BCR, _board_CFG
+_board_BCR:   .long   0       // Board Control register shadow
+_board_CFG:   .long   0       // Board Configuration (read at RESET)
+    .endm
+
+ARM_PPMRR:              .word   0x40000015
+L2CACHE_PARAM:          .word   0x00030024
+IIM_SREV_REG_VAL:       .word   IIM_BASE_ADDR + IIM_SREV_OFF
+AIPS1_CTRL_BASE_ADDR_W: .word   AIPS1_CTRL_BASE_ADDR
+AIPS2_CTRL_BASE_ADDR_W: .word   AIPS2_CTRL_BASE_ADDR
+AIPS1_PARAM_W:          .word   0x77777777
+MAX_BASE_ADDR_W:        .word   MAX_BASE_ADDR
+MAX_PARAM1:             .word   0x00302154
+CLKCTL_BASE_ADDR_W:     .word   CLKCTL_BASE_ADDR
+ESDCTL_BASE_W:          .word   ESDCTL_BASE
+M3IF_BASE_W:            .word   M3IF_BASE
+SDRAM_PARAM1_DDR:	    .word	0x4
+SDRAM_PARAM1_SDR:	    .word	0x0
+SDRAM_PARAM2_DDR:	    .word	0x80000F00
+SDRAM_PARAM2_SDR:	    .word	0x80000400
+SDRAM_PARAM3_DDR:       .word   0x00100000
+SDRAM_PARAM3_SDR:       .word   0x0
+SDRAM_PARAM4_X32:       .word   0x00010000
+SDRAM_PARAM4_X16:       .word   0x0
+SDRAM_0x55555555:       .word   0x55555555
+SDRAM_0xAAAAAAAA:       .word   0xAAAAAAAA
+SDRAM_0x92100000:       .word   0x92100000
+SDRAM_0xA2100000:       .word   0xA2100000
+SDRAM_0xB2100000:       .word   0xB2100000
+SDRAM_0x82116080:       .word   0x82116080
+SDRAM_0x0075E73A:       .word   0x0075E73A
+WEIM_CTRL_CS0_W:        .word   WEIM_CTRL_CS0
+CS0_CSCRU_0x11414C80:   .word   0x11414C80
+CS0_CSCRL_0x30000D03:   .word   0x30000D03
+CS0_CSCRA_0x00310800:   .word   0x00310800
+IOMUXC_BASE_ADDR_W:     .word   IOMUXC_BASE_ADDR
+#ifdef ARM_399MHZ
+CCM_PDR0_W:             .word   PDR0_399_133_66
+MPCTL_PARAM_W:          .word   MPCTL_PARAM_399
+#endif
+#ifdef ARM_532MHZ
+CCM_PDR0_W:             .word   PDR0_532_133_66
+MPCTL_PARAM_W:          .word   MPCTL_PARAM_532
+#endif
+
+MPCTL_PARAM_532_27_W:   .word   MPCTL_PARAM_532_27
+CCM_PDR1_0x49FCFE7F:    .word   0x49FCFE7F
+CCM_UPCTL_PARAM_240:    .word   UPCTL_PARAM_240
+CCM_UPCTL_PARAM_240_27: .word   UPCTL_PARAM_240_27
+AVIC_VECTOR0_ADDR_W:    .word   MXCBOOT_FLAG_REG
+AVIC_VECTOR1_ADDR_W:    .word   MXCFIS_FLAG_REG
+MXC_REDBOOT_ROM_START:  .word   SDRAM_BASE_ADDR + SDRAM_SIZE - 0x100000
+CONST_0x0FFF:           .word   0x0FFF
+CCM_BASE_ADDR_W:        .word   CCM_BASE_ADDR
+IPU_CTRL_BASE_ADDR_W:   .word   IPU_CTRL_BASE_ADDR
+CCM_CCMR_0x074B0BF5:    .word   0x074B0BF5
+CCM_CCMR_0x074B0BFD:    .word   0x074B0BFD
+CCM_CCMR_0x074B0B7D:    .word   0x074B0B7D
+WEIM_CTRL_CS4_W:    .word   WEIM_CTRL_CS4
+CS4_0x0000D843:     .word   0x0000D843
+CS4_0x22252521:     .word   0x22252521
+CS4_0x22220A00:     .word   0x22220A00
+
+/*---------------------------------------------------------------------------*/
+/* end of hal_platform_setup.h                                               */
+#endif /* CYGONCE_HAL_PLATFORM_SETUP_H */
diff -urN -x CVS dummy/packages/hal/arm/mx31/ads/current/include/pkgconf/mlt_arm_board_romram.h ecos_mx31/packages/hal/arm/mx31/ads/current/include/pkgconf/mlt_arm_board_romram.h
--- dummy/packages/hal/arm/mx31/ads/current/include/pkgconf/mlt_arm_board_romram.h	1969-12-31 18:00:00.000000000 -0600
+++ ecos_mx31/packages/hal/arm/mx31/ads/current/include/pkgconf/mlt_arm_board_romram.h	2005-08-11 09:55:44.000000000 -0500
@@ -0,0 +1,20 @@
+// eCos memory layout - Fri Oct 20 05:56:55 2000
+
+// This is a generated file - do not edit
+
+#ifndef __ASSEMBLER__
+#include <cyg/infra/cyg_type.h>
+#include <stddef.h>
+
+#endif
+#define CYGMEM_REGION_ram (0x00000000)
+#define CYGMEM_REGION_ram_SIZE (0x7F00000)
+#define CYGMEM_REGION_ram_ATTR (CYGMEM_REGION_ATTR_R | CYGMEM_REGION_ATTR_W)
+#define CYGMEM_REGION_rom (0x87F00000)
+#define CYGMEM_REGION_rom_SIZE (0x100000)
+#define CYGMEM_REGION_rom_ATTR (CYGMEM_REGION_ATTR_R)
+#ifndef __ASSEMBLER__
+extern char CYG_LABEL_NAME (__heap1) [];
+#endif
+#define CYGMEM_SECTION_heap1 (CYG_LABEL_NAME (__heap1))
+#define CYGMEM_SECTION_heap1_SIZE (CYGMEM_REGION_ram_SIZE - (size_t) CYG_LABEL_NAME (__heap1))
diff -urN -x CVS dummy/packages/hal/arm/mx31/ads/current/include/pkgconf/mlt_arm_board_romram.ldi ecos_mx31/packages/hal/arm/mx31/ads/current/include/pkgconf/mlt_arm_board_romram.ldi
--- dummy/packages/hal/arm/mx31/ads/current/include/pkgconf/mlt_arm_board_romram.ldi	1969-12-31 18:00:00.000000000 -0600
+++ ecos_mx31/packages/hal/arm/mx31/ads/current/include/pkgconf/mlt_arm_board_romram.ldi	2005-08-11 09:55:44.000000000 -0500
@@ -0,0 +1,28 @@
+// eCos memory layout - Fri Oct 20 05:56:55 2000
+
+// This is a generated file - do not edit
+
+#include <cyg/infra/cyg_type.inc>
+
+MEMORY
+{
+    ram : ORIGIN = 0, LENGTH = 0x7F00000
+    rom : ORIGIN = 0x87F00000, LENGTH = 0x100000
+}
+
+SECTIONS
+{
+    SECTIONS_BEGIN
+    SECTION_rom_vectors (rom, 0x87F00000, LMA_EQ_VMA)
+    SECTION_text (rom, ALIGN (0x4), LMA_EQ_VMA)
+    SECTION_fini (rom, ALIGN (0x4), LMA_EQ_VMA)
+    SECTION_rodata (rom, ALIGN (0x4), LMA_EQ_VMA)
+    SECTION_rodata1 (rom, ALIGN (0x4), LMA_EQ_VMA)
+    SECTION_fixup (rom, ALIGN (0x4), LMA_EQ_VMA)
+    SECTION_gcc_except_table (rom, ALIGN (0x4), LMA_EQ_VMA)
+    SECTION_fixed_vectors (ram, 0x20, LMA_EQ_VMA)
+    SECTION_data (ram, 0x8000, FOLLOWING (.gcc_except_table))
+    SECTION_bss (ram, ALIGN (0x4), LMA_EQ_VMA)
+    CYG_LABEL_DEFN(__heap1) = ALIGN (0x8);
+    SECTIONS_END
+}
diff -urN -x CVS dummy/packages/hal/arm/mx31/ads/current/include/pkgconf/mlt_arm_board_romram.mlt ecos_mx31/packages/hal/arm/mx31/ads/current/include/pkgconf/mlt_arm_board_romram.mlt
--- dummy/packages/hal/arm/mx31/ads/current/include/pkgconf/mlt_arm_board_romram.mlt	1969-12-31 18:00:00.000000000 -0600
+++ ecos_mx31/packages/hal/arm/mx31/ads/current/include/pkgconf/mlt_arm_board_romram.mlt	2005-08-11 09:55:44.000000000 -0500
@@ -0,0 +1,14 @@
+version 0
+region ram 0 7F00000 0 !
+region rom 87F00000 100000 1 !
+section fixed_vectors 0 1 0 1 1 0 1 0 20 20 !
+section data 0 1 1 1 1 1 0 0 8000 bss !
+section bss 0 4 0 1 0 1 0 1 heap1 heap1 !
+section heap1 0 8 0 0 0 0 0 0 !
+section rom_vectors 0 1 0 1 1 1 1 1 87F00000 87F00000 text text !
+section text 0 4 0 1 0 1 0 1 fini fini !
+section fini 0 4 0 1 0 1 0 1 rodata rodata !
+section rodata 0 4 0 1 0 1 0 1 rodata1 rodata1 !
+section rodata1 0 4 0 1 0 1 0 1 fixup fixup !
+section fixup 0 4 0 1 0 1 0 1 gcc_except_table gcc_except_table !
+section gcc_except_table 0 4 0 1 0 0 0 1 data !
diff -urN -x CVS dummy/packages/hal/arm/mx31/ads/current/include/plf_io.h ecos_mx31/packages/hal/arm/mx31/ads/current/include/plf_io.h
--- dummy/packages/hal/arm/mx31/ads/current/include/plf_io.h	1969-12-31 18:00:00.000000000 -0600
+++ ecos_mx31/packages/hal/arm/mx31/ads/current/include/plf_io.h	2007-05-09 12:33:05.000000000 -0500
@@ -0,0 +1,69 @@
+#ifndef CYGONCE_HAL_ARM_BOARD_PLF_IO_H
+#define CYGONCE_HAL_ARM_BOARD_PLF_IO_H
+
+//=============================================================================
+//
+//      plf_io.h
+//
+//      Platform specific support (register layout, etc)
+//
+//=============================================================================
+//####ECOSGPLCOPYRIGHTBEGIN####
+// -------------------------------------------
+// This file is part of eCos, the Embedded Configurable Operating System.
+// Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+//
+// eCos is free software; you can redistribute it and/or modify it under
+// the terms of the GNU General Public License as published by the Free
+// Software Foundation; either version 2 or (at your option) any later version.
+//
+// eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with eCos; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+//
+// As a special exception, if other files instantiate templates or use macros
+// or inline functions from this file, or you compile this file and link it
+// with other works to produce a work based on this file, this file does not
+// by itself cause the resulting work to be covered by the GNU General Public
+// License. However the source code for this file must still be made available
+// in accordance with section (3) of the GNU General Public License.
+//
+// This exception does not invalidate any other reasons why a work based on
+// this file might be covered by the GNU General Public License.
+//
+// Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+// at http://sources.redhat.com/ecos/ecos-license/
+// -------------------------------------------
+//####ECOSGPLCOPYRIGHTEND####
+//=============================================================================
+
+#include <cyg/hal/fsl_board.h>
+#include <cyg/hal/hal_soc.h>
+
+#define CYGHWR_REDBOOT_LINUX_ATAG_MEM(_p_)                                                           \
+    CYG_MACRO_START                                                                                  \
+    {                                                                                                \
+      extern unsigned int system_rev;                                                                \
+             /* Next ATAG_MEM. */                                                                    \
+         _p_->hdr.size = (sizeof(struct tag_mem32) + sizeof(struct tag_header))/sizeof(long);        \
+         _p_->hdr.tag = ATAG_MEM;                                                                    \
+         /* Round up so there's only one bit set in the memory size.                                 \
+         * Don't double it if it's already a power of two, though.                                   \
+         */                                                                                          \
+         _p_->u.mem.size  = 1<<hal_msbindex(CYGMEM_REGION_ram_SIZE);                                 \
+         if (_p_->u.mem.size < CYGMEM_REGION_ram_SIZE)                                               \
+                 _p_->u.mem.size <<= 1;                                                              \
+         _p_->u.mem.start = CYGARC_PHYSICAL_ADDRESS(CYGMEM_REGION_ram);                              \
+         _p_ = (struct tag *)((long *)_p_ + _p_->hdr.size);                                          \
+         _p_->hdr.size = ((sizeof(struct tag_revision)) + sizeof(struct tag_header))/sizeof(long);   \
+         _p_->hdr.tag = ATAG_REVISION;                                                               \
+         _p_->u.revision.rev = system_rev;                                                           \
+     }                                                                                               \
+    CYG_MACRO_END
+
+#endif // CYGONCE_HAL_ARM_BOARD_PLF_IO_H
diff -urN -x CVS dummy/packages/hal/arm/mx31/ads/current/include/plf_mmap.h ecos_mx31/packages/hal/arm/mx31/ads/current/include/plf_mmap.h
--- dummy/packages/hal/arm/mx31/ads/current/include/plf_mmap.h	1969-12-31 18:00:00.000000000 -0600
+++ ecos_mx31/packages/hal/arm/mx31/ads/current/include/plf_mmap.h	2006-02-09 15:23:01.000000000 -0600
@@ -0,0 +1,65 @@
+#ifndef CYGONCE_HAL_BOARD_PLATFORM_PLF_MMAP_H
+#define CYGONCE_HAL_BOARD_PLATFORM_PLF_MMAP_H
+//=============================================================================
+//
+//      plf_mmap.h
+//
+//      Platform specific memory map support
+//
+//=============================================================================
+//####ECOSGPLCOPYRIGHTBEGIN####
+// -------------------------------------------
+// This file is part of eCos, the Embedded Configurable Operating System.
+// Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+//
+// eCos is free software; you can redistribute it and/or modify it under
+// the terms of the GNU General Public License as published by the Free
+// Software Foundation; either version 2 or (at your option) any later version.
+//
+// eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with eCos; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+//
+// As a special exception, if other files instantiate templates or use macros
+// or inline functions from this file, or you compile this file and link it
+// with other works to produce a work based on this file, this file does not
+// by itself cause the resulting work to be covered by the GNU General Public
+// License. However the source code for this file must still be made available
+// in accordance with section (3) of the GNU General Public License.
+//
+// This exception does not invalidate any other reasons why a work based on
+// this file might be covered by the GNU General Public License.
+//
+// Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+// at http://sources.redhat.com/ecos/ecos-license/
+// -------------------------------------------
+//####ECOSGPLCOPYRIGHTEND####
+//===========================================================================
+
+#include <cyg/hal/hal_misc.h>
+
+// Get the pagesize for a particular virtual address:
+
+// This does not depend on the vaddr.
+#define HAL_MM_PAGESIZE(vaddr, pagesize) CYG_MACRO_START        \
+        (pagesize) = SZ_1M;                                         \
+CYG_MACRO_END
+
+// Get the physical address from a virtual address:
+
+#define HAL_VIRT_TO_PHYS_ADDRESS( vaddr, paddr ) CYG_MACRO_START           \
+        cyg_uint32 _v_ = (cyg_uint32)(vaddr);                                  \
+        if ( _v_ < 128 * SZ_1M )          /* SDRAM */                           \
+                _v_ += 0x800u * SZ_1M;                                             \
+        else                             /* Rest of it */                      \
+                /* no change */ ;                                                  \
+                (paddr) = _v_;                                                         \
+CYG_MACRO_END
+
+//---------------------------------------------------------------------------
+#endif // CYGONCE_HAL_BOARD_PLATFORM_PLF_MMAP_H
diff -urN -x CVS dummy/packages/hal/arm/mx31/ads/current/misc/redboot_ROMRAM.ecm ecos_mx31/packages/hal/arm/mx31/ads/current/misc/redboot_ROMRAM.ecm
--- dummy/packages/hal/arm/mx31/ads/current/misc/redboot_ROMRAM.ecm	1969-12-31 18:00:00.000000000 -0600
+++ ecos_mx31/packages/hal/arm/mx31/ads/current/misc/redboot_ROMRAM.ecm	2008-04-02 12:10:03.000000000 -0500
@@ -0,0 +1,126 @@
+cdl_savefile_version 1;
+cdl_savefile_command cdl_savefile_version {};
+cdl_savefile_command cdl_savefile_command {};
+cdl_savefile_command cdl_configuration { description hardware template package };
+cdl_savefile_command cdl_package { value_source user_value wizard_value inferred_value };
+cdl_savefile_command cdl_component { value_source user_value wizard_value inferred_value };
+cdl_savefile_command cdl_option { value_source user_value wizard_value inferred_value };
+cdl_savefile_command cdl_interface { value_source user_value wizard_value inferred_value };
+
+cdl_configuration eCos {
+    description "" ;
+    hardware    mx31ads ;
+    template    redboot ;
+    package -hardware CYGPKG_HAL_ARM current ;
+    package -hardware CYGPKG_HAL_ARM_MX31 current ;
+    package -hardware CYGPKG_HAL_ARM_MX31ADS current ;
+    package -hardware CYGPKG_IO_ETH_DRIVERS current ;
+    package -hardware CYGPKG_DEVS_ETH_ARM_MX31ADS current ;
+    package -hardware CYGPKG_DEVS_ETH_CL_CS8900A current ;
+    package -hardware CYGPKG_COMPRESS_ZLIB current ;
+    package -hardware CYGPKG_DEVS_FLASH_AMD_AM29XXXXX current ;
+    package -hardware CYGPKG_IO_FLASH current ;
+    package -hardware CYGPKG_DEVS_FLASH_ONMXC current ;
+    package -hardware CYGPKG_DEVS_FLASH_MX31ADS_SPANSION current ;
+    package -hardware CYGPKG_DEVS_MXC_SPI current ;
+    package -hardware CYGPKG_DEVS_MXC_I2C current ;
+    package -template CYGPKG_HAL current ;
+    package -template CYGPKG_INFRA current ;
+    package -template CYGPKG_REDBOOT current ;
+    package -template CYGPKG_ISOINFRA current ;
+    package -template CYGPKG_LIBC_STRING current ;
+    package -template CYGPKG_CRC current ;
+    package CYGPKG_MEMALLOC current ;
+};
+
+cdl_option CYGFUN_LIBC_STRING_BSD_FUNCS {
+    inferred_value 0
+};
+
+cdl_option CYGHWR_DEVS_FLASH_S29WS256N {
+    inferred_value 1
+};
+
+cdl_option CYGHWR_DEVS_FLASH_MXC_NOR {
+    inferred_value 1
+};
+
+cdl_option CYGHWR_DEVS_FSL_SPI_VER_0_4 {
+    inferred_value 1
+};
+
+cdl_option CYGHWR_DEVS_FLASH_MXC_NAND {
+    inferred_value 1
+};
+
+cdl_option CYGIMP_HAL_COMMON_INTERRUPTS_USE_INTERRUPT_STACK {
+    inferred_value 0
+};
+
+cdl_option CYGNUM_HAL_COMMON_INTERRUPTS_STACK_SIZE {
+    user_value 4096
+};
+
+cdl_option CYGDBG_HAL_COMMON_INTERRUPTS_SAVE_MINIMUM_CONTEXT {
+    user_value 0
+};
+
+cdl_option CYGDBG_REDBOOT_TICK_GRANULARITY {
+    user_value 50
+};
+
+cdl_option CYGDBG_HAL_COMMON_CONTEXT_SAVE_MINIMUM {
+    inferred_value 0
+};
+
+cdl_option CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS {
+    inferred_value 1
+};
+
+cdl_option CYGSEM_HAL_ROM_MONITOR {
+    inferred_value 1
+};
+
+cdl_component CYGBLD_BUILD_REDBOOT {
+    user_value 1
+};
+
+cdl_option CYGBLD_REDBOOT_MIN_IMAGE_SIZE {
+    inferred_value 0x00040000
+};
+
+cdl_option CYGHWR_REDBOOT_ARM_LINUX_EXEC_ADDRESS_DEFAULT {
+    inferred_value 0x80008000
+};
+
+cdl_option CYGBLD_ISO_STRTOK_R_HEADER {
+    inferred_value 1 <cyg/libc/string/string.h>
+};
+
+cdl_option CYGBLD_ISO_STRING_LOCALE_FUNCS_HEADER {
+    inferred_value 1 <cyg/libc/string/string.h>
+};
+
+cdl_option CYGBLD_ISO_STRING_BSD_FUNCS_HEADER {
+    inferred_value 1 <cyg/libc/string/bsdstring.h>
+};
+
+cdl_option CYGBLD_ISO_STRING_MEMFUNCS_HEADER {
+    inferred_value 1 <cyg/libc/string/string.h>
+};
+
+cdl_option CYGBLD_ISO_STRING_STRFUNCS_HEADER {
+    inferred_value 1 <cyg/libc/string/string.h>
+};
+
+cdl_component CYG_HAL_STARTUP {
+    user_value ROMRAM
+};
+
+cdl_component CYGPRI_REDBOOT_ZLIB_FLASH_FORCE {
+    inferred_value 1
+};
+
+cdl_option CYGDAT_REDBOOT_CUSTOM_VERSION {
+    user_value 1 "FSL 200814"
+};
diff -urN -x CVS dummy/packages/hal/arm/mx31/ads/current/src/board_diag.c ecos_mx31/packages/hal/arm/mx31/ads/current/src/board_diag.c
--- dummy/packages/hal/arm/mx31/ads/current/src/board_diag.c	1969-12-31 18:00:00.000000000 -0600
+++ ecos_mx31/packages/hal/arm/mx31/ads/current/src/board_diag.c	2006-02-09 23:09:46.000000000 -0600
@@ -0,0 +1,650 @@
+/*=============================================================================
+//
+//      board_diag.c
+//
+//      HAL diagnostic output code
+//
+//=============================================================================
+//####ECOSGPLCOPYRIGHTBEGIN####
+// -------------------------------------------
+// This file is part of eCos, the Embedded Configurable Operating System.
+// Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+//
+// eCos is free software; you can redistribute it and/or modify it under
+// the terms of the GNU General Public License as published by the Free
+// Software Foundation; either version 2 or (at your option) any later version.
+//
+// eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with eCos; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+//
+// As a special exception, if other files instantiate templates or use macros
+// or inline functions from this file, or you compile this file and link it
+// with other works to produce a work based on this file, this file does not
+// by itself cause the resulting work to be covered by the GNU General Public
+// License. However the source code for this file must still be made available
+// in accordance with section (3) of the GNU General Public License.
+//
+// This exception does not invalidate any other reasons why a work based on
+// this file might be covered by the GNU General Public License.
+//
+// Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+// at http://sources.redhat.com/ecos/ecos-license/
+// -------------------------------------------
+//####ECOSGPLCOPYRIGHTEND####
+//===========================================================================*/
+
+#include <pkgconf/hal.h>
+
+#include <cyg/infra/cyg_type.h>         // base types
+#include <cyg/infra/cyg_trac.h>         // tracing macros
+#include <cyg/infra/cyg_ass.h>          // assertion macros
+
+#include <cyg/hal/hal_arch.h>           // basic machine info
+#include <cyg/hal/hal_intr.h>           // interrupt macros
+#include <cyg/hal/hal_io.h>             // IO macros
+#include <cyg/hal/hal_diag.h>
+#include <cyg/hal/hal_if.h>             // Calling-if API
+#include <cyg/hal/drv_api.h>            // driver API
+#include <cyg/hal/hal_misc.h>           // Helper functions
+#include <cyg/hal/hal_soc.h>            // Hardware definitions
+#include <cyg/hal/fsl_board.h>          // Platform specifics
+
+static void cyg_hal_plf_duart_init(void);
+extern void cyg_hal_plf_serial_init(void);
+
+#define DUART_WORKAROUND_DELAY(a)   \
+do {                                \
+    if (BOARD_PBC_VERSION < 7)      \
+        hal_delay_us(a);            \
+} while (0)
+
+void cyg_hal_plf_comms_init(void)
+{
+    static int initialized = 0;
+
+    if (initialized)
+        return;
+
+    initialized = 1;
+
+    /* Setup GPIO and enable transceiver for UARTs */
+    cyg_hal_plf_duart_init();
+    cyg_hal_plf_serial_init();
+}
+
+//=============================================================================
+// ST16552 DUART driver
+//=============================================================================
+
+//-----------------------------------------------------------------------------
+// There are two serial ports.
+#define CYG_DEV_SERIAL_BASE_A    (BOARD_CS_UART_BASE + 0x0000) // port A
+#define CYG_DEV_SERIAL_BASE_B    (BOARD_CS_UART_BASE + 0x0010) // port B
+
+//-----------------------------------------------------------------------------
+// Based on 14.7456 MHz xtal
+#if CYGNUM_HAL_VIRTUAL_VECTOR_CONSOLE_CHANNEL_BAUD==9600
+#define CYG_DEV_SERIAL_BAUD_MSB        0x00
+#define CYG_DEV_SERIAL_BAUD_LSB        0x60
+#endif
+#if CYGNUM_HAL_VIRTUAL_VECTOR_CONSOLE_CHANNEL_BAUD==19200
+#define CYG_DEV_SERIAL_BAUD_MSB        0x00
+#define CYG_DEV_SERIAL_BAUD_LSB        0x30
+#endif
+#if CYGNUM_HAL_VIRTUAL_VECTOR_CONSOLE_CHANNEL_BAUD==38400
+#define CYG_DEV_SERIAL_BAUD_MSB        0x00
+#define CYG_DEV_SERIAL_BAUD_LSB        0x18
+#endif
+#if CYGNUM_HAL_VIRTUAL_VECTOR_CONSOLE_CHANNEL_BAUD==57600
+#define CYG_DEV_SERIAL_BAUD_MSB        0x00
+#define CYG_DEV_SERIAL_BAUD_LSB        0x10
+#endif
+#if CYGNUM_HAL_VIRTUAL_VECTOR_CONSOLE_CHANNEL_BAUD==115200
+#define CYG_DEV_SERIAL_BAUD_MSB        0x00
+#define CYG_DEV_SERIAL_BAUD_LSB        0x08
+#endif
+
+#ifndef CYG_DEV_SERIAL_BAUD_MSB
+#error Missing/incorrect serial baud rate defined - CDL error?
+#endif
+
+//-----------------------------------------------------------------------------
+// Define the serial registers. The board is equipped with a 16552
+// serial chip.
+
+#ifdef EXT_UART_x16
+#define HAL_WRITE_UINT_UART HAL_WRITE_UINT16
+#define HAL_READ_UINT_UART HAL_READ_UINT16
+typedef cyg_uint16 uart_width;
+#else  //_x8
+typedef cyg_uint8 uart_width;
+#define HAL_WRITE_UINT_UART HAL_WRITE_UINT8
+#define HAL_READ_UINT_UART HAL_READ_UINT8
+#endif
+
+#define CYG_DEV_SERIAL_RHR   0x00 // receiver buffer register, read, dlab = 0
+#define CYG_DEV_SERIAL_THR   0x00 // transmitter holding register, write, dlab = 0
+#define CYG_DEV_SERIAL_DLL   0x00 // divisor latch (LS), read/write, dlab = 1
+#define CYG_DEV_SERIAL_IER   0x01 // interrupt enable register, read/write, dlab = 0
+#define CYG_DEV_SERIAL_DLM   0x01 // divisor latch (MS), read/write, dlab = 1
+#define CYG_DEV_SERIAL_IIR   0x02 // interrupt identification register, read, dlab = 0
+#define CYG_DEV_SERIAL_FCR   0x02 // fifo control register, write, dlab = 0
+#define CYG_DEV_SERIAL_AFR   0x02 // alternate function register, read/write, dlab = 1
+#define CYG_DEV_SERIAL_LCR   0x03 // line control register, read/write
+#define CYG_DEV_SERIAL_MCR   0x04
+#define CYG_DEV_SERIAL_MCR_A 0x04
+#define CYG_DEV_SERIAL_MCR_B 0x04
+#define CYG_DEV_SERIAL_LSR   0x05 // line status register, read
+#define CYG_DEV_SERIAL_MSR   0x06 // modem status register, read
+#define CYG_DEV_SERIAL_SCR   0x07 // scratch pad register
+
+// The interrupt enable register bits.
+#define SIO_IER_ERDAI   0x01            // enable received data available irq
+#define SIO_IER_ETHREI  0x02            // enable THR empty interrupt
+#define SIO_IER_ELSI    0x04            // enable receiver line status irq
+#define SIO_IER_EMSI    0x08            // enable modem status interrupt
+
+// The interrupt identification register bits.
+#define SIO_IIR_IP      0x01            // 0 if interrupt pending
+#define SIO_IIR_ID_MASK 0x0e            // mask for interrupt ID bits
+#define ISR_Tx          0x02
+#define ISR_Rx          0x04
+
+// The line status register bits.
+#define SIO_LSR_DR      0x01            // data ready
+#define SIO_LSR_OE      0x02            // overrun error
+#define SIO_LSR_PE      0x04            // parity error
+#define SIO_LSR_FE      0x08            // framing error
+#define SIO_LSR_BI      0x10            // break interrupt
+#define SIO_LSR_THRE    0x20            // transmitter holding register empty
+#define SIO_LSR_TEMT    0x40            // transmitter register empty
+#define SIO_LSR_ERR     0x80            // any error condition
+
+// The modem status register bits.
+#define SIO_MSR_DCTS    0x01            // delta clear to send
+#define SIO_MSR_DDSR    0x02            // delta data set ready
+#define SIO_MSR_TERI    0x04            // trailing edge ring indicator
+#define SIO_MSR_DDCD    0x08            // delta data carrier detect
+#define SIO_MSR_CTS     0x10            // clear to send
+#define SIO_MSR_DSR     0x20            // data set ready
+#define SIO_MSR_RI      0x40            // ring indicator
+#define SIO_MSR_DCD     0x80            // data carrier detect
+
+// The line control register bits.
+#define SIO_LCR_WLS0   0x01             // word length select bit 0
+#define SIO_LCR_WLS1   0x02             // word length select bit 1
+#define SIO_LCR_STB    0x04             // number of stop bits
+#define SIO_LCR_PEN    0x08             // parity enable
+#define SIO_LCR_EPS    0x10             // even parity select
+#define SIO_LCR_SP     0x20             // stick parity
+#define SIO_LCR_SB     0x40             // set break
+#define SIO_LCR_DLAB   0x80             // divisor latch access bit
+
+// The FIFO control register
+#define SIO_FCR_FCR0   0x01             // enable xmit and rcvr fifos
+#define SIO_FCR_FCR1   0x02             // clear RCVR FIFO
+#define SIO_FCR_FCR2   0x04             // clear XMIT FIFO
+
+//-----------------------------------------------------------------------------
+
+typedef struct {
+    uart_width* base;
+    cyg_int32 msec_timeout;
+    int isr_vector;
+} channel_data_t;
+
+static channel_data_t channels[] = {
+#if CYGHWR_HAL_ARM_DUART_UARTA != 0
+    {(uart_width*)CYG_DEV_SERIAL_BASE_A, 1000, 0},
+#endif
+#if CYGHWR_HAL_ARM_DUART_UARTB != 0
+    {(uart_width*)CYG_DEV_SERIAL_BASE_B, 1000, 0}
+#endif
+};
+
+//-----------------------------------------------------------------------------
+
+static void init_duart_channel(channel_data_t* __ch_data)
+{
+    uart_width* base = __ch_data->base;
+    uart_width lcr;
+
+    // 8-1-no parity.
+    HAL_WRITE_UINT_UART(base+CYG_DEV_SERIAL_LCR,
+                        SIO_LCR_WLS0 | SIO_LCR_WLS1);
+    DUART_WORKAROUND_DELAY(50);
+    HAL_READ_UINT_UART(base+CYG_DEV_SERIAL_LCR, lcr);
+    lcr |= SIO_LCR_DLAB;
+    DUART_WORKAROUND_DELAY(50);
+    HAL_WRITE_UINT_UART(base+CYG_DEV_SERIAL_LCR, lcr);
+    DUART_WORKAROUND_DELAY(50);
+    HAL_WRITE_UINT_UART(base+CYG_DEV_SERIAL_DLL, CYG_DEV_SERIAL_BAUD_LSB);
+    DUART_WORKAROUND_DELAY(50);
+    HAL_WRITE_UINT_UART(base+CYG_DEV_SERIAL_DLM, CYG_DEV_SERIAL_BAUD_MSB);
+    lcr &= ~SIO_LCR_DLAB;
+    DUART_WORKAROUND_DELAY(50);
+    HAL_WRITE_UINT_UART(base+CYG_DEV_SERIAL_LCR, lcr);
+    DUART_WORKAROUND_DELAY(50);
+    HAL_WRITE_UINT_UART(base+CYG_DEV_SERIAL_FCR, 0x07);  // Enable & clear FIFO
+}
+
+//#define x_debug_uart_log_buf
+#ifdef x_debug_uart_log_buf
+#define x_DIAG_BUFSIZE 2048
+static char __x_log_buf[x_DIAG_BUFSIZE];
+static int x_diag_bp = 0;
+#endif
+
+void cyg_hal_plf_duart_putc(void* __ch_data, cyg_uint8 c)
+{
+    uart_width* base = ((channel_data_t*)__ch_data)->base;
+    uart_width lsr;
+
+#ifdef x_debug_uart_log_buf
+    __x_log_buf[x_diag_bp++] = c;
+#endif
+    CYGARC_HAL_SAVE_GP();
+
+    do {
+        HAL_READ_UINT_UART(base+CYG_DEV_SERIAL_LSR, lsr);
+    } while ((lsr & SIO_LSR_THRE) == 0);
+
+    DUART_WORKAROUND_DELAY(50);
+    HAL_WRITE_UINT_UART(base+CYG_DEV_SERIAL_THR, c);
+
+    // Hang around until the character has been safely sent.
+    do {
+        HAL_READ_UINT_UART(base+CYG_DEV_SERIAL_LSR, lsr);
+    } while ((lsr & SIO_LSR_THRE) == 0);
+
+    CYGARC_HAL_RESTORE_GP();
+}
+
+static cyg_bool cyg_hal_plf_duart_getc_nonblock(void* __ch_data, cyg_uint8* ch)
+{
+    uart_width* base = ((channel_data_t*)__ch_data)->base;
+    uart_width lsr, ch16;
+
+    HAL_READ_UINT_UART(base+CYG_DEV_SERIAL_LSR, lsr);
+    if ((lsr & SIO_LSR_DR) == 0)
+        return false;
+
+    HAL_READ_UINT_UART(base+CYG_DEV_SERIAL_RHR, ch16);
+
+    *ch = (cyg_uint8) (ch16 & 0x00FF);
+
+    return true;
+}
+
+cyg_uint8 cyg_hal_plf_duart_getc(void* __ch_data)
+{
+    cyg_uint8 ch;
+
+    CYGARC_HAL_SAVE_GP();
+
+    while (!cyg_hal_plf_duart_getc_nonblock(__ch_data, &ch));
+
+    CYGARC_HAL_RESTORE_GP();
+    return ch;
+}
+
+static void cyg_hal_plf_duart_write(void* __ch_data, const cyg_uint8* __buf,
+                                    cyg_uint32 __len)
+{
+    CYGARC_HAL_SAVE_GP();
+
+    while (__len-- > 0)
+        cyg_hal_plf_duart_putc(__ch_data, *__buf++);
+
+    CYGARC_HAL_RESTORE_GP();
+}
+
+static void cyg_hal_plf_duart_read(void* __ch_data, cyg_uint8* __buf, 
+                                   cyg_uint32 __len)
+{
+    CYGARC_HAL_SAVE_GP();
+
+    while (__len-- > 0)
+        *__buf++ = cyg_hal_plf_duart_getc(__ch_data);
+
+    CYGARC_HAL_RESTORE_GP();
+}
+
+cyg_bool cyg_hal_plf_duart_getc_timeout(void* __ch_data, cyg_uint8* ch)
+{
+    int delay_count;
+    channel_data_t* chan = (channel_data_t*)__ch_data;
+    cyg_bool res;
+
+    CYGARC_HAL_SAVE_GP();
+
+    delay_count = chan->msec_timeout * 10; // delay in .1 ms steps
+    for (;;) {
+        res = cyg_hal_plf_duart_getc_nonblock(__ch_data, ch);
+        if (res || 0 == delay_count--)
+            break;
+
+        CYGACC_CALL_IF_DELAY_US(100);
+    }
+
+    CYGARC_HAL_RESTORE_GP();
+    return res;
+}
+
+static int cyg_hal_plf_duart_control(void *__ch_data, 
+                                     __comm_control_cmd_t __func, ...)
+{
+    static int irq_state = 0;
+    channel_data_t* chan = (channel_data_t*)__ch_data;
+    uart_width ier;
+    int ret = 0;
+
+    CYGARC_HAL_SAVE_GP();
+
+    switch (__func) {
+    case __COMMCTL_IRQ_ENABLE:
+        HAL_INTERRUPT_UNMASK(chan->isr_vector);
+        HAL_INTERRUPT_SET_LEVEL(chan->isr_vector, 1);
+        HAL_READ_UINT_UART(chan->base+CYG_DEV_SERIAL_IER, ier);
+        ier |= SIO_IER_ERDAI;
+        HAL_WRITE_UINT_UART(chan->base+CYG_DEV_SERIAL_IER, ier);
+        irq_state = 1;
+        break;
+    case __COMMCTL_IRQ_DISABLE:
+        ret = irq_state;
+        irq_state = 0;
+        HAL_INTERRUPT_MASK(chan->isr_vector);
+        HAL_READ_UINT_UART(chan->base+CYG_DEV_SERIAL_IER, ier);
+        ier &= ~SIO_IER_ERDAI;
+        HAL_WRITE_UINT_UART(chan->base+CYG_DEV_SERIAL_IER, ier);
+        break;
+    case __COMMCTL_DBG_ISR_VECTOR:
+        ret = chan->isr_vector;
+        break;
+    case __COMMCTL_SET_TIMEOUT:
+        {
+            va_list ap;
+
+            va_start(ap, __func);
+
+            ret = chan->msec_timeout;
+            chan->msec_timeout = va_arg(ap, cyg_uint32);
+
+            va_end(ap);
+        }
+        break;
+    default:
+        break;
+    }
+    CYGARC_HAL_RESTORE_GP();
+    return ret;
+}
+
+static int cyg_hal_plf_duart_isr(void *__ch_data, int* __ctrlc,
+                                 CYG_ADDRWORD __vector, CYG_ADDRWORD __data)
+{
+    channel_data_t* chan = (channel_data_t*)__ch_data;
+    uart_width _iir;
+    int res = 0;
+    CYGARC_HAL_SAVE_GP();
+
+    HAL_READ_UINT_UART(chan->base+CYG_DEV_SERIAL_IIR, _iir);
+    _iir &= SIO_IIR_ID_MASK;
+
+    *__ctrlc = 0;
+    if ( ISR_Rx == _iir ) {
+        uart_width c, lsr;
+        cyg_uint8 c8;
+        HAL_READ_UINT_UART(chan->base+CYG_DEV_SERIAL_LSR, lsr);
+        if (lsr & SIO_LSR_DR) {
+
+            HAL_READ_UINT_UART(chan->base+CYG_DEV_SERIAL_RHR, c);
+
+            c8 = (cyg_uint8) (c & 0x00FF);
+
+            if (cyg_hal_is_break( &c8 , 1 ))
+                *__ctrlc = 1;
+        }
+
+        // Acknowledge the interrupt
+        HAL_INTERRUPT_ACKNOWLEDGE(chan->isr_vector);
+        res = CYG_ISR_HANDLED;
+    }
+
+    CYGARC_HAL_RESTORE_GP();
+    return res;
+}
+
+static void cyg_hal_plf_duart_init(void)
+{
+    hal_virtual_comm_table_t* comm;
+    int cur = CYGACC_CALL_IF_SET_CONSOLE_COMM(CYGNUM_CALL_IF_SET_COMM_ID_QUERY_CURRENT);
+    int i;
+
+    // Init channels
+#define NUMOF(x) (sizeof(x)/sizeof(x[0]))
+    for (i = 0;  i < NUMOF(channels);  i++) {
+        HAL_INTERRUPT_MASK(channels[i].isr_vector);
+        init_duart_channel(&channels[i]);
+        CYGACC_CALL_IF_SET_CONSOLE_COMM(i);
+        comm = CYGACC_CALL_IF_CONSOLE_PROCS();
+        CYGACC_COMM_IF_CH_DATA_SET(*comm, &channels[i]);
+        CYGACC_COMM_IF_WRITE_SET(*comm, cyg_hal_plf_duart_write);
+        CYGACC_COMM_IF_READ_SET(*comm, cyg_hal_plf_duart_read);
+        CYGACC_COMM_IF_PUTC_SET(*comm, cyg_hal_plf_duart_putc);
+        CYGACC_COMM_IF_GETC_SET(*comm, cyg_hal_plf_duart_getc);
+        CYGACC_COMM_IF_CONTROL_SET(*comm, cyg_hal_plf_duart_control);
+        CYGACC_COMM_IF_DBG_ISR_SET(*comm, cyg_hal_plf_duart_isr);
+        CYGACC_COMM_IF_GETC_TIMEOUT_SET(*comm, cyg_hal_plf_duart_getc_timeout);
+    }
+
+    // Restore original console
+    CYGACC_CALL_IF_SET_CONSOLE_COMM(cur);
+}
+
+//=============================================================================
+// Compatibility with older stubs
+//=============================================================================
+
+//=============================================================================
+// Compatibility with older stubs
+//=============================================================================
+
+#ifndef CYGSEM_HAL_VIRTUAL_VECTOR_DIAG
+
+#include <cyg/hal/hal_stub.h>           // cyg_hal_gdb_interrupt
+
+#if (CYGNUM_HAL_VIRTUAL_VECTOR_CONSOLE_CHANNEL == 0)
+#define __BASE   CMA101_DUARTA
+#define _INT     CYGNUM_HAL_INTERRUPT_SERIAL_A
+#elif (CYGNUM_HAL_VIRTUAL_VECTOR_CONSOLE_CHANNEL == 1)
+#define __BASE   CMA101_DUARTB
+#define _INT     CYGNUM_HAL_INTERRUPT_SERIAL_B
+#endif
+
+#ifdef __BASE
+
+#ifdef CYGSEM_HAL_ROM_MONITOR
+#define CYG_HAL_STARTUP_ROM
+#define CYG_HAL_STARTUP_ROMRAM
+#undef CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS
+#endif
+
+#if (defined(CYG_HAL_STARTUP_ROM) || defined(CYG_HAL_STARTUP_ROMRAM)) && !defined(CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS)
+#define HAL_DIAG_USES_HARDWARE
+#elif !defined(CYGDBG_HAL_DIAG_TO_DEBUG_CHAN)
+#define HAL_DIAG_USES_HARDWARE
+#elif CYGNUM_HAL_VIRTUAL_VECTOR_CONSOLE_CHANNEL != CYGNUM_HAL_VIRTUAL_VECTOR_DEBUG_CHANNEL
+#define HAL_DIAG_USES_HARDWARE
+#endif
+
+static channel_data_t channel = {
+    (uart_width*) _BASE, 0, 0
+};
+
+#ifdef HAL_DIAG_USES_HARDWARE
+
+void hal_diag_init(void)
+{
+    static int init = 0;
+    char *msg = "\n\rARM eCos\n\r";
+    uart_width lcr;
+
+    if (init++) return;
+
+    init_duart_channel(&channel);
+
+    while (*msg) hal_diag_write_char(*msg++);
+}
+
+#ifdef DEBUG_DIAG
+#if defined(CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS)
+#define DIAG_BUFSIZE 32
+#else
+#define DIAG_BUFSIZE 2048
+#endif
+static char diag_buffer[DIAG_BUFSIZE];
+static int diag_bp = 0;
+#endif
+
+void hal_diag_write_char(char c)
+{
+    uart_width lsr;
+
+    hal_diag_init();
+
+    cyg_hal_plf_duart_putc(&channel, c)
+
+#ifdef DEBUG_DIAG
+    diag_buffer[diag_bp++] = c;
+    if (diag_bp == DIAG_BUFSIZE) {
+        while (1) ;
+        diag_bp = 0;
+    }
+#endif
+}
+
+void hal_diag_read_char(char *c)
+{
+    *c = cyg_hal_plf_duart_getc(&channel);
+}
+
+#else // HAL_DIAG relies on GDB
+
+// Initialize diag port - assume GDB channel is already set up
+void hal_diag_init(void)
+{
+    if (0) init_duart_channel(&channel); // avoid warning
+}
+
+// Actually send character down the wire
+static void hal_diag_write_char_serial(char c)
+{
+    cyg_hal_plf_duart_putc(&channel, c);
+}
+
+static bool hal_diag_read_serial(char *c)
+{
+    long timeout = 1000000000;  // A long time...
+
+    while (!cyg_hal_plf_duart_getc_nonblock(&channel, c))
+        if (0 == --timeout) return false;
+
+    return true;
+}
+
+void hal_diag_read_char(char *c)
+{
+    while (!hal_diag_read_serial(c)) ;
+}
+
+void hal_diag_write_char(char c)
+{
+    static char line[100];
+    static int pos = 0;
+
+    // No need to send CRs
+    if (c == '\r') return;
+
+    line[pos++] = c;
+
+    if (c == '\n' || pos == sizeof(line)) {
+        CYG_INTERRUPT_STATE old;
+
+        // Disable interrupts. This prevents GDB trying to interrupt us
+        // while we are in the middle of sending a packet. The serial
+        // receive interrupt will be seen when we re-enable interrupts
+        // later.
+
+#ifdef CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS
+        CYG_HAL_GDB_ENTER_CRITICAL_IO_REGION(old);
+#else
+        HAL_DISABLE_INTERRUPTS(old);
+#endif
+
+        while (1) {
+            static char hex[] = "0123456789ABCDEF";
+            cyg_uint8 csum = 0;
+            int i;
+            char c1;
+
+            hal_diag_write_char_serial('$');
+            hal_diag_write_char_serial('O');
+            csum += 'O';
+            for (i = 0; i < pos; i++) {
+                char ch = line[i];
+                char h = hex[(ch>>4)&0xF];
+                char l = hex[ch&0xF];
+                hal_diag_write_char_serial(h);
+                hal_diag_write_char_serial(l);
+                csum += h;
+                csum += l;
+            }
+            hal_diag_write_char_serial('#');
+            hal_diag_write_char_serial(hex[(csum>>4)&0xF]);
+            hal_diag_write_char_serial(hex[csum&0xF]);
+
+            // Wait for the ACK character '+' from GDB here and handle
+            // receiving a ^C instead.  This is the reason for this clause
+            // being a loop.
+            if (!hal_diag_read_serial(&c1))
+                continue;   // No response - try sending packet again
+
+            if ( c1 == '+' )
+                break;          // a good acknowledge
+
+#ifdef CYGDBG_HAL_DEBUG_GDB_BREAK_SUPPORT
+            cyg_drv_interrupt_acknowledge(CYG_DEV_SERIAL_INT);
+            if ( c1 == 3 ) {
+                // Ctrl-C: breakpoint.
+                cyg_hal_gdb_interrupt (__builtin_return_address(0));
+                break;
+            }
+#endif
+            // otherwise, loop round again
+        }
+
+        pos = 0;
+
+        // And re-enable interrupts
+#ifdef CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS
+        CYG_HAL_GDB_LEAVE_CRITICAL_IO_REGION(old);
+#else
+        HAL_RESTORE_INTERRUPTS(old);
+#endif
+
+    }
+}
+#endif
+
+#endif // __BASE
+
+#endif // CYGSEM_HAL_VIRTUAL_VECTOR_DIAG
+
+/*---------------------------------------------------------------------------*/
diff -urN -x CVS dummy/packages/hal/arm/mx31/ads/current/src/board_misc.c ecos_mx31/packages/hal/arm/mx31/ads/current/src/board_misc.c
--- dummy/packages/hal/arm/mx31/ads/current/src/board_misc.c	1969-12-31 18:00:00.000000000 -0600
+++ ecos_mx31/packages/hal/arm/mx31/ads/current/src/board_misc.c	2008-04-02 14:36:05.000000000 -0500
@@ -0,0 +1,188 @@
+//==========================================================================
+//
+//      board_misc.c
+//
+//      HAL misc board support code for the board
+//
+//==========================================================================
+//####ECOSGPLCOPYRIGHTBEGIN####
+// -------------------------------------------
+// This file is part of eCos, the Embedded Configurable Operating System.
+// Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+//
+// eCos is free software; you can redistribute it and/or modify it under
+// the terms of the GNU General Public License as published by the Free
+// Software Foundation; either version 2 or (at your option) any later version.
+//
+// eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with eCos; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+//
+// As a special exception, if other files instantiate templates or use macros
+// or inline functions from this file, or you compile this file and link it
+// with other works to produce a work based on this file, this file does not
+// by itself cause the resulting work to be covered by the GNU General Public
+// License. However the source code for this file must still be made available
+// in accordance with section (3) of the GNU General Public License.
+//
+// This exception does not invalidate any other reasons why a work based on
+// this file might be covered by the GNU General Public License.
+//
+// Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+// at http://sources.redhat.com/ecos/ecos-license/
+// -------------------------------------------
+//####ECOSGPLCOPYRIGHTEND####
+//========================================================================*/
+
+#include <pkgconf/hal.h>
+#include <pkgconf/system.h>
+#include <redboot.h>
+#include CYGBLD_HAL_PLATFORM_H
+
+#include <cyg/infra/cyg_type.h>         // base types
+#include <cyg/infra/cyg_trac.h>         // tracing macros
+#include <cyg/infra/cyg_ass.h>          // assertion macros
+
+#include <cyg/hal/hal_io.h>             // IO macros
+#include <cyg/hal/hal_arch.h>           // Register state info
+#include <cyg/hal/hal_diag.h>
+#include <cyg/hal/hal_intr.h>           // Interrupt names
+#include <cyg/hal/hal_cache.h>
+#include <cyg/hal/hal_soc.h>         // Hardware definitions
+#include <cyg/hal/fsl_board.h>             // Platform specifics
+
+#include <cyg/infra/diag.h>             // diag_printf
+
+// All the MM table layout is here:
+#include <cyg/hal/hal_mm.h>
+
+externC void* memset(void *, int, size_t);
+
+void hal_mmu_init(void)
+{
+    unsigned long ttb_base = RAM_BANK0_BASE + 0x4000;
+    unsigned long i;
+
+    /*
+     * Set the TTB register
+     */
+    asm volatile ("mcr  p15,0,%0,c2,c0,0" : : "r"(ttb_base) /*:*/);
+
+    /*
+     * Set the Domain Access Control Register
+     */
+    i = ARM_ACCESS_DACR_DEFAULT;
+    asm volatile ("mcr  p15,0,%0,c3,c0,0" : : "r"(i) /*:*/);
+
+    /*
+     * First clear all TT entries - ie Set them to Faulting
+     */
+    memset((void *)ttb_base, 0, ARM_FIRST_LEVEL_PAGE_TABLE_SIZE);
+
+    /*              Actual   Virtual  Size   Attributes                                                    Function  */
+    /*              Base     Base     MB     cached?           buffered?        access permissions                 */
+    /*              xxx00000 xxx00000                                                                                */
+    X_ARM_MMU_SECTION(0x000, 0xF00,   0x1,   ARM_UNCACHEABLE, ARM_UNBUFFERABLE, ARM_ACCESS_PERM_RW_RW); /* ROM */
+    X_ARM_MMU_SECTION(0x300, 0x300,   0x1,   ARM_UNCACHEABLE, ARM_UNBUFFERABLE, ARM_ACCESS_PERM_RW_RW); /* L2CC */
+    X_ARM_MMU_SECTION(0x43F, 0x43F,   0x3C1, ARM_UNCACHEABLE, ARM_UNBUFFERABLE, ARM_ACCESS_PERM_RW_RW); /* Internal Regsisters upto SDRAM*/
+    X_ARM_MMU_SECTION(0x800, 0x000,   0x80,  ARM_CACHEABLE,   ARM_BUFFERABLE,   ARM_ACCESS_PERM_RW_RW); /* SDRAM */
+    X_ARM_MMU_SECTION(0x800, 0x800,   0x80,  ARM_CACHEABLE,   ARM_BUFFERABLE,   ARM_ACCESS_PERM_RW_RW); /* SDRAM */
+    X_ARM_MMU_SECTION(0xA00, 0xA00,   0x20,  ARM_CACHEABLE,   ARM_BUFFERABLE,   ARM_ACCESS_PERM_RW_RW); /* Flash */
+    X_ARM_MMU_SECTION(0xB40, 0xB40,   0x10,  ARM_UNCACHEABLE, ARM_UNBUFFERABLE, ARM_ACCESS_PERM_RW_RW); /* External I/O */
+    X_ARM_MMU_SECTION(0xB50, 0xB50,   0x8,   ARM_CACHEABLE,   ARM_BUFFERABLE,   ARM_ACCESS_PERM_RW_RW); /* PSRAM */
+    X_ARM_MMU_SECTION(0xB80, 0xB80,   0x10,  ARM_UNCACHEABLE, ARM_UNBUFFERABLE, ARM_ACCESS_PERM_RW_RW); /* EIM control*/
+}
+
+//
+// Platform specific initialization
+//
+
+unsigned int g_clock_src;
+extern int g_board_type;
+
+void plf_hardware_init(void)
+{
+    volatile unsigned short dummy, temp;
+    volatile int i = 0;
+    unsigned long val = readl(CCM_BASE_ADDR + CLKCTL_CCMR);
+
+    if ((val & 0x6) == 0x4) {
+        if ((readw(PBC_BASE + PBC_BSTAT2) & CLK_INPUT_27MHZ_SET) != 0) {
+            g_clock_src = FREQ_27MHZ;
+        } else {
+            g_clock_src = FREQ_26MHZ;
+        }
+    } else if ((val & 0x6) == 0x2) {
+        g_clock_src = FREQ_32768HZ;
+    }
+
+    /* PBC setup */
+    //Enable UART transceivers also reset the Ethernet/external UART
+    temp = readw(PBC_BASE + PBC_BCTRL1);
+
+    writew(0x8023, PBC_BASE + PBC_BCTRL1);
+
+    for (i = 0; i < 100000; i++) {
+    }
+
+    // clear the reset, toggle the LEDs
+    writew(0xDF, PBC_BASE + PBC_BCTRL1_CLR);
+
+    for (i = 0; i < 100000; i++) {
+    }
+
+    dummy = readb(0xB4000008);
+    dummy = readb(0xB4000007);
+    dummy = readb(0xB4000008);
+    dummy = readb(0xB4000007);
+
+    // UAT1
+    writel(0x12121212, IOMUXC_BASE_ADDR + 0x7C);
+    writel(0x12121212, IOMUXC_BASE_ADDR + 0x80);
+
+    // UART2
+    writel(0x13131300, IOMUXC_BASE_ADDR + 0x70);
+    writel(0x00001313, IOMUXC_BASE_ADDR + 0x74);
+    writel(0x00000040, IOMUXC_BASE_ADDR + 0x7C);
+    writel(0x40400000, IOMUXC_BASE_ADDR + 0x78);
+
+    g_board_type = BOARD_TYPE_ADS;
+}
+
+#include CYGHWR_MEMORY_LAYOUT_H
+
+typedef void code_fun(void);
+
+void board_program_new_stack(void *func)
+{
+    register CYG_ADDRESS stack_ptr asm("sp");
+    register CYG_ADDRESS old_stack asm("r4");
+    register code_fun *new_func asm("r0");
+    old_stack = stack_ptr;
+    stack_ptr = CYGMEM_REGION_ram + CYGMEM_REGION_ram_SIZE - sizeof(CYG_ADDRESS);
+    new_func = (code_fun*)func;
+    new_func();
+    stack_ptr = old_stack;
+}
+
+static void display_clock_src(void)
+{
+    diag_printf("\n");
+    if (g_clock_src == FREQ_27MHZ) {
+        diag_printf("Clock input is 27 MHz");
+    } else if (g_clock_src == FREQ_26MHZ) {
+        diag_printf("Clock input is 26 MHz");
+    } else if (g_clock_src == FREQ_32768HZ) {
+        diag_printf("Clock input is 32KHz");
+    } else {
+        diag_printf("Unknown clock input source. Something is wrong!");
+    }
+}
+RedBoot_init(display_clock_src, RedBoot_INIT_LAST);
+
+// ------------------------------------------------------------------------
diff -urN -x CVS dummy/packages/hal/arm/mx31/ads/current/src/redboot_cmds.c ecos_mx31/packages/hal/arm/mx31/ads/current/src/redboot_cmds.c
--- dummy/packages/hal/arm/mx31/ads/current/src/redboot_cmds.c	1969-12-31 18:00:00.000000000 -0600
+++ ecos_mx31/packages/hal/arm/mx31/ads/current/src/redboot_cmds.c	2008-04-01 11:25:31.000000000 -0500
@@ -0,0 +1,366 @@
+//==========================================================================
+//
+//      redboot_cmds.c
+//
+//      Board [platform] specific RedBoot commands
+//
+//==========================================================================
+//####ECOSGPLCOPYRIGHTBEGIN####
+// -------------------------------------------
+// This file is part of eCos, the Embedded Configurable Operating System.
+// Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+//
+// eCos is free software; you can redistribute it and/or modify it under
+// the terms of the GNU General Public License as published by the Free
+// Software Foundation; either version 2 or (at your option) any later version.
+//
+// eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with eCos; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+//
+// As a special exception, if other files instantiate templates or use macros
+// or inline functions from this file, or you compile this file and link it
+// with other works to produce a work based on this file, this file does not
+// by itself cause the resulting work to be covered by the GNU General Public
+// License. However the source code for this file must still be made available
+// in accordance with section (3) of the GNU General Public License.
+//
+// This exception does not invalidate any other reasons why a work based on
+// this file might be covered by the GNU General Public License.
+//
+// Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+// at http://sources.redhat.com/ecos/ecos-license/
+// -------------------------------------------
+//####ECOSGPLCOPYRIGHTEND####
+//==========================================================================
+#include <redboot.h>
+#include <cyg/hal/hal_intr.h>
+#include <cyg/hal/hal_cache.h>
+#include <cyg/hal/plf_mmap.h>
+#include <cyg/hal/fsl_board.h>          // Platform specific hardware definitions
+
+#ifdef CYGSEM_REDBOOT_FLASH_CONFIG
+#include <flash_config.h>
+
+#if (REDBOOT_IMAGE_SIZE != CYGBLD_REDBOOT_MIN_IMAGE_SIZE)
+#error REDBOOT_IMAGE_SIZE != CYGBLD_REDBOOT_MIN_IMAGE_SIZE
+#endif
+
+RedBoot_config_option("Board specifics",
+                      brd_specs,
+                      ALWAYS_ENABLED,
+                      true,
+                      CONFIG_INT,
+                      0
+                     );
+#endif  //CYGSEM_REDBOOT_FLASH_CONFIG
+
+char HAL_PLATFORM_EXTRA[60] = "MX31 ADS (Freescale i.MX31 based) PASS 1.0 [x32 DDR]";
+
+static void runImg(int argc, char *argv[]);
+
+RedBoot_cmd("run",
+            "Run an image at a location with MMU off",
+            "[<virtual addr>]",
+            runImg
+           );
+
+void launchRunImg(unsigned long addr)
+{
+    asm volatile ("mov r12, r0;");
+    HAL_CLEAN_INVALIDATE_L2();
+    HAL_DISABLE_L2();
+    HAL_MMU_OFF();
+    asm volatile (
+                 "mov r0, #0;"
+                 "mov r1, r12;"
+                 "mov r11, #0;"
+                 "mov r12, #0;"
+                 "mrs r10, cpsr;"
+                 "bic r10, r10, #0xF0000000;"
+                 "msr cpsr_f, r10;"
+                 "mov pc, r1"
+                 );
+}
+
+extern unsigned long entry_address;
+
+static void runImg(int argc,char *argv[])
+{
+    unsigned int virt_addr, phys_addr;
+
+    // Default physical entry point for Symbian
+    if (entry_address == 0xFFFFFFFF)
+        virt_addr = 0x800000;
+    else
+    virt_addr = entry_address;
+
+    if (!scan_opts(argc,argv,1,0,0,(void*)&virt_addr,
+                   OPTION_ARG_TYPE_NUM, "virtual address"))
+        return;
+
+    if (entry_address != 0xFFFFFFFF)
+        diag_printf("load entry_address=0x%lx\n", entry_address);
+    HAL_VIRT_TO_PHYS_ADDRESS(virt_addr, phys_addr);
+
+    diag_printf("virt_addr=0x%x\n",virt_addr);
+    diag_printf("phys_addr=0x%x\n",phys_addr);
+
+    launchRunImg(phys_addr);
+}
+
+#if CYGPKG_REDBOOT_NETWORKING
+#define LAN_BASE    BOARD_CS_LAN_BASE
+
+#define PP_EE_ADDR_W0   0x001C
+#define PP_EE_ADDR_W1   0x001D
+#define PP_EE_ADDR_W2   0x001E
+
+extern cyg_uint16 read_eeprom(cyg_addrword_t base, cyg_uint16 offset);
+extern void write_eeprom(cyg_addrword_t base, cyg_uint16 offset, cyg_uint16 data);
+
+// Exported CLI function(s)
+static void setMac(int argc, char *argv[]);
+RedBoot_cmd("setmac",
+            "Set Ethernet MAC address in EEPROM",
+            "[0x##:0x##:0x##:0x##:0x##:0x##]",
+            setMac
+           );
+
+const static unsigned short RESET_CONFIG_BLOCK[] = {
+    0xA002,
+    0x5E00,
+};
+
+#define DRIVER_CONFIG_BASE        0x1C   //Cirrus driver config base
+
+static unsigned short g_drv_cfg_blk[] = {
+    0xFFFF, //1C - MAC 4,5
+    0xFFFF, //1D - MAC 2,3
+    0xFFFF, //1E - MAC 0,1
+    0x0000, //1F - ISA config
+    0x0000, //20 - PP mem base
+    0x0000, //21 - Boot PROM base
+    0x0000, //22 - Boot PROM mask
+    0x8040, //23 - Tx ctrl: Full duplex, media not required
+    0x0021, //24 - Adapter config: 10Base-T, 10Base-T circuitry
+    0x0001, //25 - EEPROM rev: 1.0
+    0x0000, //26 - resvd
+    0x0A2D, //27 - Mfg date
+    0xFFFF, //28 - copy of 1C
+    0xFFFF, //29 - copy of 1D
+    0xFFFF, //2A - copy of 1E
+    0x0000, //2B - resvd
+    0x0000, //2C - resvd
+    0x0000, //2D - resvd
+    0x0000, //2E - resvd
+    0x0000, //2F - Checksum
+};
+
+static void setMac(int argc,char *argv[])
+{
+    int i, ret, wsize = sizeof(g_drv_cfg_blk) / 2;  // word size
+    unsigned char data[6];
+    unsigned long temp;
+    unsigned short ee_word[3];
+
+    if (argc == 1) {
+        ee_word[0] = read_eeprom(LAN_BASE, PP_EE_ADDR_W0 + 0);
+        ee_word[1] = read_eeprom(LAN_BASE, PP_EE_ADDR_W0 + 1);
+        ee_word[2] = read_eeprom(LAN_BASE, PP_EE_ADDR_W0 + 2);
+        if (ee_word[0] == 0 && ee_word[1] == 0 && ee_word[2] == 0) {
+            diag_printf("Can't read MAC address\n\n");
+            return;
+        }
+
+        diag_printf("MAC address: ");
+        diag_printf("0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x\n\n",
+                    (ee_word[0] & 0x00FF), (ee_word[0] >> 8),
+                    (ee_word[1] & 0x00FF), (ee_word[1] >> 8),
+                    (ee_word[2] & 0x00FF), (ee_word[2] >> 8));
+        return;
+    }
+
+    if (argc != 2) {
+        ret = -1; goto error;
+    }
+
+    for (i = 0;  i < 6;  i++) {
+        if (!parse_num(*(&argv[1]), &temp, &argv[1], ":")) {
+            ret = -2; goto error;
+        }
+        if (temp > 0xFF) {
+            ret = -3; goto error;
+        }
+        data[i] = temp & 0xFF;
+    }
+
+    g_drv_cfg_blk[0] = g_drv_cfg_blk[12] = *(unsigned short*)(&data[0]);
+    g_drv_cfg_blk[1] = g_drv_cfg_blk[13] = *(unsigned short*)(&data[2]);
+    g_drv_cfg_blk[2] = g_drv_cfg_blk[14] = *(unsigned short*)(&data[4]);
+
+    // Calculate checksum
+    temp = 0;
+    for (i = 0; i < wsize-1; i++) {
+        temp += g_drv_cfg_blk[i];
+    }
+    temp = (~temp + 1) & 0xFFFF;
+    g_drv_cfg_blk[wsize-1] = temp;
+
+    // Program the EEPROM
+    // Reset config block first
+    for (i = 0; i < sizeof(RESET_CONFIG_BLOCK)/2; i++) {
+        write_eeprom(LAN_BASE, i, RESET_CONFIG_BLOCK[i]);
+    }
+    // Driver config block 2nd
+    for (i = 0; i < wsize; i++) {
+        write_eeprom(LAN_BASE, DRIVER_CONFIG_BASE+i,
+                     g_drv_cfg_blk[i]);
+    }
+    return;
+    error:
+    diag_printf("Wrong value for setMac. Error=%d\n\n", ret);
+}
+
+//#define EEPROM_DEBUG
+#ifdef EEPROM_DEBUG
+RedBoot_cmd("eefun",
+            "read/write a word into EEPROM",
+            "[0-based IO Base offset:value]",
+            eefun
+           );
+
+static void eefun(int argc,char *argv[])
+{
+    int i, ret;
+    unsigned short data[2];
+    unsigned int temp;
+
+    if (argc != 2) {
+        ret=-1; goto error;
+    }
+
+    for (i = 0;  i < 2;  i++) {
+        if (!parse_num(*(&argv[1]), &temp, &argv[1], ":")) {
+            ret=-2; goto error;
+        }
+        if (temp > 0xFFFF) {
+            ret=-3; goto error;
+        }
+        data[i] = (unsigned short)temp;
+    }
+
+    if (data[0] >= 0x30 && data[0] != 0xFFFF) {
+        ret=-4; goto error;
+    }
+
+    if (data[0] == 0xFFFF) {
+        for (i = 0; i < 0x30; i++) {
+            if (i % 8 == 0) diag_printf("0x%02x: ", i);
+            diag_printf("%04x ", read_eeprom(LAN_BASE, i));
+            if (i % 8 == 7) diag_printf("\n");
+        }
+        return;
+    }
+
+    diag_printf("writeEE() Offset: 0x%x, value=0x%x\n", data[0], data[1]);
+    write_eeprom(LAN_BASE, data[0], data[1]);
+    diag_printf("Reading back: 0x%x\n\n", read_eeprom(LAN_BASE, data[0]));
+    return;
+    error:
+    diag_printf("Wrong value %d for writeEE\n\n", ret);
+}
+#endif //EEPROM_DEBUG
+
+#endif //CYGPKG_REDBOOT_NETWORKING
+
+#if defined(CYGSEM_REDBOOT_FLASH_CONFIG) && defined(CYG_HAL_STARTUP_ROMRAM)
+
+RedBoot_cmd("romupdate",
+            "Update Redboot with currently running image",
+            "",
+            romupdate
+           );
+
+extern int flash_program(void *_addr, void *_data, int len, void **err_addr);
+extern int flash_erase(void *addr, int len, void **err_addr);
+extern char *flash_errmsg(int err);
+extern unsigned char *ram_end; //ram end is where the redboot starts FIXME: use PC value
+
+#ifdef CYGPKG_IO_FLASH
+void romupdate(int argc, char *argv[])
+{
+    void *err_addr, *base_addr;
+    int stat;
+
+    if (IS_FIS_FROM_NAND()) {
+        base_addr = (void*)0;
+        diag_printf("Updating ROM in NAND flash\n");
+    } else if (IS_FIS_FROM_NOR()) {
+        base_addr = (void*)BOARD_FLASH_START;
+        diag_printf("Updating ROM in NOR flash\n");
+    } else {
+        diag_printf("romupdate not supported\n");
+        diag_printf("Use \"factive [NOR|NAND]\" to select either NOR or NAND flash\n");
+        return;
+    }
+    // Erase area to be programmed
+    if ((stat = flash_erase((void *)base_addr,
+                            CYGBLD_REDBOOT_MIN_IMAGE_SIZE,
+                            (void **)&err_addr)) != 0) {
+        diag_printf("Can't erase region at %p: %s\n",
+                    err_addr, flash_errmsg(stat));
+        return;
+    }
+    // Now program it
+    if ((stat = flash_program((void *)base_addr, (void *)ram_end,
+                              CYGBLD_REDBOOT_MIN_IMAGE_SIZE,
+                              (void **)&err_addr)) != 0) {
+        diag_printf("Can't program region at %p: %s\n",
+                    err_addr, flash_errmsg(stat));
+    }
+}
+RedBoot_cmd("factive",
+            "Enable one flash media for Redboot",
+            "[NOR | NAND]",
+            factive
+           );
+
+void factive(int argc, char *argv[])
+{
+    unsigned long phys_addr;
+
+    if (argc != 2) {
+        diag_printf("Invalid factive cmd\n");
+        return;
+    }
+
+    if (strcasecmp(argv[1], "NOR") == 0) {
+#ifndef MXCFLASH_SELECT_NOR
+        diag_printf("Not supported\n");
+        return;
+#else
+        MXC_ASSERT_NOR_BOOT();
+#endif
+    } else if (strcasecmp(argv[1], "NAND") == 0) {
+#ifndef MXCFLASH_SELECT_NAND
+        diag_printf("Not supported\n");
+        return;
+#else
+        MXC_ASSERT_NAND_BOOT();
+#endif
+    } else {
+        diag_printf("Invalid command: %s\n", argv[1]);
+        return;
+    }
+    HAL_VIRT_TO_PHYS_ADDRESS(ram_end, phys_addr);
+
+    launchRunImg(phys_addr);
+}
+#endif //CYGPKG_IO_FLASH
+#endif /* CYG_HAL_STARTUP_ROMRAM */
diff -urN -x CVS dummy/packages/hal/arm/mx31/var/current/cdl/hal_arm_soc.cdl ecos_mx31/packages/hal/arm/mx31/var/current/cdl/hal_arm_soc.cdl
--- dummy/packages/hal/arm/mx31/var/current/cdl/hal_arm_soc.cdl	1969-12-31 18:00:00.000000000 -0600
+++ ecos_mx31/packages/hal/arm/mx31/var/current/cdl/hal_arm_soc.cdl	2006-03-25 17:14:34.000000000 -0600
@@ -0,0 +1,162 @@
+# ====================================================================
+#####ECOSGPLCOPYRIGHTBEGIN####
+## -------------------------------------------
+## This file is part of eCos, the Embedded Configurable Operating System.
+## Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+##
+## eCos is free software; you can redistribute it and/or modify it under
+## the terms of the GNU General Public License as published by the Free
+## Software Foundation; either version 2 or (at your option) any later version.
+##
+## eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+## WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+## for more details.
+##
+## You should have received a copy of the GNU General Public License along
+## with eCos; if not, write to the Free Software Foundation, Inc.,
+## 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+##
+## As a special exception, if other files instantiate templates or use macros
+## or inline functions from this file, or you compile this file and link it
+## with other works to produce a work based on this file, this file does not
+## by itself cause the resulting work to be covered by the GNU General Public
+## License. However the source code for this file must still be made available
+## in accordance with section (3) of the GNU General Public License.
+##
+## This exception does not invalidate any other reasons why a work based on
+## this file might be covered by the GNU General Public License.
+##
+## Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+## at http://sources.redhat.com/ecos/ecos-license/
+## -------------------------------------------
+#####ECOSGPLCOPYRIGHTEND####
+# ====================================================================
+######DESCRIPTIONBEGIN####
+#
+# Author(s):      gthomas
+# Original data:  gthomas
+# Contributors:
+# Date:           2000-05-08
+#
+#####DESCRIPTIONEND####
+#
+# ====================================================================
+cdl_package CYGPKG_HAL_ARM_MX31 {
+    display       "Freescale SoC architecture"
+    parent        CYGPKG_HAL_ARM
+    hardware
+    include_dir   cyg/hal
+    define_header hal_arm_soc.h
+    description   "
+        This HAL variant package provides generic
+        support for the Freescale SoC. It is also
+        necessary to select a specific target platform HAL
+        package."
+
+    implements    CYGINT_HAL_ARM_ARCH_ARM9
+    implements    CYGINT_HAL_VIRTUAL_VECTOR_COMM_BAUD_SUPPORT
+
+    # Let the architectural HAL see this variant's interrupts file -
+    # the SoC has no variation between targets here.
+    define_proc {
+        puts $::cdl_header "#define CYGBLD_HAL_VAR_INTS_H <cyg/hal/hal_var_ints.h>"
+        puts $::cdl_system_header "#define CYGBLD_HAL_ARM_VAR_IO_H"
+
+        puts $::cdl_header "#define CYGPRI_KERNEL_TESTS_DHRYSTONE_PASSES 1000000"
+    }
+
+    compile       soc_diag.c soc_misc.c
+    compile -library=libextras.a cmds.c
+
+    cdl_option CYGHWR_HAL_ARM_SOC_PROCESSOR_CLOCK {
+        display       "Processor clock rate"
+        active_if     { CYG_HAL_STARTUP == "ROM" }
+        flavor        data
+        legal_values  150000 200000
+        default_value { CYGHWR_HAL_ARM_SOC_PROCESSOR_CLOCK_OVERRIDE_DEFAULT ?
+                        CYGHWR_HAL_ARM_SOC_PROCESSOR_CLOCK_OVERRIDE_DEFAULT : 150000}
+        description   "
+           The processor can run at various frequencies.
+           These values are expressed in KHz.  Note that there are
+           several steppings of the rated to run at different
+           maximum frequencies.  Check the specs to make sure that your
+           particular processor can run at the rate you select here."
+    }
+
+    # Real-time clock/counter specifics
+    cdl_component CYGNUM_HAL_RTC_CONSTANTS {
+        display       "Real-time clock constants"
+        flavor        none
+        no_define
+    
+        cdl_option CYGNUM_HAL_RTC_NUMERATOR {
+            display       "Real-time clock numerator"
+            flavor        data
+            calculated    1000000000
+        }
+        cdl_option CYGNUM_HAL_RTC_DENOMINATOR {
+            display       "Real-time clock denominator"
+            flavor        data
+            default_value 100
+            description   "
+              This option selects the heartbeat rate for the real-time clock.
+              The rate is specified in ticks per second.  Change this value
+              with caution - too high and your system will become saturated
+              just handling clock interrupts, too low and some operations
+              such as thread scheduling may become sluggish."
+        }
+        cdl_option CYGNUM_HAL_RTC_PERIOD {
+            display       "Real-time clock period"
+            flavor        data
+            calculated    (3686400/CYGNUM_HAL_RTC_DENOMINATOR)        ;# Clock for OS Timer is 3.6864MHz
+        }
+    }
+
+    # Control over hardware layout.  
+    cdl_interface     CYGHWR_HAL_ARM_SOC_UART1 {
+        display   "UART1 available as diagnostic/debug channel"
+        description "
+	  The chip has multiple serial channels which may be
+          used for different things on different platforms.  This
+          interface allows a platform to indicate that the specified
+          serial port can be used as a diagnostic and/or debug channel."
+    }
+
+    cdl_interface     CYGHWR_HAL_ARM_SOC_UART2 {
+        display   "UART2 available as diagnostic/debug channel"
+        description "
+	  The chip has multiple serial channels which may be
+          used for different things on different platforms.  This
+          interface allows a platform to indicate that the specified
+          serial port can be used as a diagnostic and/or debug channel."
+    }
+
+    cdl_interface     CYGHWR_HAL_ARM_SOC_UART3 {
+        display   "UART3 available as diagnostic/debug channel"
+        description "
+	  The chip has multiple serial channels which may be
+          used for different things on different platforms.  This
+          interface allows a platform to indicate that the specified
+          serial port can be used as a diagnostic and/or debug channel."
+    }
+
+    cdl_interface     CYGHWR_HAL_ARM_SOC_UART4 {
+        display   "UART4 available as diagnostic/debug channel"
+        description "
+	  The chip has multiple serial channels which may be
+          used for different things on different platforms.  This
+          interface allows a platform to indicate that the specified
+          serial port can be used as a diagnostic and/or debug channel."
+    }
+
+    cdl_interface     CYGHWR_HAL_ARM_SOC_UART5 {
+        display   "UART5 available as diagnostic/debug channel"
+        description "
+	  The chip has multiple serial channels which may be
+          used for different things on different platforms.  This
+          interface allows a platform to indicate that the specified
+          serial port can be used as a diagnostic and/or debug channel."
+    }
+
+}
diff -urN -x CVS dummy/packages/hal/arm/mx31/var/current/include/hal_cache.h ecos_mx31/packages/hal/arm/mx31/var/current/include/hal_cache.h
--- dummy/packages/hal/arm/mx31/var/current/include/hal_cache.h	1969-12-31 18:00:00.000000000 -0600
+++ ecos_mx31/packages/hal/arm/mx31/var/current/include/hal_cache.h	2008-01-09 13:58:19.000000000 -0600
@@ -0,0 +1,322 @@
+#ifndef CYGONCE_HAL_CACHE_H
+#define CYGONCE_HAL_CACHE_H
+
+//=============================================================================
+//
+//      hal_cache.h
+//
+//      HAL cache control API
+//
+//=============================================================================
+//####ECOSGPLCOPYRIGHTBEGIN####
+// -------------------------------------------
+// This file is part of eCos, the Embedded Configurable Operating System.
+// Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+//
+// eCos is free software; you can redistribute it and/or modify it under
+// the terms of the GNU General Public License as published by the Free
+// Software Foundation; either version 2 or (at your option) any later version.
+//
+// eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with eCos; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+//
+// As a special exception, if other files instantiate templates or use macros
+// or inline functions from this file, or you compile this file and link it
+// with other works to produce a work based on this file, this file does not
+// by itself cause the resulting work to be covered by the GNU General Public
+// License. However the source code for this file must still be made available
+// in accordance with section (3) of the GNU General Public License.
+//
+// This exception does not invalidate any other reasons why a work based on
+// this file might be covered by the GNU General Public License.
+//
+// Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+// at http://sources.redhat.com/ecos/ecos-license/
+// -------------------------------------------
+//####ECOSGPLCOPYRIGHTEND####
+//=============================================================================
+
+#include <cyg/infra/cyg_type.h>
+#include <cyg/hal/hal_soc.h>         // Variant specific hardware definitions
+
+//-----------------------------------------------------------------------------
+// Cache dimensions
+
+// Data cache
+#define HAL_DCACHE_SIZE                 0x4000    // 16KB Size of data cache in bytes
+#define HAL_DCACHE_LINE_SIZE            32    // Size of a data cache line
+#define HAL_DCACHE_WAYS                 64    // Associativity of the cache
+
+// Instruction cache
+#define HAL_ICACHE_SIZE                 0x4000    // Size of cache in bytes
+#define HAL_ICACHE_LINE_SIZE            32    // Size of a cache line
+#define HAL_ICACHE_WAYS                 64    // Associativity of the cache
+
+#define HAL_DCACHE_SETS (HAL_DCACHE_SIZE / (HAL_DCACHE_LINE_SIZE*HAL_DCACHE_WAYS))
+#define HAL_ICACHE_SETS (HAL_ICACHE_SIZE / (HAL_ICACHE_LINE_SIZE*HAL_ICACHE_WAYS))
+
+#define CYGHWR_HAL_ARM_ARM9_CLEAN_DCACHE_INDEX
+#define CYGHWR_HAL_ARM_ARM9_CLEAN_DCACHE_INDEX_STEP  0x20
+#define CYGHWR_HAL_ARM_ARM9_CLEAN_DCACHE_INDEX_LIMIT 0x100
+//-----------------------------------------------------------------------------
+// Global control of data cache
+
+// Enable the data cache
+#define HAL_DCACHE_ENABLE_L1()                                          \
+CYG_MACRO_START                                                         \
+    asm volatile (                                                      \
+        "mrc p15, 0, r1, c1, c0, 0;"                                    \
+        "orr r1, r1, #0x0007;" /* enable DCache (also ensures */        \
+                               /* the MMU, alignment faults, and */       \
+        "mcr p15, 0, r1, c1, c0, 0"                                     \
+        :                                                               \
+        :                                                               \
+        : "r1" /* Clobber list */                                       \
+        );                                                              \
+CYG_MACRO_END
+
+// Disable the data cache
+#define HAL_DCACHE_DISABLE_L1()                                         \
+CYG_MACRO_START                                                         \
+    asm volatile (                                                      \
+        "mov r1, #0;"                                                   \
+        "mcr p15, 0, r1, c7, c6, 0;" /* clear data cache */             \
+        "mrc p15, 0, r1, c1, c0, 0;"                                    \
+        "bic r1, r1, #0x0004;" /* disable DCache  */                    \
+                             /* but not MMU and alignment faults */     \
+        "mcr p15, 0, r1, c1, c0, 0"                                     \
+        :                                                               \
+        :                                                               \
+        : "r1" /* Clobber list */                                       \
+    );                                                                  \
+CYG_MACRO_END
+
+// Invalidate the entire cache
+#define HAL_DCACHE_INVALIDATE_ALL_L1()                                  \
+CYG_MACRO_START  /* this macro can discard dirty cache lines. */        \
+    asm volatile (                                                      \
+        "mov r0, #0;"                                                   \
+        "mcr p15, 0, r0, c7, c6, 0;" /* flush d-cache */                \
+        "mcr p15, 0, r0, c8, c7, 0;" /* flush i+d-TLBs */               \
+        :                                                               \
+        :                                                               \
+        : "r0","memory" /* clobber list */                              \
+    );                                                                  \
+CYG_MACRO_END
+
+// Synchronize the contents of the cache with memory.
+// using ARM9's defined(CYGHWR_HAL_ARM_ARM9_CLEAN_DCACHE_INDEX)
+#define HAL_DCACHE_SYNC_L1()                                           \
+CYG_MACRO_START                                                        \
+    asm volatile (                                                     \
+        "nop; "                                                        \
+        "nop; "                                                        \
+        "nop; "                                                        \
+        "nop; "                                                        \
+        "nop; "                                                        \
+        "nop; "                                                        \
+        "mov r0, #0x0;"                                                \
+        "mcr p15, 0, r0, c7, c14, 0;" /* clean, invalidate Dcache*/    \
+        "mcr p15, 0, r0, c7, c10, 4;" /* drain the write buffer */     \
+        "mcr p15, 0, r0, c7, c10, 5;" /* data memory barrier */        \
+        :                                                              \
+        :                                                              \
+        : "r0" /* Clobber list */                                      \
+        );                                                             \
+CYG_MACRO_END
+
+// Query the state of the data cache
+#define HAL_DCACHE_IS_ENABLED(_state_)                                  \
+CYG_MACRO_START                                                         \
+    register int reg;                                                   \
+    asm volatile (                                                      \
+        "nop; "                                                         \
+        "nop; "                                                         \
+        "nop; "                                                         \
+        "nop; "                                                         \
+        "nop; "                                                         \
+        "mrc p15, 0, %0, c1, c0, 0;"                                    \
+                  : "=r"(reg)                                           \
+                  :                                                     \
+        );                                                              \
+    (_state_) = (0 != (4 & reg)); /* Bit 2 is DCache enable */          \
+CYG_MACRO_END
+
+//-----------------------------------------------------------------------------
+// Global control of Instruction cache
+
+// Enable the instruction cache
+#define HAL_ICACHE_ENABLE_L1()                                          \
+CYG_MACRO_START                                                         \
+    asm volatile (                                                      \
+        "mrc p15, 0, r1, c1, c0, 0;"                                    \
+        "orr r1, r1, #0x1000;"                                          \
+        "orr r1, r1, #0x0003;"  /* enable ICache (also ensures   */     \
+                                /* that MMU and alignment faults */     \
+                                /* are enabled)                  */     \
+        "mcr p15, 0, r1, c1, c0, 0"                                     \
+        :                                                               \
+        :                                                               \
+        : "r1" /* Clobber list */                                       \
+        );                                                              \
+CYG_MACRO_END
+
+// Query the state of the instruction cache
+#define HAL_ICACHE_IS_ENABLED(_state_)                                  \
+CYG_MACRO_START                                                         \
+    register cyg_uint32 reg;                                            \
+    asm volatile (                                                      \
+        "mrc p15, 0, %0, c1, c0, 0"                                     \
+        : "=r"(reg)                                                     \
+        :                                                               \
+        );                                                              \
+                                                                        \
+    (_state_) = (0 != (0x1000 & reg)); /* Bit 12 is ICache enable */    \
+CYG_MACRO_END
+
+// Disable the instruction cache
+#define HAL_ICACHE_DISABLE_L1()                                         \
+CYG_MACRO_START                                                         \
+    asm volatile (                                                      \
+        "mrc p15, 0, r1, c1, c0, 0;"                                    \
+        "bic r1, r1, #0x1000;" /* disable ICache (but not MMU, etc) */  \
+        "mcr p15, 0, r1, c1, c0, 0;"                                    \
+        "mov r1, #0;"                                                   \
+        "mcr p15, 0, r1, c7, c5, 0;"  /* flush ICache */                \
+        "mcr p15, 0, r1, c7, c5, 4;"  /* flush prefetch buffer */       \
+        "nop;" /* next few instructions may be via cache    */          \
+        "nop;"                                                          \
+        "nop;"                                                          \
+        "nop;"                                                          \
+        "nop;"                                                          \
+        "nop"                                                           \
+        :                                                               \
+        :                                                               \
+        : "r1" /* Clobber list */                                       \
+        );                                                              \
+CYG_MACRO_END
+
+// Invalidate the entire cache
+#define HAL_ICACHE_INVALIDATE_ALL_L1()                                  \
+CYG_MACRO_START                                                         \
+    /* this macro can discard dirty cache lines (N/A for ICache) */     \
+    asm volatile (                                                      \
+        "mov r1, #0;"                                                   \
+        "mcr p15, 0, r1, c7, c5, 0;"  /* flush ICache */                \
+        "mcr p15, 0, r1, c8, c5, 0;"  /* flush ITLB only */             \
+        "mcr p15, 0, r1, c7, c5, 4;"  /* flush prefetch buffer */       \
+        "nop;" /* next few instructions may be via cache    */          \
+        "nop;"                                                          \
+        "nop;"                                                          \
+        "nop;"                                                          \
+        "nop;"                                                          \
+        "nop;"                                                          \
+        :                                                               \
+        :                                                               \
+        : "r1" /* Clobber list */                                       \
+        );                                                              \
+CYG_MACRO_END
+
+// Synchronize the contents of the cache with memory.
+// (which includes flushing out pending writes)
+#define HAL_ICACHE_SYNC()                                       \
+CYG_MACRO_START                                                 \
+    HAL_DCACHE_SYNC(); /* ensure data gets to RAM */            \
+    HAL_ICACHE_INVALIDATE_ALL(); /* forget all we know */       \
+CYG_MACRO_END
+
+// Query the state of the L2 cache
+#define HAL_L2CACHE_IS_ENABLED(_state_)                         \
+    (_state_ = readl(L2CC_BASE_ADDR + L2_CACHE_CTL_REG) & 1)
+
+#ifdef L2CC_ENABLED
+
+#define HAL_ENABLE_L2()                             \
+{                                                   \
+    writel(1, L2CC_BASE_ADDR + L2_CACHE_CTL_REG);   \
+}
+
+#define HAL_DISABLE_L2()                            \
+{                                                   \
+    writel(0, L2CC_BASE_ADDR + L2_CACHE_CTL_REG);   \
+}
+
+#define HAL_SYNC_L2()                                                           \
+{                                                                               \
+    if ((readl(L2CC_BASE_ADDR + L2_CACHE_CTL_REG) & 1) != 0) {                  \
+        writel(0, L2CC_BASE_ADDR + L2_CACHE_SYNC_REG);                          \
+        while ((readl(L2CC_BASE_ADDR + L2_CACHE_SYNC_REG) & 1) == 1);           \
+    }                                                                           \
+}
+
+#define HAL_INVALIDATE_L2()                                                     \
+{                                                                               \
+    if ((readl(L2CC_BASE_ADDR + L2_CACHE_CTL_REG) & 1) != 0) {                  \
+        writel(0xFF, L2CC_BASE_ADDR + L2_CACHE_INV_WAY_REG);                    \
+        while ((readl(L2CC_BASE_ADDR + L2_CACHE_INV_WAY_REG) & 0xFF) != 0);    \
+        HAL_SYNC_L2();                                                          \
+    }                                                                           \
+}
+                                                                                \
+#define HAL_CLEAN_INVALIDATE_L2()                                               \
+{                                                                               \
+    if ((readl(L2CC_BASE_ADDR + L2_CACHE_CTL_REG) & 1) != 0) {                  \
+        writel(0xFF, L2CC_BASE_ADDR + L2_CACHE_CLEAN_INV_WAY_REG);              \
+        while ((readl(L2CC_BASE_ADDR + L2_CACHE_CLEAN_INV_WAY_REG) & 0xFF) != 0);\
+        HAL_SYNC_L2();                                                          \
+    }                                                                           \
+}
+
+#else //L2CC_ENABLED
+
+#define HAL_ENABLE_L2()
+#define HAL_DISABLE_L2()
+#define HAL_INVALIDATE_L2()
+#define HAL_CLEAN_INVALIDATE_L2()
+#define HAL_SYNC_L2()
+#endif //L2CC_ENABLED
+
+/*********************** Exported macros *******************/
+
+#define HAL_DCACHE_ENABLE() {           \
+        HAL_DCACHE_ENABLE_L1();         \
+        HAL_ENABLE_L2();                \
+}
+
+#define HAL_DCACHE_DISABLE() {          \
+        HAL_DCACHE_DISABLE_L1();        \
+        HAL_DISABLE_L2();               \
+}
+
+#define HAL_DCACHE_INVALIDATE_ALL() {   \
+        HAL_DCACHE_INVALIDATE_ALL_L1(); \
+        HAL_CLEAN_INVALIDATE_L2();      \
+}
+
+#define HAL_DCACHE_SYNC() {             \
+        HAL_DCACHE_SYNC_L1();           \
+        /* don't just call HAL_SYNC_L2() */ \
+        HAL_CLEAN_INVALIDATE_L2();      \
+}
+
+#define HAL_ICACHE_INVALIDATE_ALL() {   \
+        HAL_ICACHE_INVALIDATE_ALL_L1(); \
+        HAL_CLEAN_INVALIDATE_L2();      \
+}
+
+#define HAL_ICACHE_DISABLE() {          \
+        HAL_ICACHE_DISABLE_L1();        \
+}                                       
+
+#define HAL_ICACHE_ENABLE() {           \
+        HAL_ICACHE_ENABLE_L1();         \
+}
+
+#endif // ifndef CYGONCE_HAL_CACHE_H
+// End of hal_cache.h
diff -urN -x CVS dummy/packages/hal/arm/mx31/var/current/include/hal_diag.h ecos_mx31/packages/hal/arm/mx31/var/current/include/hal_diag.h
--- dummy/packages/hal/arm/mx31/var/current/include/hal_diag.h	1969-12-31 18:00:00.000000000 -0600
+++ ecos_mx31/packages/hal/arm/mx31/var/current/include/hal_diag.h	2004-06-02 16:15:28.000000000 -0500
@@ -0,0 +1,83 @@
+#ifndef CYGONCE_HAL_DIAG_H
+#define CYGONCE_HAL_DIAG_H
+
+/*=============================================================================
+//
+//      hal_diag.h
+//
+//      HAL Support for Kernel Diagnostic Routines
+//
+//=============================================================================
+//####ECOSGPLCOPYRIGHTBEGIN####
+// -------------------------------------------
+// This file is part of eCos, the Embedded Configurable Operating System.
+// Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+//
+// eCos is free software; you can redistribute it and/or modify it under
+// the terms of the GNU General Public License as published by the Free
+// Software Foundation; either version 2 or (at your option) any later version.
+//
+// eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with eCos; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+//
+// As a special exception, if other files instantiate templates or use macros
+// or inline functions from this file, or you compile this file and link it
+// with other works to produce a work based on this file, this file does not
+// by itself cause the resulting work to be covered by the GNU General Public
+// License. However the source code for this file must still be made available
+// in accordance with section (3) of the GNU General Public License.
+//
+// This exception does not invalidate any other reasons why a work based on
+// this file might be covered by the GNU General Public License.
+//
+// Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+// at http://sources.redhat.com/ecos/ecos-license/
+// -------------------------------------------
+//####ECOSGPLCOPYRIGHTEND####
+//===========================================================================*/
+
+#include <pkgconf/hal.h>
+
+#include <cyg/infra/cyg_type.h>
+
+#if defined(CYGSEM_HAL_VIRTUAL_VECTOR_DIAG)
+
+#include <cyg/hal/hal_if.h>
+
+#define HAL_DIAG_INIT() hal_if_diag_init()
+#define HAL_DIAG_WRITE_CHAR(_c_) hal_if_diag_write_char(_c_)
+#define HAL_DIAG_READ_CHAR(_c_) hal_if_diag_read_char(&_c_)
+
+#else // everything by steam
+
+/*---------------------------------------------------------------------------*/
+/* functions implemented in hal_diag.c                                       */
+
+externC void hal_diag_init(void);
+externC void hal_diag_write_char(char c);
+externC void hal_diag_read_char(char *c);
+
+/*---------------------------------------------------------------------------*/
+
+#define HAL_DIAG_INIT() hal_diag_init()
+
+#define HAL_DIAG_WRITE_CHAR(_c_) hal_diag_write_char(_c_)
+
+#define HAL_DIAG_READ_CHAR(_c_) hal_diag_read_char(&_c_)
+
+#endif // CYGSEM_HAL_VIRTUAL_VECTOR_DIAG
+
+/*---------------------------------------------------------------------------*/
+// LED
+
+externC void hal_diag_led(int n);
+
+/*---------------------------------------------------------------------------*/
+/* end of hal_diag.h                                                         */
+#endif /* CYGONCE_HAL_DIAG_H */
diff -urN -x CVS dummy/packages/hal/arm/mx31/var/current/include/hal_mm.h ecos_mx31/packages/hal/arm/mx31/var/current/include/hal_mm.h
--- dummy/packages/hal/arm/mx31/var/current/include/hal_mm.h	1969-12-31 18:00:00.000000000 -0600
+++ ecos_mx31/packages/hal/arm/mx31/var/current/include/hal_mm.h	2006-04-19 17:17:11.000000000 -0500
@@ -0,0 +1,176 @@
+#ifndef CYGONCE_HAL_MM_H
+#define CYGONCE_HAL_MM_H
+
+//=============================================================================
+//
+//      hal_mm.h
+//
+//=============================================================================
+//####ECOSGPLCOPYRIGHTBEGIN####
+// -------------------------------------------
+// This file is part of eCos, the Embedded Configurable Operating System.
+// Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+//
+// eCos is free software; you can redistribute it and/or modify it under
+// the terms of the GNU General Public License as published by the Free
+// Software Foundation; either version 2 or (at your option) any later version.
+//
+// eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with eCos; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+//
+// As a special exception, if other files instantiate templates or use macros
+// or inline functions from this file, or you compile this file and link it
+// with other works to produce a work based on this file, this file does not
+// by itself cause the resulting work to be covered by the GNU General Public
+// License. However the source code for this file must still be made available
+// in accordance with section (3) of the GNU General Public License.
+//
+// This exception does not invalidate any other reasons why a work based on
+// this file might be covered by the GNU General Public License.
+//
+// Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+// at http://sources.redhat.com/ecos/ecos-license/
+// -------------------------------------------
+//####ECOSGPLCOPYRIGHTEND####
+//=============================================================================
+// -------------------------------------------------------------------------
+// MMU initialization:
+//
+// These structures are laid down in memory to define the translation
+// table.
+//
+
+/*
+ * Translation Table Base Bit Masks
+ */
+#define ARM_TRANSLATION_TABLE_MASK               0xFFFFC000
+
+/*
+ * Domain Access Control Bit Masks
+ */
+#define ARM_ACCESS_TYPE_NO_ACCESS(domain_num)    (0x0 << (domain_num)*2)
+#define ARM_ACCESS_TYPE_CLIENT(domain_num)       (0x1 << (domain_num)*2)
+#define ARM_ACCESS_TYPE_MANAGER(domain_num)      (0x3 << (domain_num)*2)
+
+struct ARM_MMU_FIRST_LEVEL_FAULT {
+        unsigned int id : 2;
+        unsigned int sbz : 30;
+};
+
+#define ARM_MMU_FIRST_LEVEL_FAULT_ID 0x0
+
+struct ARM_MMU_FIRST_LEVEL_PAGE_TABLE {
+        unsigned int id : 2;
+        unsigned int imp : 2;
+        unsigned int domain : 4;
+        unsigned int sbz : 1;
+        unsigned int base_address : 23;
+};
+
+#define ARM_MMU_FIRST_LEVEL_PAGE_TABLE_ID 0x1
+
+struct ARM_MMU_FIRST_LEVEL_SECTION {
+        unsigned int id : 2;
+        unsigned int b : 1;
+        unsigned int c : 1;
+        unsigned int imp : 1;
+        unsigned int domain : 4;
+        unsigned int sbz0 : 1;
+        unsigned int ap : 2;
+        unsigned int sbz1 : 8;
+        unsigned int base_address : 12;
+};
+
+#define ARM_MMU_FIRST_LEVEL_SECTION_ID 0x2
+
+struct ARM_MMU_FIRST_LEVEL_RESERVED {
+        unsigned int id : 2;
+        unsigned int sbz : 30;
+};
+
+#define ARM_MMU_FIRST_LEVEL_RESERVED_ID 0x3
+
+#define ARM_MMU_FIRST_LEVEL_DESCRIPTOR_ADDRESS(ttb_base, table_index) \
+        (unsigned long *)((unsigned long)(ttb_base) + ((table_index) << 2))
+
+#define ARM_FIRST_LEVEL_PAGE_TABLE_SIZE 0x4000
+
+#define ARM_MMU_SECTION(ttb_base, actual_base, virtual_base,              \
+                        cacheable, bufferable, perm)                      \
+    CYG_MACRO_START                                                       \
+        register union ARM_MMU_FIRST_LEVEL_DESCRIPTOR desc;               \
+                                                                          \
+        desc.word = 0;                                                    \
+        desc.section.id = ARM_MMU_FIRST_LEVEL_SECTION_ID;                 \
+        desc.section.domain = 0;                                          \
+        desc.section.c = (cacheable);                                     \
+        desc.section.b = (bufferable);                                    \
+        desc.section.ap = (perm);                                         \
+        desc.section.base_address = (actual_base);                        \
+        *ARM_MMU_FIRST_LEVEL_DESCRIPTOR_ADDRESS(ttb_base, (virtual_base)) \
+                            = desc.word;                                  \
+    CYG_MACRO_END
+
+#define X_ARM_MMU_SECTION(abase,vbase,size,cache,buff,access)                 \
+      {                                                            \
+        int i; int j = abase; int k = vbase;                              \
+        for (i = size; i > 0 ; i--,j++,k++) {                             \
+        ARM_MMU_SECTION(ttb_base, j, k, cache, buff, access);      \
+      }                                                            \
+    }
+
+union ARM_MMU_FIRST_LEVEL_DESCRIPTOR {
+        unsigned long word;
+        struct ARM_MMU_FIRST_LEVEL_FAULT fault;
+        struct ARM_MMU_FIRST_LEVEL_PAGE_TABLE page_table;
+        struct ARM_MMU_FIRST_LEVEL_SECTION section;
+        struct ARM_MMU_FIRST_LEVEL_RESERVED reserved;
+};
+
+#define ARM_UNCACHEABLE                         0
+#define ARM_CACHEABLE                           1
+#define ARM_UNBUFFERABLE                        0
+#define ARM_BUFFERABLE                          1
+
+#define ARM_ACCESS_PERM_NONE_NONE               0
+#define ARM_ACCESS_PERM_RO_NONE                 0
+#define ARM_ACCESS_PERM_RO_RO                   0
+#define ARM_ACCESS_PERM_RW_NONE                 1
+#define ARM_ACCESS_PERM_RW_RO                   2
+#define ARM_ACCESS_PERM_RW_RW                   3
+
+/*
+ * Initialization for the Domain Access Control Register
+ */
+#define ARM_ACCESS_DACR_DEFAULT      (          \
+        ARM_ACCESS_TYPE_MANAGER(0)    |         \
+        ARM_ACCESS_TYPE_NO_ACCESS(1)  |         \
+        ARM_ACCESS_TYPE_NO_ACCESS(2)  |         \
+        ARM_ACCESS_TYPE_NO_ACCESS(3)  |         \
+        ARM_ACCESS_TYPE_NO_ACCESS(4)  |         \
+        ARM_ACCESS_TYPE_NO_ACCESS(5)  |         \
+        ARM_ACCESS_TYPE_NO_ACCESS(6)  |         \
+        ARM_ACCESS_TYPE_NO_ACCESS(7)  |         \
+        ARM_ACCESS_TYPE_NO_ACCESS(8)  |         \
+        ARM_ACCESS_TYPE_NO_ACCESS(9)  |         \
+        ARM_ACCESS_TYPE_NO_ACCESS(10) |         \
+        ARM_ACCESS_TYPE_NO_ACCESS(11) |         \
+        ARM_ACCESS_TYPE_NO_ACCESS(12) |         \
+        ARM_ACCESS_TYPE_NO_ACCESS(13) |         \
+        ARM_ACCESS_TYPE_NO_ACCESS(14) |         \
+        ARM_ACCESS_TYPE_NO_ACCESS(15) )
+
+// ------------------------------------------------------------------------
+#endif // ifndef CYGONCE_HAL_MM_H
+// End of hal_mm.h
+
+
+
+
+
diff -urN -x CVS dummy/packages/hal/arm/mx31/var/current/include/hal_soc.h ecos_mx31/packages/hal/arm/mx31/var/current/include/hal_soc.h
--- dummy/packages/hal/arm/mx31/var/current/include/hal_soc.h	1969-12-31 18:00:00.000000000 -0600
+++ ecos_mx31/packages/hal/arm/mx31/var/current/include/hal_soc.h	2008-04-02 14:36:06.000000000 -0500
@@ -0,0 +1,475 @@
+//==========================================================================
+//
+//      hal_soc.h
+//
+//      SoC chip definitions
+//
+//==========================================================================
+//####ECOSGPLCOPYRIGHTBEGIN####
+// -------------------------------------------
+// This file is part of eCos, the Embedded Configurable Operating System.
+// Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+// Copyright (C) 2002 Gary Thomas
+//
+// eCos is free software; you can redistribute it and/or modify it under
+// the terms of the GNU General Public License as published by the Free
+// Software Foundation; either version 2 or (at your option) any later version.
+//
+// eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with eCos; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+//
+// As a special exception, if other files instantiate templates or use macros
+// or inline functions from this file, or you compile this file and link it
+// with other works to produce a work based on this file, this file does not
+// by itself cause the resulting work to be covered by the GNU General Public
+// License. However the source code for this file must still be made available
+// in accordance with section (3) of the GNU General Public License.
+//
+// This exception does not invalidate any other reasons why a work based on
+// this file might be covered by the GNU General Public License.
+//
+// Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+// at http://sources.redhat.com/ecos/ecos-license/
+// -------------------------------------------
+//####ECOSGPLCOPYRIGHTEND####
+//========================================================================*/
+
+#ifndef __HAL_SOC_H__
+#define __HAL_SOC_H__
+
+#ifdef __ASSEMBLER__
+
+#define REG8_VAL(a)          (a)
+#define REG16_VAL(a)         (a)
+#define REG32_VAL(a)         (a)
+
+#define REG8_PTR(a)          (a)
+#define REG16_PTR(a)         (a)
+#define REG32_PTR(a)         (a)
+
+#else /* __ASSEMBLER__ */
+
+extern char HAL_PLATFORM_EXTRA[];
+#define REG8_VAL(a)          ((unsigned char)(a))
+#define REG16_VAL(a)         ((unsigned short)(a))
+#define REG32_VAL(a)         ((unsigned int)(a))
+
+#define REG8_PTR(a)          ((volatile unsigned char *)(a))
+#define REG16_PTR(a)         ((volatile unsigned short *)(a))
+#define REG32_PTR(a)         ((volatile unsigned int *)(a))
+#define readb(a)             (*(volatile unsigned char *)(a))
+#define readw(a)             (*(volatile unsigned short *)(a))
+#define readl(a)             (*(volatile unsigned int *)(a))
+#define writeb(v,a)          (*(volatile unsigned char *)(a) = (v))
+#define writew(v,a)          (*(volatile unsigned short *)(a) = (v))
+#define writel(v,a)          (*(volatile unsigned int *)(a) = (v))
+
+#endif /* __ASSEMBLER__ */
+
+/*
+ * Default Memory Layout Definitions
+ */
+
+#define L2CC_BASE_ADDR          0x30000000
+
+/*
+ * AIPS 1
+ */
+#define AIPS1_BASE_ADDR         0x43F00000
+#define AIPS1_CTRL_BASE_ADDR    AIPS1_BASE_ADDR
+#define MAX_BASE_ADDR           0x43F04000
+#define EVTMON_BASE_ADDR        0x43F08000
+#define CLKCTL_BASE_ADDR        0x43F0C000
+#define ETB_SLOT4_BASE_ADDR     0x43F10000
+#define ETB_SLOT5_BASE_ADDR     0x43F14000
+#define ECT_CTIO_BASE_ADDR      0x43F18000
+#define I2C_BASE_ADDR           0x43F80000
+#define I2C3_BASE_ADDR          0x43F84000
+#define OTG_BASE_ADDR           0x43F88000
+#define ATA_BASE_ADDR           0x43F8C000
+#define UART1_BASE_ADDR         0x43F90000
+#define UART2_BASE_ADDR         0x43F94000
+#define I2C2_BASE_ADDR          0x43F98000
+#define OWIRE_BASE_ADDR         0x43F9C000
+#define SSI1_BASE_ADDR          0x43FA0000
+#define CSPI1_BASE_ADDR         0x43FA4000
+#define KPP_BASE_ADDR           0x43FA8000
+#define IOMUXC_BASE_ADDR        0x43FAC000
+#define UART4_BASE_ADDR         0x43FB0000
+#define UART5_BASE_ADDR         0x43FB4000
+#define ECT_IP1_BASE_ADDR       0x43FB8000
+#define ECT_IP2_BASE_ADDR       0x43FBC000
+
+/*
+ * SPBA
+ */
+#define SPBA_BASE_ADDR          0x50000000
+#define MMC_SDHC1_BASE_ADDR     0x50004000
+#define MMC_SDHC2_BASE_ADDR     0x50008000
+#define UART3_BASE_ADDR         0x5000C000
+#define CSPI2_BASE_ADDR         0x50010000
+#define SSI2_BASE_ADDR          0x50014000
+#define SIM_BASE_ADDR           0x50018000
+#define IIM_BASE_ADDR           0x5001C000
+#define ATA_DMA_BASE_ADDR       0x50020000
+#define SPBA_CTRL_BASE_ADDR     0x5003C000
+
+/*
+ * AIPS 2
+ */
+#define AIPS2_BASE_ADDR         0x53F00000
+#define AIPS2_CTRL_BASE_ADDR    AIPS2_BASE_ADDR
+#define CCM_BASE_ADDR           0x53F80000
+#define FIRI_BASE_ADDR          0x53F8C000
+#define GPT1_BASE_ADDR          0x53F90000
+#define EPIT1_BASE_ADDR         0x53F94000
+#define EPIT2_BASE_ADDR         0x53F98000
+#define GPIO3_BASE_ADDR         0x53FA4000
+#define SCC_BASE                0x53FAC000
+#define SCM_BASE                0x53FAE000
+#define SMN_BASE                0x53FAF000
+#define RNGA_BASE_ADDR          0x53FB0000
+#define IPU_CTRL_BASE_ADDR      0x53FC0000
+#define AUDMUX_BASE             0x53FC4000
+#define MPEG4_ENC_BASE          0x53FC8000
+#define GPIO1_BASE_ADDR         0x53FCC000
+#define GPIO2_BASE_ADDR         0x53FD0000
+#define SDMA_BASE_ADDR          0x53FD4000
+#define RTC_BASE_ADDR           0x53FD8000
+#define WDOG_BASE_ADDR          0x53FDC000
+#define PWM_BASE_ADDR           0x53FE0000
+#define RTIC_BASE_ADDR          0x53FEC000
+
+/*
+ * ROMPATCH and AVIC
+ */
+#define ROMPATCH_BASE_ADDR      0x60000000
+#define AVIC_BASE_ADDR          0x68000000
+
+/*
+ * NAND, SDRAM, WEIM, M3IF, EMI controllers
+ */
+#define EXT_MEM_CTRL_BASE       0xB8000000
+#define NFC_BASE                EXT_MEM_CTRL_BASE
+#define ESDCTL_BASE             0xB8001000
+#define WEIM_BASE_ADDR          0xB8002000
+#define WEIM_CTRL_CS0           WEIM_BASE_ADDR
+#define WEIM_CTRL_CS1           (WEIM_BASE_ADDR + 0x10)
+#define WEIM_CTRL_CS2           (WEIM_BASE_ADDR + 0x20)
+#define WEIM_CTRL_CS3           (WEIM_BASE_ADDR + 0x30)
+#define WEIM_CTRL_CS4           (WEIM_BASE_ADDR + 0x40)
+#define WEIM_CTRL_CS5           (WEIM_BASE_ADDR + 0x50)
+#define M3IF_BASE               0xB8003000
+#define PCMCIA_CTL_BASE         0xB8004000
+
+/*
+ * Memory regions and CS
+ */
+#define IPU_MEM_BASE_ADDR       0x70000000
+#define CSD0_BASE_ADDR          0x80000000
+#define CSD1_BASE_ADDR          0x90000000
+#define CS0_BASE_ADDR           0xA0000000
+#define CS1_BASE_ADDR           0xA8000000
+#define CS2_BASE_ADDR           0xB0000000
+#define CS3_BASE_ADDR           0xB2000000
+#define CS4_BASE_ADDR           0xB4000000
+#define CS4_BASE_PSRAM          0xB5000000
+#define CS5_BASE_ADDR           0xB6000000
+#define PCMCIA_MEM_BASE_ADDR    0xC0000000
+
+#define INTERNAL_ROM_VA         0xF0000000
+
+/*
+ * IRQ Controller Register Definitions.
+ */
+#define AVIC_NIMASK                     REG32_PTR(AVIC_BASE_ADDR + (0x04))
+#define AVIC_INTTYPEH                   REG32_PTR(AVIC_BASE_ADDR + (0x18))
+#define AVIC_INTTYPEL                   REG32_PTR(AVIC_BASE_ADDR + (0x1C))
+
+/* L210 */
+#define L2_CACHE_LINE_SIZE              32
+#define L2_CACHE_CTL_REG                0x100
+#define L2_CACHE_AUX_CTL_REG            0x104
+#define L2_CACHE_SYNC_REG               0x730
+#define L2_CACHE_INV_LINE_REG           0x770
+#define L2_CACHE_INV_WAY_REG            0x77C
+#define L2_CACHE_CLEAN_LINE_PA_REG      0x7B0
+#define L2_CACHE_CLEAN_LINE_WAY_REG     0x7B8
+#define L2_CACHE_CLEAN_WAY_REG          0x7BC
+#define L2_CACHE_CLEAN_INV_LINE_PA_REG  0x7F0
+#define L2_CACHE_CLEAN_INV_LINE_WAY_REG 0x7F8
+#define L2_CACHE_CLEAN_INV_WAY_REG      0x7FC
+
+/* CCM */
+#define CLKCTL_CCMR                     0x00
+#define CLKCTL_PDR0                     0x04
+#define CLKCTL_PDR1                     0x08
+#define CLKCTL_PDR2                     0x64
+#define CLKCTL_RCSR                     0x0C
+#define CLKCTL_MPCTL                    0x10
+#define CLKCTL_UPCTL                    0x14
+#define CLKCTL_SPCTL                    0x18
+#define CLKCTL_COSR                     0x1C
+#define FREQ_26MHZ                      26000000
+#define FREQ_27MHZ                      27000000
+#define FREQ_32768HZ                    (32768 * 512)
+#define FREQ_32000HZ                    (32000 * 512)
+#define PLL_REF_CLK                     FREQ_26MHZ
+//#define PLL_REF_CLK  FREQ_32768HZ
+//#define PLL_REF_CLK  FREQ_32000HZ
+
+/* WEIM - CS0 */
+#define CSCRU                           0x00
+#define CSCRL                           0x04
+#define CSCRA                           0x08
+#define CHIP_REV_1_0            0x0      /* PASS 1.0 */
+#define CHIP_REV_1_1            0x1      /* PASS 1.1 */
+#define CHIP_REV_2_0            0x2      /* PASS 2.0 */
+#define CHIP_LATEST             CHIP_REV_1_1
+
+#define IIM_STAT_OFF            0x00
+#define IIM_STAT_BUSY           (1 << 7)
+#define IIM_STAT_PRGD           (1 << 1)
+#define IIM_STAT_SNSD           (1 << 0)
+#define IIM_STATM_OFF           0x04
+#define IIM_ERR_OFF             0x08
+#define IIM_ERR_PRGE            (1 << 7)
+#define IIM_ERR_WPE         (1 << 6)
+#define IIM_ERR_OPE         (1 << 5)
+#define IIM_ERR_RPE         (1 << 4)
+#define IIM_ERR_WLRE        (1 << 3)
+#define IIM_ERR_SNSE        (1 << 2)
+#define IIM_ERR_PARITYE     (1 << 1)
+#define IIM_EMASK_OFF           0x0C
+#define IIM_FCTL_OFF            0x10
+#define IIM_UA_OFF              0x14
+#define IIM_LA_OFF              0x18
+#define IIM_SDAT_OFF            0x1C
+#define IIM_PREV_OFF            0x20
+#define IIM_SREV_OFF            0x24
+#define IIM_PREG_P_OFF          0x28
+#define IIM_SCS0_OFF            0x2C
+#define IIM_SCS1_P_OFF          0x30
+#define IIM_SCS2_OFF            0x34
+#define IIM_SCS3_P_OFF          0x38
+
+#define EPIT_BASE_ADDR          EPIT1_BASE_ADDR
+#define EPITCR                  0x00
+#define EPITSR                  0x04
+#define EPITLR                  0x08
+#define EPITCMPR                0x0C
+#define EPITCNR                 0x10
+
+#define GPT_BASE_ADDR           GPT1_BASE_ADDR
+#define GPTCR                   0x00
+#define GPTPR                   0x04
+#define GPTSR                   0x08
+#define GPTIR                   0x0C
+#define GPTOCR1                 0x10
+#define GPTOCR2                 0x14
+#define GPTOCR3                 0x18
+#define GPTICR1                 0x1C
+#define GPTICR2                 0x20
+#define GPTCNT                  0x24
+
+/* ESDCTL */
+#define ESDCTL_ESDCTL0                  0x00
+#define ESDCTL_ESDCFG0                  0x04
+#define ESDCTL_ESDCTL1                  0x08
+#define ESDCTL_ESDCFG1                  0x0C
+#define ESDCTL_ESDMISC                  0x10
+
+#if (PLL_REF_CLK != 26000000)
+#error Wrong PLL reference clock! The following macros will not work.
+#endif
+
+/* Assuming 26MHz input clock */
+/*                            PD             MFD              MFI          MFN */
+#define MPCTL_PARAM_208     (((2-1) << 26) + ((1 -1) << 16) + (8  << 10) + (0  << 0))
+#define MPCTL_PARAM_399     (((1-1) << 26) + ((52-1) << 16) + (7  << 10) + (35 << 0))
+#define MPCTL_PARAM_532     (((1-1) << 26) + ((52-1) << 16) + (10 << 10) + (12 << 0))
+#define MPCTL_PARAM_665     (((1-1) << 26) + ((52-1) << 16) + (12 << 10) + (41 << 0))
+#define MPCTL_PARAM_532_27  (((1-1) << 26) + ((15-1) << 16) + (9  << 10) + (13 << 0))
+
+/* UPCTL                      PD             MFD              MFI          MFN */
+#define UPCTL_PARAM_288     (((1-1) << 26) + ((13-1) << 16) + (5  << 10) + (7  << 0))
+#define UPCTL_PARAM_240     (((2-1) << 26) + ((13-1) << 16) + (9  << 10) + (3  << 0))
+#define UPCTL_PARAM_240_27  (((2-1) << 26) + ((9 -1) << 16) + (8  << 10) + (8  << 0))
+
+/* SPCTL                      PD             MFD              MFI          MFN */
+#define SPCTL_PARAM_399     (((1-1) << 26) + ((52-1) << 16) + (7  << 10) + (35 << 0))
+#define SPCTL_PARAM_399_27  (((1-1) << 26) + ((5-1)  << 16) + (7  << 10) + (2  << 0))
+
+/* PDR0 */
+#define PDR0_208_104_52     0xFF870D48  /* ARM=208MHz, HCLK=104MHz, IPG=52MHz */
+#define PDR0_399_66_66      0xFF872B28  /* ARM=399MHz, HCLK=IPG=66.5MHz */
+#define PDR0_399_133_66     0xFF871650  /* ARM=399MHz, HCLK=133MHz, IPG=66.5MHz */
+#define PDR0_532_133_66     0xFF871D58  /* ARM=532MHz, HCLK=133MHz, IPG=66MHz */
+#define PDR0_665_83_42      0xFF873B78  /* ARM=665MHz, HCLK=83MHz, IPG=42MHz */
+#define PDR0_665_133_66     0xFF872560  /* ARM=665MHz, HCLK=133MHz, IPG=66MHz */
+
+#define NAND_REG_BASE                   (NFC_BASE + 0xE00)
+#define NFC_BUFSIZE_REG_OFF             (0 + 0x00)
+#define RAM_BUFFER_ADDRESS_REG_OFF      (0 + 0x04)
+#define NAND_FLASH_ADD_REG_OFF          (0 + 0x06)
+#define NAND_FLASH_CMD_REG_OFF          (0 + 0x08)
+#define NFC_CONFIGURATION_REG_OFF       (0 + 0x0A)
+#define ECC_STATUS_RESULT_REG_OFF       (0 + 0x0C)
+#define ECC_RSLT_MAIN_AREA_REG_OFF      (0 + 0x0E)
+#define ECC_RSLT_SPARE_AREA_REG_OFF     (0 + 0x10)
+#define NF_WR_PROT_REG_OFF              (0 + 0x12)
+#define UNLOCK_START_BLK_ADD_REG_OFF    (0 + 0x14)
+#define UNLOCK_END_BLK_ADD_REG_OFF      (0 + 0x16)
+#define NAND_FLASH_WR_PR_ST_REG_OFF     (0 + 0x18)
+#define NAND_FLASH_CONFIG1_REG_OFF      (0 + 0x1A)
+#define NAND_FLASH_CONFIG2_REG_OFF      (0 + 0x1C)
+#define RAM_BUFFER_ADDRESS_RBA_3        0x3
+#define NFC_BUFSIZE_1KB                 0x0
+#define NFC_BUFSIZE_2KB                 0x1
+#define NFC_CONFIGURATION_UNLOCKED      0x2
+#define ECC_STATUS_RESULT_NO_ERR        0x0
+#define ECC_STATUS_RESULT_1BIT_ERR      0x1
+#define ECC_STATUS_RESULT_2BIT_ERR      0x2
+#define NF_WR_PROT_UNLOCK               0x4
+#define NAND_FLASH_CONFIG1_FORCE_CE     (1 << 7)
+#define NAND_FLASH_CONFIG1_RST          (1 << 6)
+#define NAND_FLASH_CONFIG1_BIG          (1 << 5)
+#define NAND_FLASH_CONFIG1_INT_MSK      (1 << 4)
+#define NAND_FLASH_CONFIG1_ECC_EN       (1 << 3)
+#define NAND_FLASH_CONFIG1_SP_EN        (1 << 2)
+#define NAND_FLASH_CONFIG2_INT_DONE     (1 << 15)
+#define NAND_FLASH_CONFIG2_FDO_PAGE     (0 << 3)
+#define NAND_FLASH_CONFIG2_FDO_ID       (2 << 3)
+#define NAND_FLASH_CONFIG2_FDO_STATUS   (4 << 3)
+#define NAND_FLASH_CONFIG2_FDI_EN       (1 << 2)
+#define NAND_FLASH_CONFIG2_FADD_EN      (1 << 1)
+#define NAND_FLASH_CONFIG2_FCMD_EN      (1 << 0)
+#define FDO_PAGE_SPARE_VAL              0x8
+
+#define NOR_FLASH_BOOT                  0
+#define NAND_FLASH_BOOT                 0x10000000
+#define SDRAM_NON_FLASH_BOOT            0x20000000
+#define MXCBOOT_FLAG_REG                (AVIC_BASE_ADDR + 0x100)
+#define MXCFIS_NOTHING                  0x00000000
+#define MXCFIS_NAND                     0x10000000
+#define MXCFIS_NOR                      0x20000000
+#define MXCFIS_FLAG_REG                 (AVIC_BASE_ADDR + 0x104)
+
+#define IS_BOOTING_FROM_NAND()          (readl(MXCBOOT_FLAG_REG) == NAND_FLASH_BOOT)
+#define IS_BOOTING_FROM_NOR()           (readl(MXCBOOT_FLAG_REG) == NOR_FLASH_BOOT)
+#define IS_BOOTING_FROM_SDRAM()         (readl(MXCBOOT_FLAG_REG) == SDRAM_NON_FLASH_BOOT)
+
+#ifndef MXCFLASH_SELECT_NAND
+#define IS_FIS_FROM_NAND()              0
+#else
+#define IS_FIS_FROM_NAND()              (readl(MXCFIS_FLAG_REG) == MXCFIS_NAND)
+#endif
+
+#ifndef MXCFLASH_SELECT_NOR
+#define IS_FIS_FROM_NOR()               0
+#else
+#define IS_FIS_FROM_NOR()               (!IS_FIS_FROM_NAND())
+#endif
+
+#define MXC_ASSERT_NOR_BOOT()           writel(MXCFIS_NOR, MXCFIS_FLAG_REG)
+#define MXC_ASSERT_NAND_BOOT()          writel(MXCFIS_NAND, MXCFIS_FLAG_REG)
+
+/*
+ * This macro is used to get certain bit field from a number
+ */
+#define MXC_GET_FIELD(val, len, sh)          ((val >> sh) & ((1 << len) - 1))
+
+/*
+ * This macro is used to set certain bit field inside a number
+ */
+#define MXC_SET_FIELD(val, len, sh, nval)    ((val & ~(((1 << len) - 1) << sh)) | (nval << sh))
+
+#define L2CC_ENABLED
+#define UART_WIDTH_32         /* internal UART is 32bit access only */
+
+#if !defined(__ASSEMBLER__)
+void cyg_hal_plf_serial_init(void);
+void cyg_hal_plf_serial_stop(void);
+void hal_delay_us(unsigned int usecs);
+#define HAL_DELAY_US(n)     hal_delay_us(n)
+
+enum plls {
+        MCU_PLL = CCM_BASE_ADDR + CLKCTL_MPCTL,
+        USB_PLL = CCM_BASE_ADDR + CLKCTL_UPCTL,
+        SER_PLL = CCM_BASE_ADDR + CLKCTL_SPCTL,
+};
+
+enum main_clocks {
+        CPU_CLK,
+        AHB_CLK,
+        MBX_CLK,
+        IPG_CLK,
+        IPG_PER_CLK,
+        NFC_CLK,
+        USB_CLK,
+        HSP_CLK,
+};
+
+enum peri_clocks {
+        UART1_BAUD,
+        UART2_BAUD,
+        UART3_BAUD,
+        UART4_BAUD,
+        UART5_BAUD,
+        FIRI_BAUD,
+        SIM_BAUD,
+        SSI1_BAUD,
+        SSI2_BAUD,
+        CSI_BAUD,
+        MSTICK1_CLK,
+        MSTICK2_CLK,
+        SPI1_CLK = CSPI1_BASE_ADDR,
+        SPI2_CLK = CSPI2_BASE_ADDR,
+};
+
+unsigned int pll_clock(enum plls pll);
+
+unsigned int get_main_clock(enum main_clocks clk);
+
+unsigned int get_peri_clock(enum peri_clocks clk);
+
+enum {
+    MXC_NFC_V1,
+    MXC_NFC_V2,
+};
+
+enum {
+    BOARD_TYPE_UNKNOWN,
+    BOARD_TYPE_ADS,
+    BOARD_TYPE_3STACK,
+};
+
+typedef unsigned int nfc_setup_func_t(unsigned int, unsigned int, unsigned int);
+
+#endif //#if !defined(__ASSEMBLER__)
+
+#define HAL_MMU_OFF() \
+CYG_MACRO_START          \
+    asm volatile (                                                      \
+        "mcr p15, 0, r0, c7, c14, 0;"                                   \
+        "mcr p15, 0, r0, c7, c10, 4;" /* drain the write buffer */      \
+        "mcr p15, 0, r0, c7, c5, 0;" /* invalidate I cache */           \
+        "mrc p15, 0, r0, c1, c0, 0;" /* read c1 */                      \
+        "bic r0, r0, #0x7;" /* disable DCache and MMU */                \
+        "bic r0, r0, #0x1000;" /* disable ICache */                     \
+        "mcr p15, 0, r0, c1, c0, 0;" /*  */                             \
+        "nop;" /* flush i+d-TLBs */                                     \
+        "nop;" /* flush i+d-TLBs */                                     \
+        "nop;" /* flush i+d-TLBs */                                     \
+        :                                                               \
+        :                                                               \
+        : "r0","memory" /* clobber list */);                            \
+CYG_MACRO_END
+
+#endif /* __HAL_SOC_H__ */
diff -urN -x CVS dummy/packages/hal/arm/mx31/var/current/include/hal_var_ints.h ecos_mx31/packages/hal/arm/mx31/var/current/include/hal_var_ints.h
--- dummy/packages/hal/arm/mx31/var/current/include/hal_var_ints.h	1969-12-31 18:00:00.000000000 -0600
+++ ecos_mx31/packages/hal/arm/mx31/var/current/include/hal_var_ints.h	2006-02-09 15:23:01.000000000 -0600
@@ -0,0 +1,127 @@
+#ifndef CYGONCE_HAL_VAR_INTS_H
+#define CYGONCE_HAL_VAR_INTS_H
+//==========================================================================
+//
+//      hal_var_ints.h
+//
+//      HAL Interrupt and clock support
+//
+//==========================================================================
+//####ECOSGPLCOPYRIGHTBEGIN####
+// -------------------------------------------
+// This file is part of eCos, the Embedded Configurable Operating System.
+// Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+//
+// eCos is free software; you can redistribute it and/or modify it under
+// the terms of the GNU General Public License as published by the Free
+// Software Foundation; either version 2 or (at your option) any later version.
+//
+// eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with eCos; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+//
+// As a special exception, if other files instantiate templates or use macros
+// or inline functions from this file, or you compile this file and link it
+// with other works to produce a work based on this file, this file does not
+// by itself cause the resulting work to be covered by the GNU General Public
+// License. However the source code for this file must still be made available
+// in accordance with section (3) of the GNU General Public License.
+//
+// This exception does not invalidate any other reasons why a work based on
+// this file might be covered by the GNU General Public License.
+//
+// Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+// at http://sources.redhat.com/ecos/ecos-license/
+// -------------------------------------------
+//####ECOSGPLCOPYRIGHTEND####
+//==========================================================================
+
+#include <cyg/hal/hal_soc.h>         // registers
+
+#define CYGNUM_HAL_INTERRUPT_GPIO0   0
+#define CYGNUM_HAL_INTERRUPT_GPIO1   1
+#define CYGNUM_HAL_INTERRUPT_GPIO2   2
+#define CYGNUM_HAL_INTERRUPT_GPIO3   3
+#define CYGNUM_HAL_INTERRUPT_GPIO4   4
+#define CYGNUM_HAL_INTERRUPT_GPIO5   5
+#define CYGNUM_HAL_INTERRUPT_GPIO6   6
+#define CYGNUM_HAL_INTERRUPT_GPIO7   7
+#define CYGNUM_HAL_INTERRUPT_GPIO8   8
+#define CYGNUM_HAL_INTERRUPT_GPIO9   9
+#define CYGNUM_HAL_INTERRUPT_GPIO10  10
+#define CYGNUM_HAL_INTERRUPT_GPIO    11  // Don't use directly!
+#define CYGNUM_HAL_INTERRUPT_LCD     12
+#define CYGNUM_HAL_INTERRUPT_UDC     13
+#define CYGNUM_HAL_INTERRUPT_UART1   15
+#define CYGNUM_HAL_INTERRUPT_UART2   16
+#define CYGNUM_HAL_INTERRUPT_UART3   17
+#define CYGNUM_HAL_INTERRUPT_UART4   17
+#define CYGNUM_HAL_INTERRUPT_MCP     18
+#define CYGNUM_HAL_INTERRUPT_SSP     19
+#define CYGNUM_HAL_INTERRUPT_TIMER0  26
+#define CYGNUM_HAL_INTERRUPT_TIMER1  27
+#define CYGNUM_HAL_INTERRUPT_TIMER2  28
+#define CYGNUM_HAL_INTERRUPT_TIMER3  29
+#define CYGNUM_HAL_INTERRUPT_HZ      30
+#define CYGNUM_HAL_INTERRUPT_ALARM   31
+
+// GPIO bits 31..11 can generate interrupts as well, but they all
+// end up clumped into interrupt signal #11.  Using the symbols
+// below allow for detection of these separately.
+
+#define CYGNUM_HAL_INTERRUPT_GPIO11  (32+11)
+#define CYGNUM_HAL_INTERRUPT_GPIO12  (32+12)
+#define CYGNUM_HAL_INTERRUPT_GPIO13  (32+13)
+#define CYGNUM_HAL_INTERRUPT_GPIO14  (32+14)
+#define CYGNUM_HAL_INTERRUPT_GPIO15  (32+15)
+#define CYGNUM_HAL_INTERRUPT_GPIO16  (32+16)
+#define CYGNUM_HAL_INTERRUPT_GPIO17  (32+17)
+#define CYGNUM_HAL_INTERRUPT_GPIO18  (32+18)
+#define CYGNUM_HAL_INTERRUPT_GPIO19  (32+19)
+#define CYGNUM_HAL_INTERRUPT_GPIO20  (32+20)
+#define CYGNUM_HAL_INTERRUPT_GPIO21  (32+21)
+#define CYGNUM_HAL_INTERRUPT_GPIO22  (32+22)
+#define CYGNUM_HAL_INTERRUPT_GPIO23  (32+23)
+#define CYGNUM_HAL_INTERRUPT_GPIO24  (32+24)
+#define CYGNUM_HAL_INTERRUPT_GPIO25  (32+25)
+#define CYGNUM_HAL_INTERRUPT_GPIO26  (32+26)
+#define CYGNUM_HAL_INTERRUPT_GPIO27  (32+27)
+
+#define CYGNUM_HAL_INTERRUPT_NONE    -1
+
+#define CYGNUM_HAL_ISR_MIN            0
+#define CYGNUM_HAL_ISR_MAX           (27+32)
+
+#define CYGNUM_HAL_ISR_COUNT         (CYGNUM_HAL_ISR_MAX+1)
+
+// The vector used by the Real time clock
+#define CYGNUM_HAL_INTERRUPT_RTC     CYGNUM_HAL_INTERRUPT_TIMER0
+
+// The vector used by the Ethernet
+#define CYGNUM_HAL_INTERRUPT_ETH     CYGNUM_HAL_INTERRUPT_GPIO0
+
+// method for reading clock interrupt latency
+#ifdef CYGVAR_KERNEL_COUNTERS_CLOCK_LATENCY
+externC void hal_clock_latency(cyg_uint32 *);
+# define HAL_CLOCK_LATENCY( _pvalue_ ) \
+         hal_clock_latency( (cyg_uint32 *)(_pvalue_) )
+#endif
+
+//----------------------------------------------------------------------------
+// Reset.
+#define HAL_PLATFORM_RESET()                                        \
+        CYG_MACRO_START                                             \
+                *(volatile unsigned short *)WDOG_BASE_ADDR |= 0x4;  \
+                /* hang here forever if reset fails */              \
+                while (1){}                                         \
+        CYG_MACRO_END
+
+// Fallback (never really used)
+#define HAL_PLATFORM_RESET_ENTRY 0x00000000
+
+#endif // CYGONCE_HAL_VAR_INTS_H
diff -urN -x CVS dummy/packages/hal/arm/mx31/var/current/include/plf_stub.h ecos_mx31/packages/hal/arm/mx31/var/current/include/plf_stub.h
--- dummy/packages/hal/arm/mx31/var/current/include/plf_stub.h	1969-12-31 18:00:00.000000000 -0600
+++ ecos_mx31/packages/hal/arm/mx31/var/current/include/plf_stub.h	2006-02-09 15:23:01.000000000 -0600
@@ -0,0 +1,72 @@
+#ifndef CYGONCE_HAL_PLF_STUB_H
+#define CYGONCE_HAL_PLF_STUB_H
+
+//=============================================================================
+//
+//      plf_stub.h
+//
+//      Platform header for GDB stub support.
+//
+//=============================================================================
+//####ECOSGPLCOPYRIGHTBEGIN####
+// -------------------------------------------
+// This file is part of eCos, the Embedded Configurable Operating System.
+// Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+//
+// eCos is free software; you can redistribute it and/or modify it under
+// the terms of the GNU General Public License as published by the Free
+// Software Foundation; either version 2 or (at your option) any later version.
+//
+// eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with eCos; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+//
+// As a special exception, if other files instantiate templates or use macros
+// or inline functions from this file, or you compile this file and link it
+// with other works to produce a work based on this file, this file does not
+// by itself cause the resulting work to be covered by the GNU General Public
+// License. However the source code for this file must still be made available
+// in accordance with section (3) of the GNU General Public License.
+//
+// This exception does not invalidate any other reasons why a work based on
+// this file might be covered by the GNU General Public License.
+//
+// Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+// at http://sources.redhat.com/ecos/ecos-license/
+// -------------------------------------------
+//####ECOSGPLCOPYRIGHTEND####
+//=============================================================================
+
+#include <pkgconf/hal.h>
+#include <cyg/infra/cyg_type.h>         // CYG_UNUSED_PARAM
+
+#include <cyg/hal/hal_soc.h>         // registers
+#include <cyg/hal/hal_io.h>             // IO macros
+#include <cyg/hal/hal_intr.h>           // Interrupt macros
+#include <cyg/hal/arm_stub.h>           // architecture stub support
+
+#ifdef CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS
+//----------------------------------------------------------------------------
+// Define some platform specific communication details. This is mostly
+// handled by hal_if now, but we need to make sure the comms tables are
+// properly initialized.
+
+externC void cyg_hal_plf_comms_init(void);
+
+#define HAL_STUB_PLATFORM_INIT_SERIAL()         cyg_hal_plf_comms_init()
+#define HAL_STUB_PLATFORM_SET_BAUD_RATE(baud)   CYG_UNUSED_PARAM(int, (baud))
+#define HAL_STUB_PLATFORM_INTERRUPTIBLE         0
+
+//----------------------------------------------------------------------------
+// Stub initializer.
+#define HAL_STUB_PLATFORM_INIT()                CYG_EMPTY_STATEMENT
+
+#endif // ifdef CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS
+//-----------------------------------------------------------------------------
+#endif // CYGONCE_HAL_PLF_STUB_H
+// End of plf_stub.h
diff -urN -x CVS dummy/packages/hal/arm/mx31/var/current/include/var_io.h ecos_mx31/packages/hal/arm/mx31/var/current/include/var_io.h
--- dummy/packages/hal/arm/mx31/var/current/include/var_io.h	1969-12-31 18:00:00.000000000 -0600
+++ ecos_mx31/packages/hal/arm/mx31/var/current/include/var_io.h	2005-05-11 16:19:14.000000000 -0500
@@ -0,0 +1,56 @@
+#ifndef CYGONCE_VAR_IO_H
+#define CYGONCE_VAR_IO_H
+
+//=============================================================================
+//
+//      var_io.h
+//
+//      Variant specific IO support
+//
+//=============================================================================
+//####ECOSGPLCOPYRIGHTBEGIN####
+// -------------------------------------------
+// This file is part of eCos, the Embedded Configurable Operating System.
+// Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+//
+// eCos is free software; you can redistribute it and/or modify it under
+// the terms of the GNU General Public License as published by the Free
+// Software Foundation; either version 2 or (at your option) any later version.
+//
+// eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with eCos; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+//
+// As a special exception, if other files instantiate templates or use macros
+// or inline functions from this file, or you compile this file and link it
+// with other works to produce a work based on this file, this file does not
+// by itself cause the resulting work to be covered by the GNU General Public
+// License. However the source code for this file must still be made available
+// in accordance with section (3) of the GNU General Public License.
+//
+// This exception does not invalidate any other reasons why a work based on
+// this file might be covered by the GNU General Public License.
+//
+// Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+// at http://sources.redhat.com/ecos/ecos-license/
+// -------------------------------------------
+//####ECOSGPLCOPYRIGHTEND####
+//=============================================================================
+
+#include <cyg/hal/plf_io.h>             // Platform specifics
+
+//-----------------------------------------------------------------------------
+
+// Memory mapping details
+#ifndef CYGARC_PHYSICAL_ADDRESS
+#define CYGARC_PHYSICAL_ADDRESS(x) (((unsigned long)x & 0x0FFFFFFF) + RAM_BANK0_BASE)
+#endif
+
+//-----------------------------------------------------------------------------
+// end of var_io.h
+#endif // CYGONCE_VAR_IO_H
diff -urN -x CVS dummy/packages/hal/arm/mx31/var/current/src/cmds.c ecos_mx31/packages/hal/arm/mx31/var/current/src/cmds.c
--- dummy/packages/hal/arm/mx31/var/current/src/cmds.c	1969-12-31 18:00:00.000000000 -0600
+++ ecos_mx31/packages/hal/arm/mx31/var/current/src/cmds.c	2007-11-29 16:10:47.000000000 -0600
@@ -0,0 +1,1081 @@
+//==========================================================================
+//
+//      cmds.c
+//
+//      SoC [platform] specific RedBoot commands
+//
+//==========================================================================
+//####ECOSGPLCOPYRIGHTBEGIN####
+// -------------------------------------------
+// This file is part of eCos, the Embedded Configurable Operating System.
+// Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+//
+// eCos is free software; you can redistribute it and/or modify it under
+// the terms of the GNU General Public License as published by the Free
+// Software Foundation; either version 2 or (at your option) any later version.
+//
+// eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with eCos; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+//
+// As a special exception, if other files instantiate templates or use macros
+// or inline functions from this file, or you compile this file and link it
+// with other works to produce a work based on this file, this file does not
+// by itself cause the resulting work to be covered by the GNU General Public
+// License. However the source code for this file must still be made available
+// in accordance with section (3) of the GNU General Public License.
+//
+// This exception does not invalidate any other reasons why a work based on
+// this file might be covered by the GNU General Public License.
+//
+// Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+// at http://sources.redhat.com/ecos/ecos-license/
+// -------------------------------------------
+//####ECOSGPLCOPYRIGHTEND####
+//==========================================================================
+#include <redboot.h>
+#include <cyg/hal/hal_intr.h>
+#include <cyg/hal/plf_mmap.h>
+#include <cyg/hal/hal_soc.h>         // Hardware definitions
+#include <cyg/hal/hal_cache.h>
+
+typedef unsigned long long  u64;
+typedef unsigned int        u32;
+typedef unsigned short      u16;
+typedef unsigned char       u8;
+
+#define SZ_DEC_1M       1000000
+#define PLL_PD_MAX      16      //actual pd+1
+#define PLL_MFI_MAX     15
+#define PLL_MFI_MIN     5
+#define PLL_MFD_MAX     1024    //actual mfd+1
+#define PLL_MFN_MAX     511
+#define PRESC_MAX       8
+#define IPG_DIV_MAX     4
+#define AHB_DIV_MAX     8
+#define HSP_PODF_MAX    8
+#define NFC_PODF_MAX    8
+
+#define PLL_FREQ_MAX    (2 * PLL_REF_CLK * PLL_MFI_MAX)
+#define PLL_FREQ_MIN    ((2 * PLL_REF_CLK * (PLL_MFI_MIN - 1)) / PLL_PD_MAX)
+#define AHB_CLK_MAX     133333333
+#define IPG_CLK_MAX     (AHB_CLK_MAX / 2)
+#define NFC_CLK_MAX     25000000
+// IPU-HSP clock is independent of the HCLK and can go up to 177MHz but requires
+// higher voltage support. For simplicity, limit it to 133MHz
+#define HSP_CLK_MAX     133333333
+
+#define ERR_WRONG_CLK   -1
+#define ERR_NO_MFI      -2
+#define ERR_NO_MFN      -3
+#define ERR_NO_PD       -4
+#define ERR_NO_PRESC    -5
+#define ERR_NO_AHB_DIV  -6
+
+u32 pll_clock(enum plls pll);
+u32 get_main_clock(enum main_clocks clk);
+u32 get_peri_clock(enum peri_clocks clk);
+
+static u32 pll_mfd_fixed;
+
+static void clock_setup(int argc, char *argv[]);
+static void clko(int argc, char *argv[]);
+extern unsigned int g_clock_src;
+
+RedBoot_cmd("clock",
+            "Setup/Display clock (max AHB=133MHz, max IPG=66.5MHz)\nSyntax:",
+            "[<core clock in MHz> [:<AHB-to-core divider>[:<IPG-to-AHB divider>]]] \n\n\
+If a divider is zero or no divider is specified, the optimal divider values \n\
+will be chosen. Examples:\n\
+   [clock]         -> Show various clocks\n\
+   [clock 532]     -> Core=532  AHB=133           IPG=66.5\n\
+   [clock 399]     -> Core=399  AHB=133           IPG=66.5\n\
+   [clock 532:8]   -> Core=532  AHB=66.5(Core/8)  IPG=66.5\n\
+   [clock 532:8:2] -> Core=532  AHB=66.5(Core/8)  IPG=33.25(AHB/2)\n",
+            clock_setup
+           );
+
+/*!
+ * This is to calculate various parameters based on reference clock and
+ * targeted clock based on the equation:
+ *      t_clk = 2*ref_freq*(mfi + mfn/(mfd+1))/(pd+1)
+ * This calculation is based on a fixed MFD value for simplicity.
+ *
+ * @param ref       reference clock freq
+ * @param target    targeted clock in HZ
+ * @param p_pd      calculated pd value (pd value from register + 1) upon return
+ * @param p_mfi     calculated actual mfi value upon return
+ * @param p_mfn     calculated actual mfn value upon return
+ * @param p_mfd     fixed mfd value (mfd value from register + 1) upon return
+ *
+ * @return          0 if successful; non-zero otherwise.
+ */
+int calc_pll_params(u32 ref, u32 target, u32 *p_pd,
+                    u32 *p_mfi, u32 *p_mfn, u32 *p_mfd)
+{
+    u64 pd, mfi, mfn, n_target = (u64)target, n_ref = (u64)ref;
+
+    if (g_clock_src == FREQ_26MHZ) {
+        pll_mfd_fixed = 26 * 16;
+    } else if (g_clock_src == FREQ_27MHZ) {
+        pll_mfd_fixed = 27 * 16;
+    } else {
+        pll_mfd_fixed = 1024;
+    }
+
+    // Make sure targeted freq is in the valid range. Otherwise the
+    // following calculation might be wrong!!!
+    if (target < PLL_FREQ_MIN || target > PLL_FREQ_MAX) {
+        return ERR_WRONG_CLK;
+    }
+    // Use n_target and n_ref to avoid overflow
+    for (pd = 1; pd <= PLL_PD_MAX; pd++) {
+        mfi = (n_target * pd) / (2 * n_ref);
+        if (mfi > PLL_MFI_MAX) {
+            return ERR_NO_MFI;
+        } else if (mfi < 5) {
+            continue;
+        }
+        break;
+    }
+    // Now got pd and mfi already
+    mfn = (((n_target * pd) / 2 - n_ref * mfi) * pll_mfd_fixed) / n_ref;
+    // Check mfn within limit and mfn < denominator
+    if (mfn > PLL_MFN_MAX || mfn >= pll_mfd_fixed) {
+        return ERR_NO_MFN;
+    }
+
+    if (pd > PLL_PD_MAX) {
+        return ERR_NO_PD;
+    }
+    *p_pd = (u32)pd;
+    *p_mfi = (u32)mfi;
+    *p_mfn = (u32)mfn;
+    *p_mfd = pll_mfd_fixed;
+    return 0;
+}
+
+/*!
+ * This function assumes the expected core clock has to be changed by
+ * modifying the PLL. This is NOT true always but for most of the times,
+ * it is. So it assumes the PLL output freq is the same as the expected
+ * core clock (presc=1) unless the core clock is less than PLL_FREQ_MIN.
+ * In the latter case, it will try to increase the presc value until
+ * (presc*core_clk) is greater than PLL_FREQ_MIN. It then makes call to
+ * calc_pll_params() and obtains the values of PD, MFI,MFN, MFD based
+ * on the targeted PLL and reference input clock to the PLL. Lastly,
+ * it sets the register based on these values along with the dividers.
+ * Note 1) There is no value checking for the passed-in divider values
+ *         so the caller has to make sure those values are sensible.
+ *      2) Also adjust the NFC divider such that the NFC clock doesn't
+ *         exceed NFC_CLK_MAX.
+ *      3) IPU HSP clock is independent of AHB clock. Even it can go up to
+ *         177MHz for higher voltage, this function fixes the max to 133MHz.
+ *      4) This function should not have allowed diag_printf() calls since
+ *         the serial driver has been stoped. But leave then here to allow
+ *         easy debugging by NOT calling the cyg_hal_plf_serial_stop().
+ *
+ * @param ref       pll input reference clock (32KHz or 26MHz)
+ * @param core_clk  core clock in Hz
+ * @param ahb_div   ahb divider to divide the core clock to get ahb clock
+ *                  (ahb_div - 1) needs to be set in the register
+ * @param ipg_div   ipg divider to divide the ahb clock to get ipg clock
+ *                  (ipg_div - 1) needs to be set in the register
+ # @return          0 if successful; non-zero otherwise
+ */
+int configure_clock(u32 ref, u32 core_clk, u32 ahb_div, u32 ipg_div)
+{
+    u32 pll, presc = 1, pd, mfi, mfn, mfd, brmo = 0, mpctl0, hsp_div;
+    u32 pdr0, nfc_div;
+    int ret, i;
+
+    // assume pll default to core clock first
+    pll = core_clk;
+    // when core_clk >= PLL_FREQ_MIN, the presc can be 1.
+    // Otherwise, need to calculate presc value below and adjust the targeted pll
+    if (core_clk < PLL_FREQ_MIN) {
+        for (presc = 1; presc <= PRESC_MAX; presc++) {
+            if ((core_clk * presc) > PLL_FREQ_MIN) {
+                break;
+            }
+        }
+        if (presc == (PRESC_MAX + 1)) {
+            diag_printf("can't make presc=%d\n", presc);
+            return ERR_NO_PRESC;
+        }
+        pll = core_clk * presc;
+    }
+    // get hsp_div
+    for (hsp_div = 1; hsp_div <= HSP_PODF_MAX; hsp_div++) {
+        if ((pll / hsp_div) <= HSP_CLK_MAX) {
+            break;
+        }
+    }
+    if (hsp_div == (HSP_PODF_MAX + 1)) {
+        diag_printf("can't make hsp_div=%d\n", hsp_div);
+        return ERR_NO_PRESC;
+    }
+
+    // get nfc_div - make sure optimal NFC clock but less than NFC_CLK_MAX
+    for (nfc_div = 1; nfc_div <= NFC_PODF_MAX; nfc_div++) {
+        if ((pll / (ahb_div * nfc_div)) <= NFC_CLK_MAX) {
+            break;
+        }
+    }
+
+    // pll is now the targeted pll output. Use it along with ref input clock
+    // to get pd, mfi, mfn, mfd
+    if ((ret = calc_pll_params(ref, pll, &pd, &mfi, &mfn, &mfd)) != 0) {
+        diag_printf("can't find pll parameters: %d\n", ret);
+        return ret;
+    }
+#ifdef CMD_CLOCK_DEBUG
+    diag_printf("ref=%d, pll=%d, pd=%d, mfi=%d,mfn=%d, mfd=%d\n",
+                ref, pll, pd, mfi, mfn, mfd);
+#endif
+
+    // blindly increase divider first to avoid too fast ahbclk and ipgclk
+    // in case the core clock increases too much
+    pdr0 = readl(CCM_BASE_ADDR + CLKCTL_PDR0);
+    pdr0 &= ~0x000000FF;
+    // increase the dividers. should work even when core clock is 832 (26*2*16)MHz
+    // which is unlikely true.
+    pdr0 |= (1 << 6) | (6 << 3) | (0 << 0);
+    writel(pdr0, CCM_BASE_ADDR + CLKCTL_PDR0);
+    // calculate new pdr0
+    pdr0 &= ~0x00003FFF;
+    pdr0 |= ((hsp_div - 1) << 11) | ((nfc_div - 1) << 8) | ((ipg_div - 1) << 6) |
+            ((ahb_div - 1) << 3) | ((presc - 1) << 0);
+
+    // update PLL register
+    if ((mfd >= (10 * mfn)) || ((10 * mfn) >= (9 * mfd)))
+        brmo = 1;
+
+    mpctl0 = readl(CCM_BASE_ADDR + CLKCTL_MPCTL);
+    mpctl0 = (mpctl0 & 0x4000C000)  |
+             (brmo << 31)           |
+             ((pd - 1) << 26)       |
+             ((mfd - 1) << 16)      |
+             (mfi << 10)            |
+             mfn;
+    writel(mpctl0, CCM_BASE_ADDR + CLKCTL_MPCTL);
+    writel(pdr0, CCM_BASE_ADDR + CLKCTL_PDR0);
+    // add some delay for new values to take effect
+    for (i = 0; i < 10000; i++);
+
+    return 0;
+}
+
+static void clock_setup(int argc,char *argv[])
+{
+    u32 i, core_clk, ipg_div, data[3], temp, ahb_div, ahb_clk, ipg_clk;
+    int ret;
+
+    if (argc == 1)
+        goto print_clock;
+    if (g_clock_src == FREQ_27MHZ) {
+        diag_printf("Error: clock setup is not supported for 27MHz source\n\n");
+        return;
+    }
+    for (i = 0;  i < 3;  i++) {
+        if (!parse_num(*(&argv[1]), (unsigned long *)&temp, &argv[1], ":")) {
+            diag_printf("Error: Invalid parameter\n");
+            return;
+        }
+        data[i] = temp;
+    }
+
+    core_clk = data[0] * SZ_DEC_1M;
+    ahb_div = data[1];  // actual register field + 1
+    ipg_div = data[2];  // actual register field + 1
+
+    if (core_clk < (PLL_FREQ_MIN / PRESC_MAX) || core_clk > PLL_FREQ_MAX) {
+        diag_printf("Targeted core clock should be within [%d - %d]\n",
+                    PLL_FREQ_MIN / PRESC_MAX, PLL_FREQ_MAX);
+        return;
+    }
+
+    // find the ahb divider
+    if (ahb_div > AHB_DIV_MAX) {
+        diag_printf("Invalid AHB divider: %d. Maximum value is %d\n",
+                    ahb_div, AHB_DIV_MAX);
+        return;
+    }
+    if (ahb_div == 0) {
+        // no HCLK divider specified
+        for (ahb_div = 1; ; ahb_div++) {
+            if ((core_clk / ahb_div) <= AHB_CLK_MAX) {
+                break;
+            }
+        }
+    }
+    if (ahb_div > AHB_DIV_MAX || (core_clk / ahb_div) > AHB_CLK_MAX) {
+        diag_printf("Can't make AHB=%d since max=%d\n",
+                    core_clk / ahb_div, AHB_CLK_MAX);
+        return;
+    }
+
+    // find the ipg divider
+    ahb_clk = core_clk / ahb_div;
+    if (ipg_div > IPG_DIV_MAX) {
+        diag_printf("Invalid IPG divider: %d. Maximum value is %d\n",
+                    ipg_div, IPG_DIV_MAX);
+        return;
+    }
+    if (ipg_div == 0) {
+        ipg_div++;          // At least =1
+        if (ahb_clk > IPG_CLK_MAX)
+            ipg_div++;      // Make it =2
+    }
+    if (ipg_div > IPG_DIV_MAX || (ahb_clk / ipg_div) > IPG_CLK_MAX) {
+        diag_printf("Can't make IPG=%d since max=%d\n",
+                    (ahb_clk / ipg_div), IPG_CLK_MAX);
+        return;
+    }
+    ipg_clk = ahb_clk / ipg_div;
+
+    diag_printf("Trying to set core=%d ahb=%d ipg=%d...\n",
+                core_clk, ahb_clk, ipg_clk);
+
+    // stop the serial to be ready to adjust the clock
+    hal_delay_us(100000);
+    cyg_hal_plf_serial_stop();
+    // adjust the clock
+    ret = configure_clock(PLL_REF_CLK, core_clk, ahb_div, ipg_div);
+    // restart the serial driver
+    cyg_hal_plf_serial_init();
+    hal_delay_us(100000);
+
+    if (ret != 0) {
+        diag_printf("Failed to setup clock: %d\n", ret);
+        return;
+    }
+    diag_printf("\n<<<New clock setting>>>\n");
+
+    // Now printing clocks
+print_clock:
+    diag_printf("\nMPLL\t\tUPLL\t\tSPLL\n");
+    diag_printf("========================================\n");
+    diag_printf("%-16d%-16d%-16d\n\n", pll_clock(MCU_PLL), pll_clock(USB_PLL),
+                pll_clock(SER_PLL));
+    diag_printf("CPU\t\tAHB\t\tIPG\t\tIPG_PER\n");
+    diag_printf("========================================================\n");
+    diag_printf("%-16d%-16d%-16d%-16d\n\n",
+                get_main_clock(CPU_CLK),
+                get_main_clock(AHB_CLK),
+                get_main_clock(IPG_CLK),
+                get_main_clock(IPG_PER_CLK));
+
+    diag_printf("NFC\t\tUSB\t\tIPU-HSP\n");
+    diag_printf("========================================\n");
+    diag_printf("%-16d%-16d%-16d\n\n",
+                get_main_clock(NFC_CLK),
+                get_main_clock(USB_CLK),
+                get_main_clock(HSP_CLK));
+
+    diag_printf("UART1-5\t\tSSI1\t\tSSI2\t\tCSI\n");
+    diag_printf("===========================================");
+    diag_printf("=============\n");
+
+    diag_printf("%-16d%-16d%-16d%-16d\n\n",
+                get_peri_clock(UART1_BAUD),
+                get_peri_clock(SSI1_BAUD),
+                get_peri_clock(SSI2_BAUD),
+                get_peri_clock(CSI_BAUD));
+
+    diag_printf("FIRI\t\tSIM\t\tMSTICK1\t\tMSTICK2\n");
+    diag_printf("===========================================");
+    diag_printf("=============\n");
+
+    diag_printf("%-16d%-16d%-16d%-16d\n\n",
+                get_peri_clock(FIRI_BAUD),
+                get_peri_clock(SIM_BAUD),
+                get_peri_clock(MSTICK1_CLK),
+                get_peri_clock(MSTICK2_CLK));
+    diag_printf("IPG_PERCLK as baud clock for: UART1-5, I2C, SIM, OWIRE, SDHC");
+    if (((readl(EPIT1_BASE_ADDR) >> 24) & 0x3) == 0x2) {
+        diag_printf(", EPIT");
+    }
+    if (((readl(GPT1_BASE_ADDR) >> 6) & 0x7) == 0x2) {
+        diag_printf("GPT,");
+    }
+    if (((readl(PWM_BASE_ADDR) >> 16) & 0x3) == 0x2) {
+        diag_printf("PWM,");
+    }
+    diag_printf("\n");
+}
+
+/*!
+ * This function returns the PLL output value in Hz based on pll.
+ */
+u32 pll_clock(enum plls pll)
+{
+    u64 mfi, mfn, mfd, pdf, ref_clk, pll_out, sign;
+    u64 reg = readl(pll);
+
+    pdf = (reg >> 26) & 0xF;
+    mfd = (reg >> 16) & 0x3FF;
+    mfi = (reg >> 10) & 0xF;
+    mfi = (mfi <= 5) ? 5: mfi;
+    mfn = reg & 0x3FF;
+    sign = (mfn < 512) ? 0: 1;
+    mfn = (mfn < 512) ? mfn: (1024 - mfn);
+
+    ref_clk = g_clock_src;
+
+    if (sign == 0) {
+        pll_out = (2 * ref_clk * mfi + ((2 * ref_clk * mfn) / (mfd + 1))) /
+                  (pdf + 1);
+    } else {
+        pll_out = (2 * ref_clk * mfi - ((2 * ref_clk * mfn) / (mfd + 1))) /
+                  (pdf + 1);
+    }
+
+    return (u32)pll_out;
+}
+
+// The clocks are on by default. But need to setup the IOMUX
+void clock_spi_enable(unsigned int spi_clk)
+{
+    u32 val;
+
+    // Take care of SPI1 and SPI2
+    val = readl(IOMUXC_BASE_ADDR + 0x80);
+    writel((val & 0xFFFF) | 0x12120000, IOMUXC_BASE_ADDR + 0x80);
+
+    writel(0x12123812, IOMUXC_BASE_ADDR + 0x84);
+
+    val = readl(IOMUXC_BASE_ADDR + 0x88);
+    writel((val & 0xFFFFFF00) | 0x12, IOMUXC_BASE_ADDR + 0x88);
+
+    /* Select CSPI 1 signals */
+    val = readl(IOMUXC_BASE_ADDR + 0x8);
+    writel((val | 0x4), IOMUXC_BASE_ADDR + 0x8);
+
+    val = readl(IOMUXC_BASE_ADDR + 0x78);
+    writel((val & 0xFFFFFF) | 0x24000000, IOMUXC_BASE_ADDR + 0x78);
+
+    val = readl(IOMUXC_BASE_ADDR + 0x7C);
+    writel((val & 0xFFFFFF00) | 0x24, IOMUXC_BASE_ADDR + 0x7C);
+
+    writel(0x12121212, IOMUXC_BASE_ADDR + 0x8C);
+
+    val = readl(IOMUXC_BASE_ADDR + 0x88);
+    writel((val & 0xFF) | 0x12121200, IOMUXC_BASE_ADDR + 0x88);
+}
+
+// The clocks are on by default. But need to setup the IOMUX
+void mxc_i2c_init(unsigned int module_base)
+{
+    unsigned int val, reg;
+
+    switch (module_base) {
+    case I2C_BASE_ADDR:
+        reg = IOMUXC_BASE_ADDR + 0xA0;
+        val = (readl(reg) & 0xFFFF0000) | 0x1212; // func mode
+        writel(val, reg);
+        break;
+    case I2C2_BASE_ADDR:
+        reg = IOMUXC_BASE_ADDR + 0x88;
+        val = (readl(reg) & 0xFFFFFF00) | 0x24; // alt mode 1
+        writel(val, reg);
+        reg = IOMUXC_BASE_ADDR + 0x84;
+        val = (readl(reg) & 0x00FFFFFF) | 0x24000000; // alt mode 1
+        writel(val, reg);
+        break;
+    case I2C3_BASE_ADDR:
+        reg = IOMUXC_BASE_ADDR + 0x84;
+        val = (readl(reg) & 0xFFFFFF00) | 0x24; // alt mode 1
+        writel(val, reg);
+        reg = IOMUXC_BASE_ADDR + 0x80;
+        val = (readl(reg) & 0x00FFFFFF) | 0x24000000; // alt mode 1
+        writel(val, reg);
+        break;
+    default:
+        diag_printf("Invalide I2C base: 0x%x\n", module_base);
+        return;
+    }
+}
+
+/*!
+ * This function returns the main clock value in Hz.
+ */
+u32 get_main_clock(enum main_clocks clk)
+{
+    u32 mcu_podf, max_pdf, ipg_pdf, nfc_pdf, hsp_podf, clk_sel;
+    u32 pll, ret_val = 0, usb_prdf, usb_podf, pdf;
+    u32 reg = readl(CCM_BASE_ADDR + CLKCTL_PDR0);
+    u32 reg1 = readl(CCM_BASE_ADDR + CLKCTL_PDR1);
+    u32 ccmr = readl(CCM_BASE_ADDR + CLKCTL_CCMR);
+    u32 mpdr0 = readl(CCM_BASE_ADDR + CLKCTL_PDR0);
+
+    switch (clk) {
+    case CPU_CLK:
+        mcu_podf = reg & 0x7;
+        pll = pll_clock(MCU_PLL);
+        ret_val = pll / (mcu_podf + 1);
+        break;
+    case AHB_CLK:
+        max_pdf = (reg >> 3) & 0x7;
+        pll = pll_clock(MCU_PLL);
+        ret_val = pll / (max_pdf + 1);
+        break;
+    case HSP_CLK:
+        hsp_podf = (reg >> 11) & 0x7;
+        pll = pll_clock(MCU_PLL);
+        ret_val = pll / (hsp_podf + 1);
+        break;
+    case MBX_CLK:
+        max_pdf = (reg >> 3) & 0x7;
+        pll = pll_clock(MCU_PLL);
+        ret_val = (pll / (max_pdf + 1)) / 2;
+        break;
+    case IPG_CLK:
+        max_pdf = (reg >> 3) & 0x7;
+        ipg_pdf = (reg >> 6) & 0x3;
+        pll = pll_clock(MCU_PLL);
+        ret_val = pll / ((max_pdf + 1) * (ipg_pdf + 1));
+        break;
+    case IPG_PER_CLK:
+        clk_sel = ccmr & (1 << 24);
+        pdf = (mpdr0 >> 16) & 0x1F;
+        if (clk_sel != 0) {
+            // get the ipg_clk
+            max_pdf = (reg >> 3) & 0x7;
+            ipg_pdf = (reg >> 6) & 0x3;
+            pll = pll_clock(MCU_PLL);
+            ret_val = pll / ((max_pdf + 1) * (ipg_pdf + 1));
+        } else {
+            ret_val = pll_clock(USB_PLL) / (pdf + 1);
+        }
+        break;
+    case NFC_CLK:
+        nfc_pdf = (reg >> 8) & 0x7;
+        max_pdf = (reg >> 3) & 0x7;
+        pll = pll_clock(MCU_PLL);
+        /* AHB/nfc_pdf */
+        ret_val = pll / ((max_pdf + 1) * (nfc_pdf + 1));
+        break;
+    case USB_CLK:
+        usb_prdf = reg1 >> 30;
+        usb_podf = (reg1 >> 27) & 0x7;
+        pll = pll_clock(USB_PLL);
+        ret_val = pll / ((usb_prdf + 1) * (usb_podf + 1));
+        break;
+    default:
+        diag_printf("Unknown clock: %d\n", clk);
+        break;
+    }
+
+    return ret_val;
+}
+
+/*!
+ * This function returns the peripheral clock value in Hz.
+ */
+u32 get_peri_clock(enum peri_clocks clk)
+{
+    u32 ret_val = 0, pdf, pre_pdf, clk_sel;
+    u32 ccmr = readl(CCM_BASE_ADDR + CLKCTL_CCMR);
+    u32 mpdr0 = readl(CCM_BASE_ADDR + CLKCTL_PDR0);
+    u32 mpdr1 = readl(CCM_BASE_ADDR + CLKCTL_PDR1);
+    u32 mpdr2 = readl(CCM_BASE_ADDR + CLKCTL_PDR2);
+
+    switch (clk) {
+    case UART1_BAUD:
+    case UART2_BAUD:
+    case UART3_BAUD:
+    case UART4_BAUD:
+    case UART5_BAUD:
+    case SIM_BAUD:
+        clk_sel = ccmr & (1 << 24);
+        pdf = (mpdr0 >> 16) & 0x1F;
+        ret_val = (clk_sel != 0) ? get_main_clock(IPG_CLK) :
+                  pll_clock(USB_PLL) / (pdf + 1);
+        break;
+    case SSI1_BAUD:
+        pre_pdf = (mpdr1 >> 6) & 0x7;
+        pdf = mpdr1 & 0x3F;
+        clk_sel = (ccmr >> 18) & 3;
+        if (clk_sel == 0) {
+            ret_val = pll_clock(MCU_PLL) / ((pre_pdf + 1) * (pdf + 1));
+        } else if (clk_sel == 0x1) {
+            ret_val = pll_clock(USB_PLL) / ((pre_pdf + 1) * (pdf + 1));
+        } else if (clk_sel == 0x2) {
+            ret_val = pll_clock(SER_PLL) / ((pre_pdf + 1) * (pdf + 1));
+        } else {
+            diag_printf("Error: Use reserved value for SSI1!\n");
+            ret_val = 0;
+        }
+        break;
+    case SSI2_BAUD:
+        pre_pdf = (mpdr1 >> 15) & 0x7;
+        pdf = (mpdr1 >> 9) & 0x3F;
+        clk_sel = (ccmr >> 21) & 3;
+        if (clk_sel == 0) {
+            ret_val = pll_clock(MCU_PLL) / ((pre_pdf + 1) * (pdf + 1));
+        } else if (clk_sel == 0x1) {
+            ret_val = pll_clock(USB_PLL) / ((pre_pdf + 1) * (pdf + 1));
+        } else if (clk_sel == 0x2) {
+            ret_val = pll_clock(SER_PLL) / ((pre_pdf + 1) * (pdf + 1));
+        } else {
+            diag_printf("Error: Use reserved value for SSI2!\n");
+            ret_val = 0;
+        }
+        break;
+    case CSI_BAUD:
+        clk_sel = ccmr & (1 << 25);
+        pdf = (mpdr0 >> 23) & 0x1FF;
+        ret_val = (clk_sel != 0) ? (pll_clock(SER_PLL) / (pdf + 1)) :
+                  (pll_clock(USB_PLL) / (pdf + 1));
+        break;
+    case FIRI_BAUD:
+        pre_pdf = (mpdr1 >> 24) & 0x7;
+        pdf = (mpdr1 >> 18) & 0x3F;
+        clk_sel = (ccmr >> 11) & 3;
+        if (clk_sel == 0) {
+            ret_val = pll_clock(MCU_PLL) / ((pre_pdf + 1) * (pdf + 1));
+        } else if (clk_sel == 0x1) {
+            ret_val = pll_clock(USB_PLL) / ((pre_pdf + 1) * (pdf + 1));
+        } else if (clk_sel == 0x2) {
+            ret_val = pll_clock(SER_PLL) / ((pre_pdf + 1) * (pdf + 1));
+        } else {
+            diag_printf("Error: Use reserved value for SSI1!\n");
+            ret_val = 0;
+        }
+        break;
+    case MSTICK1_CLK:
+        pdf = mpdr2 & 0x3F;
+        ret_val = pll_clock(USB_PLL) / (pdf + 1);
+        break;
+    case MSTICK2_CLK:
+        pdf = (mpdr2 >> 7) & 0x3F;
+        ret_val = pll_clock(USB_PLL) / (pdf + 1);
+        break;
+    case SPI1_CLK:
+    case SPI2_CLK:
+        ret_val = get_main_clock(IPG_CLK);
+        break;
+    default:
+        diag_printf("%s(): This clock: %d not supported yet \n",
+                    __FUNCTION__, clk);
+        break;
+    }
+
+    return ret_val;
+}
+
+RedBoot_cmd("clko",
+            "Select clock source for CLKO (J11 on the CPU daughter card)",
+            " Default is 1/8 of ARM core\n\
+          <0> - display current clko selection \n\
+          <1> - mpl_dpdgck_clk (MPLL) \n\
+          <2> - ipg_clk_ccm (IPG) \n\
+          <3> - upl_dpdgck_clk (UPLL) \n\
+          <4> - pll_ref_clk \n\
+          <5> - fpm_ckil512_clk \n\
+          <6> - ipg_clk_ahb_arm (AHB) \n\
+          <7> - ipg_clk_arm (ARM) \n\
+          <8> - spl_dpdgck_clk (SPLL) \n\
+          <9> - ckih \n\
+          <10> - ipg_clk_ahb_emi_clk \n\
+          <11> - ipg_clk_ipu_hsp \n\
+          <12> - ipg_clk_nfc_20m \n\
+          <13> - ipg_clk_perclk_uart1 (IPG_PER)",
+            clko
+           );
+
+static u8* clko_name[] ={
+    "NULL",
+    "1/8 of mpl_dpdgck_clk (MPLL)",
+    "ipg_clk_ccm (IPG)",
+    "1/8 of upl_dpdgck_clk (UPLL)",
+    "pll_ref_clk",
+    "fpm_ckil512_clk",
+    "ipg_clk_ahb_arm (AHB)",
+    "1/8 of ipg_clk_arm (ARM)",
+    "1/8 of spl_dpdgck_clk (SPLL)",
+    "ckih",
+    "ipg_clk_ahb_emi_clk",
+    "ipg_clk_ipu_hsp",
+    "ipg_clk_nfc_20m",
+    "ipg_clk_perclk_uart1 (IPG_PER)",
+};
+
+#define CLKO_MAX_INDEX          (sizeof(clko_name) / sizeof(u8*))
+
+static void clko(int argc,char *argv[])
+{
+    u32 action = 0, cosr;
+
+    if (!scan_opts(argc, argv, 1, 0, 0, (void*) &action,
+                   OPTION_ARG_TYPE_NUM, "action"))
+        return;
+
+    if (action >= CLKO_MAX_INDEX) {
+        diag_printf("%d is not supported\n\n", action);
+        return;
+    }
+
+    cosr = readl(CCM_BASE_ADDR + CLKCTL_COSR);
+
+    if (action != 0) {
+        cosr = (cosr & (~0x1FF)) + action - 1;
+        if (action == 1 || action == 3 || action == 7 || action == 8) {
+            cosr |= (0x3 << 6); // make it divided by 8
+        }
+        writel(cosr, CCM_BASE_ADDR + CLKCTL_COSR);
+        diag_printf("Set clko to ");
+    }
+
+    cosr = readl(CCM_BASE_ADDR + CLKCTL_COSR);
+    diag_printf("%s\n", clko_name[(cosr & 0xF) + 1]);
+    diag_printf("COSR register[0x%x] = 0x%x\n",
+                (CCM_BASE_ADDR + CLKCTL_COSR), cosr);
+}
+
+#ifdef L2CC_ENABLED
+/*
+ * This command is added for some simple testing only. It turns on/off
+ * L2 cache regardless of L1 cache state. The side effect of this is
+ * when doing any flash operations such as "fis init", the L2
+ * will be turned back on along with L1 caches even though it is off
+ * by using this command.
+ */
+RedBoot_cmd("L2",
+            "L2 cache",
+            "[ON | OFF]",
+            do_L2_caches
+           );
+
+void do_L2_caches(int argc, char *argv[])
+{
+    u32 oldints;
+    int L2cache_on=0;
+
+    if (argc == 2) {
+        if (strcasecmp(argv[1], "on") == 0) {
+            HAL_DISABLE_INTERRUPTS(oldints);
+            HAL_ENABLE_L2();
+            HAL_RESTORE_INTERRUPTS(oldints);
+        } else if (strcasecmp(argv[1], "off") == 0) {
+            HAL_DISABLE_INTERRUPTS(oldints);
+            HAL_CLEAN_INVALIDATE_L2();
+            HAL_DISABLE_L2();
+            HAL_RESTORE_INTERRUPTS(oldints);
+        } else {
+            diag_printf("Invalid L2 cache mode: %s\n", argv[1]);
+        }
+    } else {
+        HAL_L2CACHE_IS_ENABLED(L2cache_on);
+        diag_printf("L2 cache: %s\n", L2cache_on?"On":"Off");
+    }
+}
+#endif //L2CC_ENABLED
+
+#define IIM_ERR_SHIFT       8
+#define POLL_FUSE_PRGD      (IIM_STAT_PRGD | (IIM_ERR_PRGE << IIM_ERR_SHIFT))
+#define POLL_FUSE_SNSD      (IIM_STAT_SNSD | (IIM_ERR_SNSE << IIM_ERR_SHIFT))
+
+static void fuse_op_start(void)
+{
+    /* Do not generate interrupt */
+    writel(0, IIM_BASE_ADDR + IIM_STATM_OFF);
+    // clear the status bits and error bits
+    writel(0x3, IIM_BASE_ADDR + IIM_STAT_OFF);
+    writel(0xFE, IIM_BASE_ADDR + IIM_ERR_OFF);
+}
+
+/*
+ * The action should be either:
+ *          POLL_FUSE_PRGD
+ * or:
+ *          POLL_FUSE_SNSD
+ */
+static int poll_fuse_op_done(int action)
+{
+
+    u32 status, error;
+
+    if (action != POLL_FUSE_PRGD && action != POLL_FUSE_SNSD) {
+        diag_printf("%s(%d) invalid operation\n", __FUNCTION__, action);
+        return -1;
+    }
+
+    /* Poll busy bit till it is NOT set */
+    while ((readl(IIM_BASE_ADDR + IIM_STAT_OFF) & IIM_STAT_BUSY) != 0 ) {
+    }
+
+    /* Test for successful write */
+    status = readl(IIM_BASE_ADDR + IIM_STAT_OFF);
+    error = readl(IIM_BASE_ADDR + IIM_ERR_OFF);
+
+    if ((status & action) != 0 && (error & (action >> IIM_ERR_SHIFT)) == 0) {
+        if (error) {
+            diag_printf("Even though the operation seems successful...\n");
+            diag_printf("There are some error(s) at addr=0x%x: 0x%x\n",
+                        (IIM_BASE_ADDR + IIM_ERR_OFF), error);
+        }
+        return 0;
+    }
+    diag_printf("%s(%d) failed\n", __FUNCTION__, action);
+    diag_printf("status address=0x%x, value=0x%x\n",
+                (IIM_BASE_ADDR + IIM_STAT_OFF), status);
+    diag_printf("There are some error(s) at addr=0x%x: 0x%x\n",
+                (IIM_BASE_ADDR + IIM_ERR_OFF), error);
+    return -1;
+}
+
+static void sense_fuse(int bank, int row, int bit)
+{
+    int addr, addr_l, addr_h, reg_addr;
+
+    fuse_op_start();
+
+    addr = ((bank << 11) | (row << 3) | (bit & 0x7));
+    /* Set IIM Program Upper Address */
+    addr_h = (addr >> 8) & 0x000000FF;
+    /* Set IIM Program Lower Address */
+    addr_l = (addr & 0x000000FF);
+
+#ifdef IIM_FUSE_DEBUG
+    diag_printf("%s: addr_h=0x%x, addr_l=0x%x\n",
+                __FUNCTION__, addr_h, addr_l);
+#endif
+    writel(addr_h, IIM_BASE_ADDR + IIM_UA_OFF);
+    writel(addr_l, IIM_BASE_ADDR + IIM_LA_OFF);
+    /* Start sensing */
+    writel(0x8, IIM_BASE_ADDR + IIM_FCTL_OFF);
+    if (poll_fuse_op_done(POLL_FUSE_SNSD) != 0) {
+        diag_printf("%s(bank: %d, row: %d, bit: %d failed\n",
+                    __FUNCTION__, bank, row, bit);
+    }
+    reg_addr = IIM_BASE_ADDR + IIM_SDAT_OFF;
+    diag_printf("fuses at (bank:%d, row:%d) = 0x%x\n", bank, row, readl(reg_addr));
+}
+
+void do_fuse_read(int argc, char *argv[])
+{
+    int bank, row;
+
+    if (argc == 1) {
+        diag_printf("Useage: fuse_read <bank> <row>\n");
+        return;
+    } else if (argc == 3) {
+        if (!parse_num(*(&argv[1]), (unsigned long *)&bank, &argv[1], " ")) {
+                diag_printf("Error: Invalid parameter\n");
+            return;
+        }
+        if (!parse_num(*(&argv[2]), (unsigned long *)&row, &argv[2], " ")) {
+                diag_printf("Error: Invalid parameter\n");
+                return;
+            }
+
+        diag_printf("Read fuse at bank:%d row:%d\n", bank, row);
+        sense_fuse(bank, row, 0);
+
+    } else {
+        diag_printf("Passing in wrong arguments: %d\n", argc);
+        diag_printf("Useage: fuse_read <bank> <row>\n");
+    }
+}
+
+/* Blow fuses based on the bank, row and bit positions (all 0-based)
+*/
+static int fuse_blow(int bank,int row,int bit)
+{
+    int addr, addr_l, addr_h, ret = -1;
+
+    fuse_op_start();
+
+    /* Disable IIM Program Protect */
+    writel(0xAA, IIM_BASE_ADDR + IIM_PREG_P_OFF);
+
+    addr = ((bank << 11) | (row << 3) | (bit & 0x7));
+    /* Set IIM Program Upper Address */
+    addr_h = (addr >> 8) & 0x000000FF;
+    /* Set IIM Program Lower Address */
+    addr_l = (addr & 0x000000FF);
+
+#ifdef IIM_FUSE_DEBUG
+    diag_printf("blowing addr_h=0x%x, addr_l=0x%x\n", addr_h, addr_l);
+#endif
+
+    writel(addr_h, IIM_BASE_ADDR + IIM_UA_OFF);
+    writel(addr_l, IIM_BASE_ADDR + IIM_LA_OFF);
+    /* Start Programming */
+    writel(0x31, IIM_BASE_ADDR + IIM_FCTL_OFF);
+    if (poll_fuse_op_done(POLL_FUSE_PRGD) == 0) {
+        ret = 0;
+    }
+
+    /* Enable IIM Program Protect */
+    writel(0x0, IIM_BASE_ADDR + IIM_PREG_P_OFF);
+    return ret;
+}
+
+/*
+ * This command is added for burning IIM fuses
+ */
+RedBoot_cmd("fuse_read",
+            "read some fuses",
+            "<bank> <row>",
+            do_fuse_read
+           );
+
+RedBoot_cmd("fuse_blow",
+            "blow some fuses",
+            "<bank> <row> <value>",
+            do_fuse_blow
+           );
+
+#define         INIT_STRING              "12345678"
+static char ready_to_blow[] = INIT_STRING;
+
+void quick_itoa(u32 num, char *a)
+{
+    int i, j, k;
+    for (i = 0; i <= 7; i++) {
+        j = (num >> (4 * i)) & 0xF;
+        k = (j < 10) ? '0' : ('a' - 0xa);
+        a[i] = j + k;
+    }
+}
+
+void do_fuse_blow(int argc, char *argv[])
+{
+    int bank, row, value, i;
+
+    if (argc == 1) {
+        diag_printf("It is too dangeous for you to use this command.\n");
+        return;
+    } else if (argc == 2) {
+        if (strcasecmp(argv[1], "nandboot") == 0) {
+            quick_itoa(readl(EPIT_BASE_ADDR + EPITCNR), ready_to_blow);
+            diag_printf("%s\n", ready_to_blow);
+        }
+        return;
+    } else if (argc == 3) {
+        if (strcasecmp(argv[1], "nandboot") == 0 &&
+            strcasecmp(argv[2], ready_to_blow) == 0) {
+#if defined(CYGPKG_HAL_ARM_MXC91131) || defined(CYGPKG_HAL_ARM_MX21) || defined(CYGPKG_HAL_ARM_MX27) || defined(CYGPKG_HAL_ARM_MX31)
+            diag_printf("No need to blow any fuses for NAND boot on this platform\n\n");
+#else
+            diag_printf("Ready to burn NAND boot fuses\n");
+            if (fuse_blow(0, 16, 1) != 0 || fuse_blow(0, 16, 7) != 0) {
+                diag_printf("NAND BOOT fuse blown failed miserably ...\n");
+            } else {
+                diag_printf("NAND BOOT fuse blown successfully ...\n");
+            }
+        } else {
+            diag_printf("Not ready: %s, %s\n", argv[1], argv[2]);
+#endif
+        }
+    } else if (argc == 4) {
+        if (!parse_num(*(&argv[1]), (unsigned long *)&bank, &argv[1], " ")) {
+                diag_printf("Error: Invalid parameter\n");
+                return;
+        }
+        if (!parse_num(*(&argv[2]), (unsigned long *)&row, &argv[2], " ")) {
+                diag_printf("Error: Invalid parameter\n");
+                return;
+        }
+        if (!parse_num(*(&argv[3]), (unsigned long *)&value, &argv[3], " ")) {
+                diag_printf("Error: Invalid parameter\n");
+                return;
+        }
+
+        diag_printf("Blowing fuse at bank:%d row:%d value:%d\n",
+                    bank, row, value);
+        for (i = 0; i < 8; i++) {
+            if (((value >> i) & 0x1) == 0) {
+                continue;
+            }
+            if (fuse_blow(bank, row, i) != 0) {
+                diag_printf("fuse_blow(bank: %d, row: %d, bit: %d failed\n",
+                            bank, row, i);
+            } else {
+                diag_printf("fuse_blow(bank: %d, row: %d, bit: %d successful\n",
+                            bank, row, i);
+            }
+        }
+        sense_fuse(bank, row, 0);
+
+    } else {
+        diag_printf("Passing in wrong arguments: %d\n", argc);
+    }
+    /* Reset to default string */
+    strcpy(ready_to_blow, INIT_STRING);;
+}
+
+/* precondition: m>0 and n>0.  Let g=gcd(m,n). */
+int gcd(int m, int n)
+{
+    int t;
+    while(m > 0) {
+        if(n > m) {t = m; m = n; n = t;} /* swap */
+        m -= n;
+    }
+    return n;
+}
+
+#define CLOCK_SRC_DETECT_MS         100
+#define CLOCK_IPG_DEFAULT           66500000
+#define CLOCK_SRC_DETECT_MARGIN     500000
+void mxc_show_clk_input(void)
+{
+    u32 c1, c2, diff, ipg_real, num = 0;
+    u32 prcs = (readl(CCM_BASE_ADDR + CLKCTL_CCMR) >> 1) & 0x3;
+
+    return;  // FIXME
+
+    switch (prcs) {
+    case 0x01:
+        diag_printf("FPM enabled --> 32KHz input source\n");
+        return;
+    case 0x02:
+        break;
+    default:
+        diag_printf("Error %d: unknown clock source %d\n", __LINE__, prcs);
+        return;
+    }
+
+    // enable GPT with IPG clock input
+    writel(0x241, GPT_BASE_ADDR + GPTCR);
+    // prescaler = 1
+    writel(0, GPT_BASE_ADDR + GPTPR);
+
+    c1 = readl(GPT_BASE_ADDR + GPTCNT);
+    // use 32KHz input clock to get the delay
+    hal_delay_us(CLOCK_SRC_DETECT_MS * 1000);
+    c2 = readl(GPT_BASE_ADDR + GPTCNT);
+    diff = (c2 > c1) ? (c2 - c1) : (0xFFFFFFFF - c1 + c2);
+
+    ipg_real = diff * (1000 / CLOCK_SRC_DETECT_MS);
+
+    if (ipg_real > (CLOCK_IPG_DEFAULT + CLOCK_SRC_DETECT_MARGIN)) {
+        if (g_clock_src != FREQ_27MHZ)
+            num = 27;
+    } else if (ipg_real < (CLOCK_IPG_DEFAULT - CLOCK_SRC_DETECT_MARGIN)) {
+        if (g_clock_src != FREQ_26MHZ)
+            num = 26;
+    }
+    if (num != 0) {
+        diag_printf("Error: Actural clock input is %d MHz\n", num);
+        diag_printf("       ipg_real=%d CLOCK_IPG_DEFAULT - CLOCK_SRC_DETECT_MARGIN=%d\n\n",
+                    ipg_real, CLOCK_IPG_DEFAULT - CLOCK_SRC_DETECT_MARGIN);
+        diag_printf("       But clock source defined to be %d\n\n", g_clock_src);
+        hal_delay_us(2000000);
+    } else {
+        diag_printf("ipg_real=%d CLOCK_IPG_DEFAULT - CLOCK_SRC_DETECT_MARGIN=%d\n\n",
+                    ipg_real, CLOCK_IPG_DEFAULT - CLOCK_SRC_DETECT_MARGIN);
+        diag_printf("clock source defined to be %d\n\n", g_clock_src);
+    }
+}
+
+RedBoot_init(mxc_show_clk_input, RedBoot_INIT_LAST);
diff -urN -x CVS dummy/packages/hal/arm/mx31/var/current/src/soc_diag.c ecos_mx31/packages/hal/arm/mx31/var/current/src/soc_diag.c
--- dummy/packages/hal/arm/mx31/var/current/src/soc_diag.c	1969-12-31 18:00:00.000000000 -0600
+++ ecos_mx31/packages/hal/arm/mx31/var/current/src/soc_diag.c	2007-10-10 08:00:32.000000000 -0500
@@ -0,0 +1,748 @@
+/*=============================================================================
+//
+//      hal_diag.c
+//
+//      HAL diagnostic output code
+//
+//=============================================================================
+//####ECOSGPLCOPYRIGHTBEGIN####
+// -------------------------------------------
+// This file is part of eCos, the Embedded Configurable Operating System.
+// Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+//
+// eCos is free software; you can redistribute it and/or modify it under
+// the terms of the GNU General Public License as published by the Free
+// Software Foundation; either version 2 or (at your option) any later version.
+//
+// eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with eCos; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+//
+// As a special exception, if other files instantiate templates or use macros
+// or inline functions from this file, or you compile this file and link it
+// with other works to produce a work based on this file, this file does not
+// by itself cause the resulting work to be covered by the GNU General Public
+// License. However the source code for this file must still be made available
+// in accordance with section (3) of the GNU General Public License.
+//
+// This exception does not invalidate any other reasons why a work based on
+// this file might be covered by the GNU General Public License.
+//
+// Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+// at http://sources.redhat.com/ecos/ecos-license/
+// -------------------------------------------
+//####ECOSGPLCOPYRIGHTEND####
+//===========================================================================*/
+
+#include <pkgconf/hal.h>
+#include <pkgconf/system.h>
+#include CYGBLD_HAL_PLATFORM_H
+
+#include <cyg/infra/cyg_type.h>         // base types
+#include <cyg/infra/cyg_trac.h>         // tracing macros
+#include <cyg/infra/cyg_ass.h>          // assertion macros
+
+#include <cyg/hal/hal_arch.h>           // basic machine info
+#include <cyg/hal/hal_intr.h>           // interrupt macros
+#include <cyg/hal/hal_io.h>             // IO macros
+#include <cyg/hal/hal_if.h>             // Calling interface definitions
+#include <cyg/hal/hal_diag.h>
+#include <cyg/hal/drv_api.h>            // cyg_drv_interrupt_acknowledge
+#include <cyg/hal/hal_misc.h>           // Helper functions
+#include <cyg/hal/hal_soc.h>         // Hardware definitions
+
+/*
+ * UART Control Register 0 Bit Fields.
+ */
+#define EUartUCR1_ADEN      (1 << 15)           // Auto dectect interrupt
+#define EUartUCR1_ADBR      (1 << 14)           // Auto detect baud rate
+#define EUartUCR1_TRDYEN    (1 << 13)           // Transmitter ready interrupt enable
+#define EUartUCR1_IDEN      (1 << 12)           // Idle condition interrupt
+#define EUartUCR1_RRDYEN    (1 << 9)            // Recv ready interrupt enable
+#define EUartUCR1_RDMAEN    (1 << 8)            // Recv ready DMA enable
+#define EUartUCR1_IREN      (1 << 7)            // Infrared interface enable
+#define EUartUCR1_TXMPTYEN  (1 << 6)            // Transimitter empty interrupt enable
+#define EUartUCR1_RTSDEN    (1 << 5)            // RTS delta interrupt enable
+#define EUartUCR1_SNDBRK    (1 << 4)            // Send break
+#define EUartUCR1_TDMAEN    (1 << 3)            // Transmitter ready DMA enable
+#define EUartUCR1_DOZE      (1 << 1)            // Doze
+#define EUartUCR1_UARTEN    (1 << 0)            // UART enabled
+#define EUartUCR2_ESCI      (1 << 15)           // Escape seq interrupt enable
+#define EUartUCR2_IRTS      (1 << 14)           // Ignore RTS pin
+#define EUartUCR2_CTSC      (1 << 13)           // CTS pin control
+#define EUartUCR2_CTS       (1 << 12)           // Clear to send
+#define EUartUCR2_ESCEN     (1 << 11)           // Escape enable
+#define EUartUCR2_PREN      (1 << 8)            // Parity enable
+#define EUartUCR2_PROE      (1 << 7)            // Parity odd/even
+#define EUartUCR2_STPB      (1 << 6)            // Stop
+#define EUartUCR2_WS        (1 << 5)            // Word size
+#define EUartUCR2_RTSEN     (1 << 4)            // Request to send interrupt enable
+#define EUartUCR2_ATEN      (1 << 3)            // Aging timer enable
+#define EUartUCR2_TXEN      (1 << 2)            // Transmitter enabled
+#define EUartUCR2_RXEN      (1 << 1)            // Receiver enabled
+#define EUartUCR2_SRST_     (1 << 0)            // SW reset
+#define EUartUCR3_PARERREN  (1 << 12)           // Parity enable
+#define EUartUCR3_FRAERREN  (1 << 11)           // Frame error interrupt enable
+#define EUartUCR3_ADNIMP    (1 << 7)            // Autobaud detection not improved
+#define EUartUCR3_RXDSEN    (1 << 6)            // Receive status interrupt enable
+#define EUartUCR3_AIRINTEN  (1 << 5)            // Async IR wake interrupt enable
+#define EUartUCR3_AWAKEN    (1 << 4)            // Async wake interrupt enable
+#define EUartUCR3_RXDMUXSEL (1 << 2)            // RXD muxed input selected
+#define EUartUCR3_INVT      (1 << 1)            // Inverted Infrared transmission
+#define EUartUCR3_ACIEN     (1 << 0)            // Autobaud counter interrupt enable
+#define EUartUCR4_CTSTL_32  (32 << 10)          // CTS trigger level (32 chars)
+#define EUartUCR4_INVR      (1 << 9)            // Inverted infrared reception
+#define EUartUCR4_ENIRI     (1 << 8)            // Serial infrared interrupt enable
+#define EUartUCR4_WKEN      (1 << 7)            // Wake interrupt enable
+#define EUartUCR4_IRSC      (1 << 5)            // IR special case
+#define EUartUCR4_LPBYP     (1 << 4)            // Low power bypass
+#define EUartUCR4_TCEN      (1 << 3)            // Transmit complete interrupt enable
+#define EUartUCR4_BKEN      (1 << 2)            // Break condition interrupt enable
+#define EUartUCR4_OREN      (1 << 1)            // Receiver overrun interrupt enable
+#define EUartUCR4_DREN      (1 << 0)            // Recv data ready interrupt enable
+#define EUartUFCR_RXTL_SHF  0                   // Receiver trigger level shift
+#define EUartUFCR_RFDIV_1   (5 << 7)            // Reference freq divider (div 1)
+#define EUartUFCR_RFDIV_2   (4 << 7)            // Reference freq divider (div 2)
+#define EUartUFCR_RFDIV_3   (3 << 7)            // Reference freq divider (div 3)
+#define EUartUFCR_RFDIV_4   (2 << 7)            // Reference freq divider (div 4)
+#define EUartUFCR_RFDIV_5   (1 << 7)            // Reference freq divider (div 5)
+#define EUartUFCR_RFDIV_6   (0 << 7)            // Reference freq divider (div 6)
+#define EUartUFCR_RFDIV_7   (6 << 7)            // Reference freq divider (div 7)
+#define EUartUFCR_TXTL_SHF  10                  // Transmitter trigger level shift
+#define EUartUSR1_PARITYERR (1 << 15)           // Parity error interrupt flag
+#define EUartUSR1_RTSS      (1 << 14)           // RTS pin status
+#define EUartUSR1_TRDY      (1 << 13)           // Transmitter ready interrupt/dma flag
+#define EUartUSR1_RTSD      (1 << 12)           // RTS delta
+#define EUartUSR1_ESCF      (1 << 11)           // Escape seq interrupt flag
+#define EUartUSR1_FRAMERR   (1 << 10)           // Frame error interrupt flag
+#define EUartUSR1_RRDY      (1 << 9)            // Receiver ready interrupt/dma flag
+#define EUartUSR1_AGTIM     (1 << 8)            // Aging timeout interrupt status
+#define EUartUSR1_RXDS      (1 << 6)            // Receiver idle interrupt flag
+#define EUartUSR1_AIRINT    (1 << 5)            // Async IR wake interrupt flag
+#define EUartUSR1_AWAKE     (1 << 4)            // Aysnc wake interrupt flag
+#define EUartUSR2_ADET      (1 << 15)           // Auto baud rate detect complete
+#define EUartUSR2_TXFE      (1 << 14)           // Transmit buffer FIFO empty
+#define EUartUSR2_IDLE      (1 << 12)           // Idle condition
+#define EUartUSR2_ACST      (1 << 11)           // Autobaud counter stopped
+#define EUartUSR2_IRINT     (1 << 8)            // Serial infrared interrupt flag
+#define EUartUSR2_WAKE      (1 << 7)            // Wake
+#define EUartUSR2_RTSF      (1 << 4)            // RTS edge interrupt flag
+#define EUartUSR2_TXDC      (1 << 3)            // Transmitter complete
+#define EUartUSR2_BRCD      (1 << 2)            // Break condition
+#define EUartUSR2_ORE       (1 << 1)            // Overrun error
+#define EUartUSR2_RDR       (1 << 0)            // Recv data ready
+#define EUartUTS_FRCPERR    (1 << 13)           // Force parity error
+#define EUartUTS_LOOP       (1 << 12)           // Loop tx and rx
+#define EUartUTS_TXEMPTY    (1 << 6)            // TxFIFO empty
+#define EUartUTS_RXEMPTY    (1 << 5)            // RxFIFO empty
+#define EUartUTS_TXFULL     (1 << 4)            // TxFIFO full
+#define EUartUTS_RXFULL     (1 << 3)            // RxFIFO full
+#define EUartUTS_SOFTRST    (1 << 0)            // Software reset
+
+#define EUartUFCR_RFDIV                        EUartUFCR_RFDIV_2
+//#define EUartUFCR_RFDIV                        EUartUFCR_RFDIV_4
+
+#if (EUartUFCR_RFDIV==EUartUFCR_RFDIV_2)
+#define MXC_UART_REFFREQ                        (get_peri_clock(UART1_BAUD) / 2)
+#endif
+
+#if (EUartUFCR_RFDIV==EUartUFCR_RFDIV_4)
+#define MXC_UART_REFFREQ                        (get_peri_clock(UART1_BAUD) / 4)
+#endif
+
+#if 0
+void
+cyg_hal_plf_comms_init(void)
+{
+    static int initialized = 0;
+
+    if (initialized)
+        return;
+
+    initialized = 1;
+
+    cyg_hal_plf_serial_init();
+}
+#endif
+
+//=============================================================================
+// MXC Serial Port (UARTx) for Debug
+//=============================================================================
+#ifdef UART_WIDTH_32
+struct mxc_serial {
+    volatile cyg_uint32 urxd[16];
+    volatile cyg_uint32 utxd[16];
+    volatile cyg_uint32 ucr1;
+    volatile cyg_uint32 ucr2;
+    volatile cyg_uint32 ucr3;
+    volatile cyg_uint32 ucr4;
+    volatile cyg_uint32 ufcr;
+    volatile cyg_uint32 usr1;
+    volatile cyg_uint32 usr2;
+    volatile cyg_uint32 uesc;
+    volatile cyg_uint32 utim;
+    volatile cyg_uint32 ubir;
+    volatile cyg_uint32 ubmr;
+    volatile cyg_uint32 ubrc;
+    volatile cyg_uint32 onems;
+    volatile cyg_uint32 uts;
+};
+#else
+struct mxc_serial {
+    volatile cyg_uint16 urxd[1];
+    volatile cyg_uint16 resv0[31];
+
+    volatile cyg_uint16 utxd[1];
+    volatile cyg_uint16 resv1[31];
+    volatile cyg_uint16 ucr1;
+    volatile cyg_uint16 resv2;
+    volatile cyg_uint16 ucr2;
+    volatile cyg_uint16 resv3;
+    volatile cyg_uint16 ucr3;
+    volatile cyg_uint16 resv4;
+    volatile cyg_uint16 ucr4;
+    volatile cyg_uint16 resv5;
+    volatile cyg_uint16 ufcr;
+    volatile cyg_uint16 resv6;
+    volatile cyg_uint16 usr1;
+    volatile cyg_uint16 resv7;
+    volatile cyg_uint16 usr2;
+    volatile cyg_uint16 resv8;
+    volatile cyg_uint16 uesc;
+    volatile cyg_uint16 resv9;
+    volatile cyg_uint16 utim;
+    volatile cyg_uint16 resv10;
+    volatile cyg_uint16 ubir;
+    volatile cyg_uint16 resv11;
+    volatile cyg_uint16 ubmr;
+    volatile cyg_uint16 resv12;
+    volatile cyg_uint16 ubrc;
+    volatile cyg_uint16 resv13;
+    volatile cyg_uint16 onems;
+    volatile cyg_uint16 resv14;
+    volatile cyg_uint16 uts;
+    volatile cyg_uint16 resv15;
+};
+#endif
+
+typedef struct {
+    volatile struct mxc_serial* base;
+    cyg_int32 msec_timeout;
+    int isr_vector;
+    int baud_rate;
+} channel_data_t;
+
+static channel_data_t channels[] = {
+#if CYGHWR_HAL_ARM_SOC_UART1 != 0
+    {(volatile struct mxc_serial*)UART1_BASE_ADDR, 1000,
+      CYGNUM_HAL_INTERRUPT_UART1, CYGNUM_HAL_VIRTUAL_VECTOR_CONSOLE_CHANNEL_BAUD},
+#endif
+#if CYGHWR_HAL_ARM_SOC_UART2 != 0
+    {(volatile struct mxc_serial*)UART2_BASE_ADDR, 1000,
+     CYGNUM_HAL_INTERRUPT_UART2, CYGNUM_HAL_VIRTUAL_VECTOR_CONSOLE_CHANNEL_BAUD},
+#endif
+#if CYGHWR_HAL_ARM_SOC_UART3 != 0
+    {(volatile struct mxc_serial*)UART3_BASE_ADDR, 1000,
+     CYGNUM_HAL_INTERRUPT_UART3, CYGNUM_HAL_VIRTUAL_VECTOR_CONSOLE_CHANNEL_BAUD},
+#endif
+#if CYGHWR_HAL_ARM_SOC_UART4 != 0
+    {(volatile struct mxc_serial*)UART4_BASE_ADDR, 1000,
+     CYGNUM_HAL_INTERRUPT_UART4, CYGNUM_HAL_VIRTUAL_VECTOR_CONSOLE_CHANNEL_BAUD},
+#endif
+#if CYGHWR_HAL_ARM_SOC_UART5 != 0
+    {(volatile struct mxc_serial*)UART5_BASE_ADDR, 1000,
+     CYGNUM_HAL_INTERRUPT_UART5, CYGNUM_HAL_VIRTUAL_VECTOR_CONSOLE_CHANNEL_BAUD },
+#endif
+};
+
+/*---------------------------------------------------------------------------*/
+
+static void init_serial_channel(channel_data_t* __ch_data)
+{
+    volatile struct mxc_serial* base = __ch_data->base;
+
+    /* Wait for UART to finish transmitting */
+    while (!(base->uts & EUartUTS_TXEMPTY));
+
+    /* Disable UART */
+    base->ucr1 &= ~EUartUCR1_UARTEN;
+
+    /* Set to default POR state */
+    base->ucr1 = 0x00000000;
+    base->ucr2 = 0x00000000;
+
+    while (!(base->ucr2 & EUartUCR2_SRST_));
+
+    base->ucr3 = 0x00000704;
+    base->ucr4 = 0x00008000;
+    base->ufcr = 0x00000801;
+    base->uesc = 0x0000002B;
+    base->utim = 0x00000000;
+    base->ubir = 0x00000000;
+    base->ubmr = 0x00000000;
+    base->onems = 0x00000000;
+    base->uts  = 0x00000000;
+
+    /* Configure FIFOs */
+    base->ufcr = (1 << EUartUFCR_RXTL_SHF) | EUartUFCR_RFDIV
+                 | (2 << EUartUFCR_TXTL_SHF);
+
+    /* Setup One MS timer */
+    base->onems  = (MXC_UART_REFFREQ / 1000);
+
+    /* Set to 8N1 */
+    base->ucr2 &= ~EUartUCR2_PREN;
+    base->ucr2 |= EUartUCR2_WS;
+    base->ucr2 &= ~EUartUCR2_STPB;
+
+    /* Ignore RTS */
+    base->ucr2 |= EUartUCR2_IRTS;
+
+    /* Enable UART */
+    base->ucr1 |= EUartUCR1_UARTEN;
+
+    /* Enable FIFOs */
+    base->ucr2 |= EUartUCR2_SRST_ | EUartUCR2_RXEN | EUartUCR2_TXEN;
+
+    /* Clear status flags */
+    base->usr2 |= EUartUSR2_ADET  |
+                  EUartUSR2_IDLE  |
+                  EUartUSR2_IRINT |
+                  EUartUSR2_WAKE  |
+                  EUartUSR2_RTSF  |
+                  EUartUSR2_BRCD  |
+                  EUartUSR2_ORE   |
+                  EUartUSR2_RDR;
+
+    /* Clear status flags */
+    base->usr1 |= EUartUSR1_PARITYERR |
+                  EUartUSR1_RTSD      |
+                  EUartUSR1_ESCF      |
+                  EUartUSR1_FRAMERR   |
+                  EUartUSR1_AIRINT    |
+                  EUartUSR1_AWAKE;
+
+    /* Set the numerator value minus one of the BRM ratio */
+    base->ubir = (__ch_data->baud_rate / 100) - 1;
+
+    /* Set the denominator value minus one of the BRM ratio    */
+    base->ubmr = ((MXC_UART_REFFREQ / 1600) - 1);
+
+}
+
+static void stop_serial_channel(channel_data_t* __ch_data)
+{
+    volatile struct mxc_serial* base = __ch_data->base;
+
+    /* Wait for UART to finish transmitting */
+    while (!(base->uts & EUartUTS_TXEMPTY));
+
+    /* Disable UART */
+    base->ucr1 &= ~EUartUCR1_UARTEN;
+}
+
+//#define debug_uart_log_buf
+#ifdef debug_uart_log_buf
+#define DIAG_BUFSIZE 2048
+static char __log_buf[DIAG_BUFSIZE];
+static int diag_bp = 0;
+#endif
+
+void cyg_hal_plf_serial_putc(void *__ch_data, char c)
+{
+    volatile struct mxc_serial* base = ((channel_data_t*)__ch_data)->base;
+
+#ifdef debug_uart_log_buf
+    __log_buf[diag_bp++] = c;
+#endif
+
+    CYGARC_HAL_SAVE_GP();
+
+    // Wait for Tx FIFO not full
+    while (base->uts & EUartUTS_TXFULL)
+        ;
+    base->utxd[0] = c;
+
+    CYGARC_HAL_RESTORE_GP();
+}
+
+static cyg_bool cyg_hal_plf_serial_getc_nonblock(void* __ch_data,
+                                                 cyg_uint8* ch)
+{
+    volatile struct mxc_serial* base = ((channel_data_t*)__ch_data)->base;
+
+    // If receive fifo is empty, return false
+    if (base->uts & EUartUTS_RXEMPTY)
+        return false;
+
+    *ch = (char)base->urxd[0];
+
+    return true;
+}
+
+cyg_uint8 cyg_hal_plf_serial_getc(void* __ch_data)
+{
+    cyg_uint8 ch;
+    CYGARC_HAL_SAVE_GP();
+
+    while (!cyg_hal_plf_serial_getc_nonblock(__ch_data, &ch));
+
+    CYGARC_HAL_RESTORE_GP();
+    return ch;
+}
+
+static void cyg_hal_plf_serial_write(void* __ch_data, const cyg_uint8* __buf,
+                         cyg_uint32 __len)
+{
+    CYGARC_HAL_SAVE_GP();
+
+    while(__len-- > 0)
+        cyg_hal_plf_serial_putc(__ch_data, *__buf++);
+
+    CYGARC_HAL_RESTORE_GP();
+}
+
+static void cyg_hal_plf_serial_read(void* __ch_data, cyg_uint8* __buf,
+                                    cyg_uint32 __len)
+{
+    CYGARC_HAL_SAVE_GP();
+
+    while (__len-- > 0)
+        *__buf++ = cyg_hal_plf_serial_getc(__ch_data);
+
+    CYGARC_HAL_RESTORE_GP();
+}
+
+cyg_bool cyg_hal_plf_serial_getc_timeout(void* __ch_data,
+                                         cyg_uint8* ch)
+{
+    int delay_count;
+    channel_data_t* chan = (channel_data_t*)__ch_data;
+    cyg_bool res;
+    CYGARC_HAL_SAVE_GP();
+
+    delay_count = chan->msec_timeout * 10; // delay in .1 ms steps
+
+    for(;;) {
+        res = cyg_hal_plf_serial_getc_nonblock(__ch_data, ch);
+        if (res || 0 == delay_count--)
+            break;
+
+        CYGACC_CALL_IF_DELAY_US(100);
+    }
+
+    CYGARC_HAL_RESTORE_GP();
+    return res;
+}
+
+static int cyg_hal_plf_serial_control(void *__ch_data,
+                                      __comm_control_cmd_t __func, ...)
+{
+    static int irq_state = 0;
+    channel_data_t* chan = (channel_data_t*)__ch_data;
+    int ret = -1;
+    va_list ap;
+
+    CYGARC_HAL_SAVE_GP();
+    va_start(ap, __func);
+
+    switch (__func) {
+    case __COMMCTL_GETBAUD:
+        ret = chan->baud_rate;
+        break;
+    case __COMMCTL_SETBAUD:
+        chan->baud_rate = va_arg(ap, cyg_int32);
+        // Should we verify this value here?
+        init_serial_channel(chan);
+        ret = 0;
+        break;
+    case __COMMCTL_IRQ_ENABLE:
+        irq_state = 1;
+
+        chan->base->ucr1 |= EUartUCR1_RRDYEN;
+
+        HAL_INTERRUPT_UNMASK(chan->isr_vector);
+        break;
+    case __COMMCTL_IRQ_DISABLE:
+        ret = irq_state;
+        irq_state = 0;
+
+        chan->base->ucr1 &= ~EUartUCR1_RRDYEN;
+
+        HAL_INTERRUPT_MASK(chan->isr_vector);
+        break;
+    case __COMMCTL_DBG_ISR_VECTOR:
+        ret = chan->isr_vector;
+        break;
+    case __COMMCTL_SET_TIMEOUT:
+        ret = chan->msec_timeout;
+        chan->msec_timeout = va_arg(ap, cyg_uint32);
+        break;
+    default:
+        break;
+    }
+    va_end(ap);
+    CYGARC_HAL_RESTORE_GP();
+    return ret;
+}
+
+static int cyg_hal_plf_serial_isr(void *__ch_data, int* __ctrlc,
+                       CYG_ADDRWORD __vector, CYG_ADDRWORD __data)
+{
+    int res = 0;
+    channel_data_t* chan = (channel_data_t*)__ch_data;
+    char c;
+
+    CYGARC_HAL_SAVE_GP();
+
+    cyg_drv_interrupt_acknowledge(chan->isr_vector);
+
+    *__ctrlc = 0;
+    if (!(chan->base->uts & EUartUTS_RXEMPTY)) {
+	c = (char)chan->base->urxd[0];
+
+        if (cyg_hal_is_break( &c , 1 ))
+            *__ctrlc = 1;
+
+        res = CYG_ISR_HANDLED;
+    }
+
+    CYGARC_HAL_RESTORE_GP();
+    return res;
+}
+
+void cyg_hal_plf_serial_init(void)
+{
+    hal_virtual_comm_table_t* comm;
+    int cur = CYGACC_CALL_IF_SET_CONSOLE_COMM(CYGNUM_CALL_IF_SET_COMM_ID_QUERY_CURRENT);
+    int i;
+    static int jjj = 0;
+
+    // Init channels
+#define NUMOF(x) (sizeof(x)/sizeof(x[0]))
+    for (i = 0;  i < NUMOF(channels);  i++) {
+        init_serial_channel(&channels[i]);
+        CYGACC_CALL_IF_SET_CONSOLE_COMM(i+2);
+        comm = CYGACC_CALL_IF_CONSOLE_PROCS();
+        CYGACC_COMM_IF_CH_DATA_SET(*comm, &channels[i]);
+        CYGACC_COMM_IF_WRITE_SET(*comm, cyg_hal_plf_serial_write);
+        CYGACC_COMM_IF_READ_SET(*comm, cyg_hal_plf_serial_read);
+        CYGACC_COMM_IF_PUTC_SET(*comm, cyg_hal_plf_serial_putc);
+        CYGACC_COMM_IF_GETC_SET(*comm, cyg_hal_plf_serial_getc);
+        CYGACC_COMM_IF_CONTROL_SET(*comm, cyg_hal_plf_serial_control);
+        CYGACC_COMM_IF_DBG_ISR_SET(*comm, cyg_hal_plf_serial_isr);
+        CYGACC_COMM_IF_GETC_TIMEOUT_SET(*comm, cyg_hal_plf_serial_getc_timeout);
+        if (jjj == 0) {
+            cyg_hal_plf_serial_putc(&channels[i], '+');
+            jjj++;
+        }
+        cyg_hal_plf_serial_putc(&channels[i], '+');
+    }
+
+    // Restore original console
+    CYGACC_CALL_IF_SET_CONSOLE_COMM(cur);
+}
+
+void cyg_hal_plf_serial_stop(void)
+{
+        int i;
+
+        // Init channels
+#define NUMOF(x) (sizeof(x)/sizeof(x[0]))
+        for (i = 0;  i < NUMOF(channels);  i++) {
+                stop_serial_channel(&channels[i]);
+        }
+}
+
+//=============================================================================
+// Compatibility with older stubs
+//=============================================================================
+
+#ifndef CYGSEM_HAL_VIRTUAL_VECTOR_DIAG
+
+#include <cyg/hal/hal_stub.h>           // cyg_hal_gdb_interrupt
+
+#if (CYGNUM_HAL_VIRTUAL_VECTOR_CONSOLE_CHANNEL == 2)
+#define __BASE ((void*)UART1_BASE_ADDR)
+#define CYGHWR_HAL_GDB_PORT_VECTOR CYGNUM_HAL_INTERRUPT_UART1
+#elif (CYGNUM_HAL_VIRTUAL_VECTOR_CONSOLE_CHANNEL == 3)
+#define __BASE ((void*)UART2_BASE_ADDR)
+#define CYGHWR_HAL_GDB_PORT_VECTOR CYGNUM_HAL_INTERRUPT_UART2
+#elif (CYGNUM_HAL_VIRTUAL_VECTOR_CONSOLE_CHANNEL == 4)
+#define __BASE ((void*)UART3_BASE_ADDR)
+#define CYGHWR_HAL_GDB_PORT_VECTOR CYGNUM_HAL_INTERRUPT_UART3
+#elif (CYGNUM_HAL_VIRTUAL_VECTOR_CONSOLE_CHANNEL == 5)
+#define __BASE ((void*)UART4_BASE_ADDR)
+#define CYGHWR_HAL_GDB_PORT_VECTOR CYGNUM_HAL_INTERRUPT_UART4
+#elif (CYGNUM_HAL_VIRTUAL_VECTOR_CONSOLE_CHANNEL == 6)
+#define __BASE ((void*)UART5_BASE_ADDR)
+#define CYGHWR_HAL_GDB_PORT_VECTOR CYGNUM_HAL_INTERRUPT_UART5
+#endif
+
+#ifdef __BASE
+
+#ifdef CYGSEM_HAL_ROM_MONITOR
+#define CYG_HAL_STARTUP_ROM
+#define CYG_HAL_STARTUP_ROMRAM
+#undef CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS
+#endif
+
+#if (defined(CYG_HAL_STARTUP_ROM) || defined(CYG_HAL_STARTUP_ROMRAM)) && !defined(CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS)
+#define HAL_DIAG_USES_HARDWARE
+#elif !defined(CYGDBG_HAL_DIAG_TO_DEBUG_CHAN)
+#define HAL_DIAG_USES_HARDWARE
+#elif CYGNUM_HAL_VIRTUAL_VECTOR_CONSOLE_CHANNEL != CYGNUM_HAL_VIRTUAL_VECTOR_DEBUG_CHANNEL
+#define HAL_DIAG_USES_HARDWARE
+#endif
+
+static channel_data_t channel = {
+    (volatile struct mxc_serial*)__BASE, 0, CYGHWR_HAL_GDB_PORT_VECTOR
+};
+
+#ifdef HAL_DIAG_USES_HARDWARE
+
+void hal_diag_init(void)
+{
+    static int init = 0;
+    char *msg = "\n\rARM eCos\n\r";
+    cyg_uint8 lcr;
+
+    if (init++) return;
+
+    init_serial_channel(&channel);
+
+    while (*msg) hal_diag_write_char(*msg++);
+}
+
+#ifdef DEBUG_DIAG
+#ifndef CYG_HAL_STARTUP_ROM
+#define DIAG_BUFSIZE 2048
+static char diag_buffer[DIAG_BUFSIZE];
+static int diag_bp = 0;
+#endif
+#endif
+
+void hal_diag_write_char(char c)
+{
+#ifdef DEBUG_DIAG
+#ifndef CYG_HAL_STARTUP_ROM
+    diag_buffer[diag_bp++] = c;
+    if (diag_bp == sizeof(diag_buffer)) diag_bp = 0;
+#endif
+#endif
+    cyg_hal_plf_serial_putc(&channel, c);
+}
+
+void hal_diag_read_char(char *c)
+{
+    *c = cyg_hal_plf_serial_getc(&channel);
+}
+
+#else // not HAL_DIAG_USES_HARDWARE - it uses GDB protocol
+
+void hal_diag_read_char(char *c)
+{
+    *c = cyg_hal_plf_serial_getc(&channel);
+}
+
+void hal_diag_write_char(char c)
+{
+    static char line[100];
+    static int pos = 0;
+
+    // FIXME: Some LED blinking might be nice right here.
+
+    // No need to send CRs
+    if( c == '\r' ) return;
+
+    line[pos++] = c;
+
+        if (c == '\n' || pos == sizeof(line)) {
+        CYG_INTERRUPT_STATE old;
+
+        // Disable interrupts. This prevents GDB trying to interrupt us
+        // while we are in the middle of sending a packet. The serial
+        // receive interrupt will be seen when we re-enable interrupts
+        // later.
+
+#ifdef CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS
+        CYG_HAL_GDB_ENTER_CRITICAL_IO_REGION(old);
+#else
+        HAL_DISABLE_INTERRUPTS(old);
+#endif
+
+        while (1) {
+            static char hex[] = "0123456789ABCDEF";
+            cyg_uint8 csum = 0;
+            int i;
+#ifndef CYGDBG_HAL_DEBUG_GDB_CTRLC_SUPPORT
+            char c1;
+#endif
+            cyg_hal_plf_serial_putc(&channel, '$');
+            cyg_hal_plf_serial_putc(&channel, 'O');
+            csum += 'O';
+            for(i = 0; i < pos; i++) {
+                char ch = line[i];
+                char h = hex[(ch>>4)&0xF];
+                char l = hex[ch&0xF];
+                cyg_hal_plf_serial_putc(&channel, h);
+                cyg_hal_plf_serial_putc(&channel, l);
+                csum += h;
+                csum += l;
+            }
+            cyg_hal_plf_serial_putc(&channel, '#');
+            cyg_hal_plf_serial_putc(&channel, hex[(csum>>4)&0xF]);
+            cyg_hal_plf_serial_putc(&channel, hex[csum&0xF]);
+
+#ifdef CYGDBG_HAL_DEBUG_GDB_CTRLC_SUPPORT
+
+            break; // regardless
+
+#else // not CYGDBG_HAL_DEBUG_GDB_CTRLC_SUPPORT Ie. usually...
+
+            // Wait for the ACK character '+' from GDB here and handle
+            // receiving a ^C instead.  This is the reason for this clause
+            // being a loop.
+            c1 = cyg_hal_plf_serial_getc(&channel);
+
+            if( c1 == '+' )
+                break;              // a good acknowledge
+
+#ifdef CYGDBG_HAL_DEBUG_GDB_BREAK_SUPPORT
+            cyg_drv_interrupt_acknowledge(CYGHWR_HAL_GDB_PORT_VECTOR);
+            if( c1 == 3 ) {
+                // Ctrl-C: breakpoint.
+                cyg_hal_gdb_interrupt(
+                    (target_register_t)__builtin_return_address(0) );
+                break;
+            }
+#endif // CYGDBG_HAL_DEBUG_GDB_BREAK_SUPPORT
+
+#endif // ! CYGDBG_HAL_DEBUG_GDB_CTRLC_SUPPORT
+            // otherwise, loop round again
+        }
+
+        pos = 0;
+
+        // And re-enable interrupts
+#ifdef CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS
+        CYG_HAL_GDB_LEAVE_CRITICAL_IO_REGION(old);
+#else
+        HAL_RESTORE_INTERRUPTS(old);
+#endif
+
+    }
+}
+#endif
+
+#endif // __BASE
+
+#endif // !CYGSEM_HAL_VIRTUAL_VECTOR_DIAG
+
+/*---------------------------------------------------------------------------*/
+/* End of hal_diag.c */
diff -urN -x CVS dummy/packages/hal/arm/mx31/var/current/src/soc_misc.c ecos_mx31/packages/hal/arm/mx31/var/current/src/soc_misc.c
--- dummy/packages/hal/arm/mx31/var/current/src/soc_misc.c	1969-12-31 18:00:00.000000000 -0600
+++ ecos_mx31/packages/hal/arm/mx31/var/current/src/soc_misc.c	2008-04-02 14:36:06.000000000 -0500
@@ -0,0 +1,454 @@
+//==========================================================================
+//
+//      soc_misc.c
+//
+//      HAL misc board support code
+//
+//==========================================================================
+//####ECOSGPLCOPYRIGHTBEGIN####
+// -------------------------------------------
+// This file is part of eCos, the Embedded Configurable Operating System.
+// Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+//
+// eCos is free software; you can redistribute it and/or modify it under
+// the terms of the GNU General Public License as published by the Free
+// Software Foundation; either version 2 or (at your option) any later version.
+//
+// eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with eCos; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+//
+// As a special exception, if other files instantiate templates or use macros
+// or inline functions from this file, or you compile this file and link it
+// with other works to produce a work based on this file, this file does not
+// by itself cause the resulting work to be covered by the GNU General Public
+// License. However the source code for this file must still be made available
+// in accordance with section (3) of the GNU General Public License.
+//
+// This exception does not invalidate any other reasons why a work based on
+// this file might be covered by the GNU General Public License.
+//
+// Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+// at http://sources.redhat.com/ecos/ecos-license/
+// -------------------------------------------
+//####ECOSGPLCOPYRIGHTEND####
+//========================================================================*/
+
+#include <redboot.h>
+#include <pkgconf/hal.h>
+#include <pkgconf/system.h>
+#include CYGBLD_HAL_PLATFORM_H
+
+#include <cyg/infra/cyg_type.h>         // base types
+#include <cyg/infra/cyg_trac.h>         // tracing macros
+#include <cyg/infra/cyg_ass.h>          // assertion macros
+
+#include <cyg/hal/hal_misc.h>           // Size constants
+#include <cyg/hal/hal_io.h>             // IO macros
+#include <cyg/hal/hal_arch.h>           // Register state info
+#include <cyg/hal/hal_diag.h>
+#include <cyg/hal/hal_intr.h>           // Interrupt names
+#include <cyg/hal/hal_cache.h>          // Cache control
+#include <cyg/hal/hal_soc.h>            // Hardware definitions
+#include <cyg/hal/hal_mm.h>             // MMap table definitions
+
+#include <cyg/infra/diag.h>             // diag_printf
+
+// Most initialization has already been done before we get here.
+// All we do here is set up the interrupt environment.
+// FIXME: some of the stuff in hal_platform_setup could be moved here.
+
+externC void plf_hardware_init(void);
+
+#define IIM_PROD_REV_SH         3
+#define IIM_PROD_REV_LEN        5
+#define IIM_SREV_REV_SH         4
+#define IIM_SREV_REV_LEN        4
+#define PROD_SIGNATURE_MX31     0x1
+#define PROD_SIGNATURE_MX32     0x2
+
+#define PROD_SIGNATURE_SUPPORTED_1  PROD_SIGNATURE_MX31
+#define PROD_SIGNATURE_SUPPORTED_2  PROD_SIGNATURE_MX32
+#define CHIP_VERSION_NONE           0xFFFFFFFF      // invalid product ID
+#define CHIP_VERSION_UNKNOWN        0xDEADBEEF      // invalid chip rev
+
+#define PART_NUMBER_OFFSET          (12)
+#define MAJOR_NUMBER_OFFSET         (4)
+#define MINOR_NUMBER_OFFSET         (0)
+
+/*
+ * System_rev will have the following format
+ * 31-12 = part # (0x31, 0x32, 0x27, 0x91131, 0x91321, etc)
+ * 11-8 = unused
+ * 7-4 = major (1.y)
+ * 3-0 = minor (x.0)
+ */
+unsigned int system_rev = CHIP_REV_1_0;
+static int find_correct_chip;
+int g_board_type = BOARD_TYPE_UNKNOWN;
+extern char HAL_PLATFORM_EXTRA[60];
+
+/*
+ * This functions reads the IIM module and returns the system revision number.
+ * It returns the IIM silicon revision reg value if valid product rev is found.
+ . Otherwise, it returns -1.
+ */
+static int read_system_rev(void)
+{
+    int val;
+
+    val = readl(IIM_BASE_ADDR + IIM_PREV_OFF);
+
+    /* If the IIM doesn't contain valid product signature, return
+     * the lowest revision number */
+    if ((MXC_GET_FIELD(val, IIM_PROD_REV_LEN, IIM_PROD_REV_SH) !=
+        PROD_SIGNATURE_SUPPORTED_1) &&
+        (MXC_GET_FIELD(val, IIM_PROD_REV_LEN, IIM_PROD_REV_SH) !=
+        PROD_SIGNATURE_SUPPORTED_2)){
+        return CHIP_VERSION_NONE;
+    }
+
+    /* Check if this is MX32 chip */
+    if (MXC_GET_FIELD(val, IIM_PROD_REV_LEN, IIM_PROD_REV_SH) ==
+        PROD_SIGNATURE_MX32) {
+        system_rev = 0x32 << PART_NUMBER_OFFSET; /* For MX32 Platform*/
+        if (g_board_type == BOARD_TYPE_ADS) {
+            HAL_PLATFORM_EXTRA[3] = '2';
+            HAL_PLATFORM_EXTRA[25] = '2';
+        } else if (g_board_type == BOARD_TYPE_3STACK) {
+            HAL_PLATFORM_EXTRA[3] = '2';
+            HAL_PLATFORM_EXTRA[29] = '2';
+        }
+    } else {
+        system_rev = 0x31 << PART_NUMBER_OFFSET; /* For MX31 Platform*/
+    }
+
+    /* Now trying to retrieve the silicon rev from IIM's SREV register */
+    return readl(IIM_BASE_ADDR + IIM_SREV_OFF);
+}
+
+extern nfc_setup_func_t *nfc_setup;
+unsigned int mxc_nfc_soc_setup(unsigned int pg_sz, unsigned int io_sz,
+                                      unsigned int is_mlc);
+void hal_hardware_init(void)
+{
+    volatile unsigned int esdmisc = readl(ESDCTL_BASE + 0x10);
+    volatile unsigned int esdctl0 = readl(ESDCTL_BASE);
+    int ver;
+    char chip_ver[2];
+
+    // Perform any platform specific initializations
+    plf_hardware_init();
+
+    ver = read_system_rev();
+
+    find_correct_chip = ver;
+
+    if (ver != CHIP_VERSION_NONE) {
+        /* Valid product revision found. Check actual silicon rev and
+         * NOT use the version from the ROM code. */
+        if (((ver >> 4) & 0xF) == 0x0) {
+            chip_ver[0] = '1';
+            chip_ver[1] = '0';
+            system_rev |= 1 << MAJOR_NUMBER_OFFSET      ;/*Major Number*/
+            system_rev |= 0 << MINOR_NUMBER_OFFSET      ;/*Minor Number*/
+        } else if (((ver >> 4) & 0xF) == 0x1) {
+            chip_ver[0] = '1';
+            chip_ver[1] = '1';
+            system_rev |= 1 << MAJOR_NUMBER_OFFSET      ;/*Major Number*/
+            system_rev |= 1 << MINOR_NUMBER_OFFSET      ;/*Minor Number*/
+        } else if (((ver >> 4) & 0xF) == 0x2) {
+            chip_ver[0] = '2';
+            chip_ver[1] = '0';
+            system_rev |= 2 << MAJOR_NUMBER_OFFSET      ;/*Major Number*/
+            system_rev |= 0 << MINOR_NUMBER_OFFSET      ;/*Minor Number*/
+        } else {
+            chip_ver[0] = 'x';
+            chip_ver[1] = 'x';
+            system_rev |= 1 << MAJOR_NUMBER_OFFSET      ;/*Major Number*/
+            system_rev |= 0 << MINOR_NUMBER_OFFSET      ;/*Minor Number*/
+            find_correct_chip = CHIP_VERSION_UNKNOWN;
+        }
+    }
+
+    if (g_board_type == BOARD_TYPE_ADS) {
+        HAL_PLATFORM_EXTRA[39] = chip_ver[0];
+        HAL_PLATFORM_EXTRA[41] = chip_ver[1];
+        if ((esdmisc & 0x4) == 0) {
+            HAL_PLATFORM_EXTRA[48] = 'S';
+        }
+        if ((esdctl0 & 0x30000) != 0x20000) {
+            HAL_PLATFORM_EXTRA[45] = '1';
+            HAL_PLATFORM_EXTRA[46] = '6';
+        }
+    } else if (g_board_type == BOARD_TYPE_3STACK) {
+        HAL_PLATFORM_EXTRA[43] = chip_ver[0];
+        HAL_PLATFORM_EXTRA[45] = chip_ver[1];
+        if ((esdmisc & 0x4) == 0) {
+            HAL_PLATFORM_EXTRA[52] = 'S';
+        }
+        if ((esdctl0 & 0x30000) != 0x20000) {
+            HAL_PLATFORM_EXTRA[49] = '1';
+            HAL_PLATFORM_EXTRA[50] = '6';
+        }
+    }
+
+    // Mask all interrupts
+    writel(0xFFFFFFFF, AVIC_NIMASK);
+
+    // Make all interrupts do IRQ and not FIQ
+    // FIXME: Change this if you use FIQs.
+    writel(0, AVIC_INTTYPEH);
+    writel(0, AVIC_INTTYPEL);
+
+    // Enable caches
+    HAL_ICACHE_ENABLE();
+    HAL_DCACHE_ENABLE();
+
+    // enable EPIT and start it with 32KHz input clock
+    writel(0x00010000, EPIT_BASE_ADDR + EPITCR);
+
+    // make sure reset is complete
+    while ((readl(EPIT_BASE_ADDR + EPITCR) & 0x10000) != 0) {
+    }
+
+    writel(0x030E0002, EPIT_BASE_ADDR + EPITCR);
+    writel(0x030E0003, EPIT_BASE_ADDR + EPITCR);
+
+    writel(0, EPIT_BASE_ADDR + EPITCMPR);  // always compare with 0
+
+    if ((readw(WDOG_BASE_ADDR) & 4) != 0) {
+        // increase the WDOG timeout value to the max
+        writew(readw(WDOG_BASE_ADDR) | 0xFF00, WDOG_BASE_ADDR);
+    }
+
+    // Set up eCos/ROM interfaces
+    hal_if_init();
+
+    nfc_setup = (nfc_setup_func_t*)mxc_nfc_soc_setup;
+}
+
+// -------------------------------------------------------------------------
+void hal_clock_initialize(cyg_uint32 period)
+{
+}
+
+// This routine is called during a clock interrupt.
+
+// Define this if you want to ensure that the clock is perfect (i.e. does
+// not drift).  One reason to leave it turned off is that it costs some
+// us per system clock interrupt for this maintenance.
+#undef COMPENSATE_FOR_CLOCK_DRIFT
+
+void hal_clock_reset(cyg_uint32 vector, cyg_uint32 period)
+{
+}
+
+// Read the current value of the clock, returning the number of hardware
+// "ticks" that have occurred (i.e. how far away the current value is from
+// the start)
+
+// Note: The "contract" for this function is that the value is the number
+// of hardware clocks that have happened since the last interrupt (i.e.
+// when it was reset).  This value is used to measure interrupt latencies.
+// However, since the hardware counter runs freely, this routine computes
+// the difference between the current clock period and the number of hardware
+// ticks left before the next timer interrupt.
+void hal_clock_read(cyg_uint32 *pvalue)
+{
+}
+
+// This is to cope with the test read used by tm_basic with
+// CYGVAR_KERNEL_COUNTERS_CLOCK_LATENCY defined; we read the count ASAP
+// in the ISR, *before* resetting the clock.  Which returns 1tick +
+// latency if we just use plain hal_clock_read().
+void hal_clock_latency(cyg_uint32 *pvalue)
+{
+}
+
+unsigned int hal_timer_count(void)
+{
+    return (0xFFFFFFFF - readl(EPIT_BASE_ADDR + EPITCNR));
+}
+
+#define WDT_MAGIC_1             0x5555
+#define WDT_MAGIC_2             0xAAAA
+#define MXC_WDT_WSR             0x2
+
+unsigned int i2c_base_addr[] = {
+    I2C_BASE_ADDR,
+    I2C2_BASE_ADDR,
+    I2C3_BASE_ADDR
+};
+unsigned int i2c_num = 3;
+
+static unsigned int led_on = 0;
+//
+// Delay for some number of micro-seconds
+//
+void hal_delay_us(unsigned int usecs)
+{
+    /*
+     * This causes overflow.
+     * unsigned int delayCount = (usecs * 32768) / 1000000;
+     * So use the following one instead
+     */
+    unsigned int delayCount = (usecs * 512) / 15625;
+
+    if (delayCount == 0) {
+        return;
+    }
+
+    // issue the service sequence instructions
+    if ((readw(WDOG_BASE_ADDR) & 4) != 0) {
+        writew(WDT_MAGIC_1, WDOG_BASE_ADDR + MXC_WDT_WSR);
+        writew(WDT_MAGIC_2, WDOG_BASE_ADDR + MXC_WDT_WSR);
+    }
+
+    writel(0x01, EPIT_BASE_ADDR + EPITSR); // clear the compare status bit
+
+    writel(delayCount, EPIT_BASE_ADDR + EPITLR);
+
+    while ((0x1 & readl(EPIT_BASE_ADDR + EPITSR)) == 0); // return until compare bit is set
+    if ((++led_on % 2000) == 0)
+        BOARD_DEBUG_LED(0);
+}
+
+// -------------------------------------------------------------------------
+
+// This routine is called to respond to a hardware interrupt (IRQ).  It
+// should interrogate the hardware and return the IRQ vector number.
+int hal_IRQ_handler(void)
+{
+#ifdef HAL_EXTENDED_IRQ_HANDLER
+    cyg_uint32 index;
+
+    // Use platform specific IRQ handler, if defined
+    // Note: this macro should do a 'return' with the appropriate
+    // interrupt number if such an extended interrupt exists.  The
+    // assumption is that the line after the macro starts 'normal' processing.
+    HAL_EXTENDED_IRQ_HANDLER(index);
+#endif
+
+    return CYGNUM_HAL_INTERRUPT_NONE; // This shouldn't happen!
+}
+
+//
+// Interrupt control
+//
+
+void hal_interrupt_mask(int vector)
+{
+//    diag_printf("6hal_interrupt_mask(vector=%d) \n", vector);
+#ifdef HAL_EXTENDED_INTERRUPT_MASK
+    // Use platform specific handling, if defined
+    // Note: this macro should do a 'return' for "extended" values of 'vector'
+    // Normal vectors are handled by code subsequent to the macro call.
+    HAL_EXTENDED_INTERRUPT_MASK(vector);
+#endif
+}
+
+void hal_interrupt_unmask(int vector)
+{
+//    diag_printf("7hal_interrupt_unmask(vector=%d) \n", vector);
+
+#ifdef HAL_EXTENDED_INTERRUPT_UNMASK
+    // Use platform specific handling, if defined
+    // Note: this macro should do a 'return' for "extended" values of 'vector'
+    // Normal vectors are handled by code subsequent to the macro call.
+    HAL_EXTENDED_INTERRUPT_UNMASK(vector);
+#endif
+}
+
+void hal_interrupt_acknowledge(int vector)
+{
+
+//    diag_printf("8hal_interrupt_acknowledge(vector=%d) \n", vector);
+#ifdef HAL_EXTENDED_INTERRUPT_UNMASK
+    // Use platform specific handling, if defined
+    // Note: this macro should do a 'return' for "extended" values of 'vector'
+    // Normal vectors are handled by code subsequent to the macro call.
+    HAL_EXTENDED_INTERRUPT_ACKNOWLEDGE(vector);
+#endif
+}
+
+void hal_interrupt_configure(int vector, int level, int up)
+{
+
+#ifdef HAL_EXTENDED_INTERRUPT_CONFIGURE
+    // Use platform specific handling, if defined
+    // Note: this macro should do a 'return' for "extended" values of 'vector'
+    // Normal vectors are handled by code subsequent to the macro call.
+    HAL_EXTENDED_INTERRUPT_CONFIGURE(vector, level, up);
+#endif
+}
+
+void hal_interrupt_set_level(int vector, int level)
+{
+
+#ifdef HAL_EXTENDED_INTERRUPT_SET_LEVEL
+    // Use platform specific handling, if defined
+    // Note: this macro should do a 'return' for "extended" values of 'vector'
+    // Normal vectors are handled by code subsequent to the macro call.
+    HAL_EXTENDED_INTERRUPT_SET_LEVEL(vector, level);
+#endif
+
+    // Interrupt priorities are not configurable.
+}
+
+unsigned int mxc_nfc_soc_setup(unsigned int pg_sz, unsigned int io_sz, unsigned int is_mlc)
+{
+    unsigned int tmp, res = -1;
+
+    if (is_mlc) {
+        tmp = readw(NAND_REG_BASE + NAND_FLASH_CONFIG1_REG_OFF) | (1 << 9);
+    } else {
+        tmp = readw(NAND_REG_BASE + NAND_FLASH_CONFIG1_REG_OFF) & (~(1 << 9));
+    }
+    writew(tmp, NAND_REG_BASE + NAND_FLASH_CONFIG1_REG_OFF);
+
+    if (pg_sz == 2048) {
+        tmp = readl(CCM_BASE_ADDR + CLKCTL_RCSR) | (1 << 30);
+    } else {
+        tmp = readl(CCM_BASE_ADDR + CLKCTL_RCSR) & (~(1 << 30));
+    }
+    writel(tmp, CCM_BASE_ADDR + CLKCTL_RCSR);
+
+    if (io_sz == 16) {
+        tmp = readl(CCM_BASE_ADDR + CLKCTL_RCSR) | (1 << 31);
+    } else {
+        tmp = readl(CCM_BASE_ADDR + CLKCTL_RCSR) & (~(1 << 31));
+    }
+    writel(tmp, CCM_BASE_ADDR + CLKCTL_RCSR);
+
+    tmp = system_rev >> PART_NUMBER_OFFSET;
+    switch (tmp) {
+    case 0x31:
+        res = MXC_NFC_V1;
+        break;
+    case 0x32:
+        res = MXC_NFC_V2;
+        break;
+    default:
+        diag_printf("Unknown chip version: 0x%x\n", tmp);
+        break;
+    }
+    return res;
+}
+
+static void check_correct_chip(void)
+{
+    if (find_correct_chip == CHIP_VERSION_UNKNOWN) {
+        diag_printf("Unrecognized chip version: 0x%x!!!\n", read_system_rev());
+        diag_printf("Assuming chip version=0x%x\n", system_rev);
+    } else if (find_correct_chip == CHIP_VERSION_NONE) {
+        diag_printf("Unrecognized chip: 0x%x!!!\n", readl(IIM_BASE_ADDR + IIM_PREV_OFF));
+    }
+}
+
+RedBoot_init(check_correct_chip, RedBoot_INIT_LAST);
